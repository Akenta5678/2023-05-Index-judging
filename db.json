{"issues":[{"file":"001.md","watson":{"name":"PRAISE","days":64,"is_team":false,"payout":403.7,"score":1.9031785617,"senior":false},"severity":"high","title":"ETH can be stuck in the SetToken.sol contract as it has the receive() function but doesn't have a method for the withdrawal of the sent ETH","markdown":"PRAISE\n\nhigh\n\n# ETH can be stuck in the SetToken.sol contract as it has the receive() function but doesn't have a method for the withdrawal of the sent ETH\n\n## Summary\ncontracts with the `receive()` function can receive ETH\n\n## Vulnerability Detail\nNow there are many cases of ETH that has been permanently lost on chain because a contract received ETH when it's not supposed to and has no method for the ETH to be withdrawn.\n\n## Impact\nThe SetToken.sol contract can receive ETH when it's not supposed to and it has no method for the ETH to be withdrawn.\nETH will be permanently locked in the contract.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/SetToken.sol#L536\n## Tool used\n\nManual Review\n\n## Recommendation\nplease remove the receive() function","decidedSeverity":"false","decidedDuplication":"ETH can be stuck in the SetToken.sol contract as it has the receive() function but doesn't have a method for the withdrawal of the sent ETH"},{"file":"002.md","watson":{"name":"volodya","days":18,"is_team":false,"payout":346.86,"score":12.1469219611,"senior":false},"severity":"medium","title":"globalLastTradeTimestamp is not up to date inside AaveLeverageStrategyExtension","markdown":"volodya\n\nmedium\n\n# globalLastTradeTimestamp is not up to date inside AaveLeverageStrategyExtension\n\n## Summary\nglobalLastTradeTimestamp not being up to date which leads system not working as expected\n## Vulnerability Detail\nThere are comments in the file that globalLastTradeTimestamp is always updated whenever an exchange happens\n> Update globalLastTradeTimestamp and exchangeLastTradeTimestamp values. This function updates both the exchange-specific and global timestamp so that the\n     * epoch rebalance can use the global timestamp (since the global timestamp is always  equal to the most recently used exchange timestamp).\n     \nbut inside disengage, there is an exchange - `_delever`, `_deleverToZeroBorrowBalance`but that variable is not being updated\n```solidity\n    function disengage(string memory _exchangeName) external onlyOperator {\n        LeverageInfo memory leverageInfo = _getAndValidateLeveragedInfo(\n            execution.slippageTolerance,\n            exchangeSettings[_exchangeName].twapMaxTradeSize,\n            _exchangeName\n        );\n\n        uint256 newLeverageRatio = PreciseUnitMath.preciseUnit();\n        (\n            uint256 chunkRebalanceNotional,\n            uint256 totalRebalanceNotional\n        ) = _calculateChunkRebalanceNotional(leverageInfo, newLeverageRatio, false);\n\n        if (totalRebalanceNotional > chunkRebalanceNotional) {\n            _delever(leverageInfo, chunkRebalanceNotional);\n        } else {\n            _deleverToZeroBorrowBalance(leverageInfo, totalRebalanceNotional);\n        }\n//      @audit\n//        _updateLastTradeTimestamp(_exchangeName);\n\n        emit Disengaged(\n            leverageInfo.currentLeverageRatio,\n            newLeverageRatio,\n            chunkRebalanceNotional,\n            totalRebalanceNotional\n        );\n    }\n```\n[adapters/AaveLeverageStrategyExtension.sol#L412](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L412)\n## Impact\nThe system doesn't work as expected\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n```diff\n    function disengage(string memory _exchangeName) external onlyOperator {\n        LeverageInfo memory leverageInfo = _getAndValidateLeveragedInfo(\n            execution.slippageTolerance,\n            exchangeSettings[_exchangeName].twapMaxTradeSize,\n            _exchangeName\n        );\n\n        uint256 newLeverageRatio = PreciseUnitMath.preciseUnit();\n        (\n            uint256 chunkRebalanceNotional,\n            uint256 totalRebalanceNotional\n        ) = _calculateChunkRebalanceNotional(leverageInfo, newLeverageRatio, false);\n\n        if (totalRebalanceNotional > chunkRebalanceNotional) {\n            _delever(leverageInfo, chunkRebalanceNotional);\n        } else {\n            _deleverToZeroBorrowBalance(leverageInfo, totalRebalanceNotional);\n        }\n+        _updateLastTradeTimestamp(_exchangeName);\n\n        emit Disengaged(\n            leverageInfo.currentLeverageRatio,\n            newLeverageRatio,\n            chunkRebalanceNotional,\n            totalRebalanceNotional\n        );\n    }\n```\n","decidedSeverity":"false","decidedDuplication":"globalLastTradeTimestamp is not up to date inside AaveLeverageStrategyExtension"},{"file":"003.md","watson":{"name":"volodya","days":18,"is_team":false,"payout":346.86,"score":12.1469219611,"senior":false},"severity":"medium","title":"Integrating with AaveLeverageStrategyExtension will cause external contracts and keeper bots to not function due to typo","markdown":"volodya\n\nmedium\n\n# Integrating with AaveLeverageStrategyExtension will cause external contracts and keeper bots to not function due to typo\n\n## Summary\nIntegrating with AaveLeverageStrategyExtension will cause external contracts and keeper bots to not function.\n E.x. from [comments](https://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/adapters/AaveLeverageStrategyExtension.sol#L604)\n> Calculates the chunk rebalance size. This can be used by external contracts and keeper bots to calculate the optimal exchange to rebalance with.\n## Vulnerability Detail\n\nThis is how currently info is being created\n```solidity\n    function getChunkRebalanceNotional(\n        string[] calldata _exchangeNames\n    )\n        external\n        view\n        returns(uint256[] memory sizes, address sellAsset, address buyAsset)\n    {\n\n        uint256 newLeverageRatio;\n        uint256 currentLeverageRatio = getCurrentLeverageRatio();\n        bool isRipcord = false;\n\n        // if over incentivized leverage ratio, always ripcord\n        if (currentLeverageRatio > incentive.incentivizedLeverageRatio) {\n            newLeverageRatio = methodology.maxLeverageRatio;\n            isRipcord = true;\n        // if we are in an ongoing twap, use the cached twapLeverageRatio as our target leverage\n        } else if (twapLeverageRatio > 0) {\n            newLeverageRatio = twapLeverageRatio;\n        // if all else is false, then we would just use the normal rebalance new leverage ratio calculation\n        } else {\n            newLeverageRatio = _calculateNewLeverageRatio(currentLeverageRatio);\n        }\n\n        ActionInfo memory actionInfo = _createActionInfo();\n        bool isLever = newLeverageRatio > currentLeverageRatio;\n\n        sizes = new uint256[](_exchangeNames.length);\n\n        for (uint256 i = 0; i < _exchangeNames.length; i++) {\n    \n            LeverageInfo memory leverageInfo = LeverageInfo({\n                action: actionInfo,\n                currentLeverageRatio: currentLeverageRatio,\n                slippageTolerance: isRipcord ? incentive.incentivizedSlippageTolerance : execution.slippageTolerance,\n                twapMaxTradeSize: isRipcord ?\n                    exchangeSettings[_exchangeNames[i]].incentivizedTwapMaxTradeSize :\n                    exchangeSettings[_exchangeNames[i]].twapMaxTradeSize,\n                exchangeName: _exchangeNames[i]\n            });\n\n            (uint256 collateralNotional, ) = _calculateChunkRebalanceNotional(leverageInfo, newLeverageRatio, isLever);\n\n            // _calculateBorrowUnits can convert both unit and notional values\n            sizes[i] = isLever ? _calculateBorrowUnits(collateralNotional, leverageInfo.action) : collateralNotional;\n        }\n\n        sellAsset = isLever ? strategy.borrowAsset : strategy.collateralAsset;\n        buyAsset = isLever ? strategy.collateralAsset : strategy.borrowAsset;\n    }\n\n```\n[contracts/adapters/AaveLeverageStrategyExtension.sol#L655](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L627)\n\nLet's look at how the system validates ripcord - `_leverageInfo.currentLeverageRatio >= incentive.incentivizedLeverageRatio` and not `_leverageInfo.currentLeverageRatio > incentive.incentivizedLeverageRatio`\n```solidity\n    function _validateRipcord(LeverageInfo memory _leverageInfo, uint256 _lastTradeTimestamp) internal view {\n        require(_leverageInfo.currentLeverageRatio >= incentive.incentivizedLeverageRatio, \"Must be above incentivized leverage ratio\");\n        // If currently in the midst of a TWAP rebalance, ensure that the cooldown period has elapsed\n        require(_lastTradeTimestamp.add(incentive.incentivizedTwapCooldownPeriod) < block.timestamp, \"TWAP cooldown must have elapsed\");\n    }\n\n```\n## Impact\nIntegrating with AaveLeverageStrategyExtension will cause external contracts and keeper bots to not function.\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n```diff\n    function getChunkRebalanceNotional(\n        string[] calldata _exchangeNames\n    )\n        external\n        view\n        returns(uint256[] memory sizes, address sellAsset, address buyAsset)\n    {\n\n        uint256 newLeverageRatio;\n        uint256 currentLeverageRatio = getCurrentLeverageRatio();\n        bool isRipcord = false;\n\n        // if over incentivized leverage ratio, always ripcord\n-        if (currentLeverageRatio > incentive.incentivizedLeverageRatio) {\n+       if (currentLeverageRatio >= incentive.incentivizedLeverageRatio) {\n            newLeverageRatio = methodology.maxLeverageRatio;\n            isRipcord = true;\n        // if we are in an ongoing twap, use the cached twapLeverageRatio as our target leverage\n        } else if (twapLeverageRatio > 0) {\n            newLeverageRatio = twapLeverageRatio;\n        // if all else is false, then we would just use the normal rebalance new leverage ratio calculation\n        } else {\n            newLeverageRatio = _calculateNewLeverageRatio(currentLeverageRatio);\n        }\n\n        ActionInfo memory actionInfo = _createActionInfo();\n        bool isLever = newLeverageRatio > currentLeverageRatio;\n\n        sizes = new uint256[](_exchangeNames.length);\n\n        for (uint256 i = 0; i < _exchangeNames.length; i++) {\n    \n            LeverageInfo memory leverageInfo = LeverageInfo({\n                action: actionInfo,\n                currentLeverageRatio: currentLeverageRatio,\n                slippageTolerance: isRipcord ? incentive.incentivizedSlippageTolerance : execution.slippageTolerance,\n                twapMaxTradeSize: isRipcord ?\n                    exchangeSettings[_exchangeNames[i]].incentivizedTwapMaxTradeSize :\n                    exchangeSettings[_exchangeNames[i]].twapMaxTradeSize,\n                exchangeName: _exchangeNames[i]\n            });\n\n            (uint256 collateralNotional, ) = _calculateChunkRebalanceNotional(leverageInfo, newLeverageRatio, isLever);\n\n            // _calculateBorrowUnits can convert both unit and notional values\n            sizes[i] = isLever ? _calculateBorrowUnits(collateralNotional, leverageInfo.action) : collateralNotional;\n        }\n\n        sellAsset = isLever ? strategy.borrowAsset : strategy.collateralAsset;\n        buyAsset = isLever ? strategy.collateralAsset : strategy.borrowAsset;\n    }\n\n```\n","decidedSeverity":"false","decidedDuplication":"Integrating with AaveLeverageStrategyExtension will cause external contracts and keeper bots to not function due to typo"},{"file":"004.md","watson":{"name":"volodya","days":18,"is_team":false,"payout":346.86,"score":12.1469219611,"senior":false},"severity":"medium","title":"Deprecated chainlink oracle","markdown":"volodya\n\nmedium\n\n# Deprecated chainlink oracle\n\n## Summary\nDeprecated chainlink oracle leads to incorrect and stale prices\n\n## Vulnerability Detail\nAccording to chainlink [docs](https://docs.chain.link/data-feeds/api-reference#latestanswer) latestAnswer shouldn't be used\n> latestAnswer | (Deprecated - Do not use this function.)\n\nlatestAnswer is being used in the code and there is no check for stale prices\n```solidity\n    function _createActionInfo() internal view returns(ActionInfo memory) {\n        ActionInfo memory rebalanceInfo;\n\n        // Calculate prices from chainlink. Chainlink returns prices with 8 decimal places, but we need 36 - underlyingDecimals decimal places.\n        // This is so that when the underlying amount is multiplied by the received price, the collateral valuation is normalized to 36 decimals.\n        // To perform this adjustment, we multiply by 10^(36 - 8 - underlyingDecimals)\n//      @audit latestAnswer\t(Deprecated - Do not use this function.)\n//      https://docs.chain.link/getting-started/consuming-data-feeds\n        int256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\n        rebalanceInfo.collateralPrice = rawCollateralPrice.toUint256().mul(10 ** strategy.collateralDecimalAdjustment);\n        int256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer();\n        rebalanceInfo.borrowPrice = rawBorrowPrice.toUint256().mul(10 ** strategy.borrowDecimalAdjustment);\n\n        rebalanceInfo.collateralBalance = strategy.targetCollateralAToken.balanceOf(address(strategy.setToken));\n        rebalanceInfo.borrowBalance = strategy.targetBorrowDebtToken.balanceOf(address(strategy.setToken));\n        rebalanceInfo.collateralValue = rebalanceInfo.collateralPrice.preciseMul(rebalanceInfo.collateralBalance);\n        rebalanceInfo.borrowValue = rebalanceInfo.borrowPrice.preciseMul(rebalanceInfo.borrowBalance);\n        rebalanceInfo.setTotalSupply = strategy.setToken.totalSupply();\n\n        return rebalanceInfo;\n    }\n```\n[adapters/AaveLeverageStrategyExtension.sol#L889](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L895)\n## Impact\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\nUse latestRoundData and check for stale prices\n\n```solidity\n            (uint80 roundId, int256 assetChainlinkPriceInt, , uint256 updatedAt, uint80 answeredInRound) = strategy.collateralPriceOracle.latestRoundData();\n            require(answeredInRound >= roundId, \"price is stale\");\n            require(updatedAt > 0, \"round is incomplete\");\n            int256 rawCollateralPrice = assetChainlinkPriceInt;\n```","decidedSeverity":"medium","decidedDuplication":"Deprecated oracle function `latestAnswer()` could bring fund loss"},{"file":"005.md","watson":{"name":"volodya","days":18,"is_team":false,"payout":346.86,"score":12.1469219611,"senior":false},"severity":"medium","title":"AaveLeverageStrategyExtension doesn't work with turned on Efficiency Mode","markdown":"volodya\n\nmedium\n\n# AaveLeverageStrategyExtension doesn't work with turned on Efficiency Mode\n\n## Summary\nAaveLeverageStrategyExtension doesn't work with turned-on Efficiency Mode. Incorrect \n\n- LTV (Loan to value)\n- Liquidation threshold\n- Liquidation bonus\n- A custom price oracle (optional)\n\n## Vulnerability Detail\nAccording to aave [docs](https://docs.aave.com/developers/whats-new/efficiency-mode-emode) whenever a pool in eMode it does how its own \n\n- LTV (Loan to value)\n- Liquidation threshold\n- Liquidation bonus\n- A custom price oracle (optional)\n\nWhenever pool in eMode these params are not being fetched but instead using the same params as if eMode is not on which leads to the system having unexpected issues.\n\nYou can see from Morpho protocol that they are using different ltv and other params if pool in eMode\n```solidity\n function _assetLiquidityData(address underlying, Types.LiquidityVars memory vars)\n        internal\n        view\n        returns (uint256 underlyingPrice, uint256 ltv, uint256 liquidationThreshold, uint256 underlyingUnit)\n    {\n        DataTypes.ReserveConfigurationMap memory config = _pool.getConfiguration(underlying);\n\n        bool isInEMode;\n        (isInEMode, underlyingPrice, underlyingUnit) =\n            _assetData(underlying, vars.oracle, config, vars.eModeCategory.priceSource);\n\n        // If the LTV is 0 on Aave V3, the asset cannot be used as collateral to borrow upon a breaking withdraw.\n        // In response, Morpho disables the asset as collateral and sets its liquidation threshold\n        // to 0 and the governance should warn users to repay their debt.\n        if (config.getLtv() == 0) return (underlyingPrice, 0, 0, underlyingUnit);\n\n        if (isInEMode) {\n            ltv = vars.eModeCategory.ltv;\n            liquidationThreshold = vars.eModeCategory.liquidationThreshold;\n        } else {\n            ltv = config.getLtv();\n            liquidationThreshold = config.getLiquidationThreshold();\n        }\n    }\n```\n[src/MorphoInternal.sol#L322](https://github.com/morpho-org/morpho-aave-v3/blob/0f494b8321d20789692e50305532b7f1b8fb23ef/src/MorphoInternal.sol#L322)\n\nHowever, in Index eMode is not being used to determine ltv, liquidationThreshold and other params\n```solidity\n    function _calculateMaxBorrowCollateral(ActionInfo memory _actionInfo, bool _isLever) internal view returns(uint256) {\n        \n        // Retrieve collateral factor and liquidation threshold for the collateral asset in precise units (1e16 = 1%)\n        ( , uint256 maxLtvRaw, uint256 liquidationThresholdRaw, , , , , , ,) = strategy.aaveProtocolDataProvider.getReserveConfigurationData(address(strategy.collateralAsset));\n\n        // Normalize LTV and liquidation threshold to precise units. LTV is measured in 4 decimals in Aave which is why we must multiply by 1e14\n        // for example ETH has an LTV value of 8000 which represents 80%\n        if (_isLever) {\n            uint256 netBorrowLimit = _actionInfo.collateralValue\n                .preciseMul(maxLtvRaw.mul(10 ** 14))\n                .preciseMul(PreciseUnitMath.preciseUnit().sub(execution.unutilizedLeveragePercentage));\n\n            return netBorrowLimit\n                .sub(_actionInfo.borrowValue)\n                .preciseDiv(_actionInfo.collateralPrice);\n        } else {\n            uint256 netRepayLimit = _actionInfo.collateralValue\n                .preciseMul(liquidationThresholdRaw.mul(10 ** 14))\n                .preciseMul(PreciseUnitMath.preciseUnit().sub(execution.unutilizedLeveragePercentage));\n\n            return _actionInfo.collateralBalance\n                .preciseMul(netRepayLimit.sub(_actionInfo.borrowValue))\n                .preciseDiv(netRepayLimit);\n        }\n    }\n\n```\n[adapters/AaveLeverageStrategyExtension.sol#L1095](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1095)\n## Impact\nSystem will not work properly in eMode\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\nFirst, add global eModCategoryId variable which will be 0 by default\n```diff\n    function setEModeCategory(uint8 _categoryId) external onlyOperator {\n+        eModCategoryId = _categoryId;\n        _setEModeCategory(_categoryId);\n    }\n```\nfetch data from eMode if its not 0, also do the same for oracle, like Morho is doing\n```diff\n    function _calculateMaxBorrowCollateral(ActionInfo memory _actionInfo, bool _isLever) internal view returns(uint256) {\n        \n        // Retrieve collateral factor and liquidation threshold for the collateral asset in precise units (1e16 = 1%)\n        ( , uint256 maxLtvRaw, uint256 liquidationThresholdRaw, , , , , , ,) = strategy.aaveProtocolDataProvider.getReserveConfigurationData(address(strategy.collateralAsset));\n\n+        if (eModCategoryId > 0) {\n+            eModeCategory = _pool.getEModeCategoryData(eModCategoryId);\n+            maxLtvRaw = eModeCategory.ltv;\n+            liquidationThreshold = eModeCategory.liquidationThreshold;\n+        }\n\n        // Normalize LTV and liquidation threshold to precise units. LTV is measured in 4 decimals in Aave which is why we must multiply by 1e14\n        // for example ETH has an LTV value of 8000 which represents 80%\n        if (_isLever) {\n            uint256 netBorrowLimit = _actionInfo.collateralValue\n                .preciseMul(maxLtvRaw.mul(10 ** 14))\n                .preciseMul(PreciseUnitMath.preciseUnit().sub(execution.unutilizedLeveragePercentage));\n\n            return netBorrowLimit\n                .sub(_actionInfo.borrowValue)\n                .preciseDiv(_actionInfo.collateralPrice);\n        } else {\n            uint256 netRepayLimit = _actionInfo.collateralValue\n                .preciseMul(liquidationThresholdRaw.mul(10 ** 14))\n                .preciseMul(PreciseUnitMath.preciseUnit().sub(execution.unutilizedLeveragePercentage));\n\n            return _actionInfo.collateralBalance\n                .preciseMul(netRepayLimit.sub(_actionInfo.borrowValue))\n                .preciseDiv(netRepayLimit);\n        }\n    }\n\n```\n","decidedSeverity":"false","decidedDuplication":"AaveLeverageStrategyExtension doesn't work with turned on Efficiency Mode"},{"file":"006.md","watson":{"name":"0xGoodess","days":60,"is_team":false,"payout":1471.42,"score":8.6947821081,"senior":false},"severity":"medium","title":"no checks on chainlink stale price on _createActionInfo","markdown":"0xGoodess\n\nmedium\n\n# no checks on chainlink stale price on _createActionInfo\n\n## Summary\nno checks on chainlink stale price on _createActionInfo\n\n## Vulnerability Detail\nno checks on chainlink stale price on _createActionInfo\n\n```solidity\n    function _createActionInfo() internal view returns(ActionInfo memory) {\n        ActionInfo memory rebalanceInfo;\n\n        // Calculate prices from chainlink. Chainlink returns prices with 8 decimal places, but we need 36 - underlyingDecimals decimal places.\n        // This is so that when the underlying amount is multiplied by the received price, the collateral valuation is normalized to 36 decimals. \n        // To perform this adjustment, we multiply by 10^(36 - 8 - underlyingDecimals)\n        int256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\n        rebalanceInfo.collateralPrice = rawCollateralPrice.toUint256().mul(10 ** strategy.collateralDecimalAdjustment);\n        int256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer();\n        rebalanceInfo.borrowPrice = rawBorrowPrice.toUint256().mul(10 ** strategy.borrowDecimalAdjustment);\n\n        rebalanceInfo.collateralBalance = strategy.targetCollateralAToken.balanceOf(address(strategy.setToken));\n        rebalanceInfo.borrowBalance = strategy.targetBorrowDebtToken.balanceOf(address(strategy.setToken));\n        rebalanceInfo.collateralValue = rebalanceInfo.collateralPrice.preciseMul(rebalanceInfo.collateralBalance);\n        rebalanceInfo.borrowValue = rebalanceInfo.borrowPrice.preciseMul(rebalanceInfo.borrowBalance);\n        rebalanceInfo.setTotalSupply = strategy.setToken.totalSupply();\n\n        return rebalanceInfo;\n    }\n\n```\n\n## Impact\nstale price might be used for calculating index token price\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L889-L907\n\n## Tool used\n\nManual Review\n\n## Recommendation\nadd a time threshold check on latestAnswer.\n","decidedSeverity":"medium","decidedDuplication":"Chainlink's latestRoundData return stale or incorrect result"},{"file":"007.md","watson":{"name":"0xGoodess","days":60,"is_team":false,"payout":1471.42,"score":8.6947821081,"senior":false},"severity":"high","title":"protocol would fails to delever without flashloan when the collateral value falls short of the LTV requirement","markdown":"0xGoodess\n\nhigh\n\n# protocol would fails to delever without flashloan when the collateral value falls short of the LTV requirement\n\n## Summary\nprotocol would fails to delever without flashloan when the collateral value falls short of the LTV requirement\n\n## Vulnerability Detail\nWith reference to [ETH Strat](https://indexcoop.com/products/interest-compounding-eth-index), consider a case of ETH strategy of -175% ETH + 275% stETH with targeted 2.75 leverage. The aave-v3 LTV of wstETH is 68.5%, and liquidation threshold is 79.5% with [eMode disabled](https://app.aave.com/reserve-overview/?underlyingAsset=0x7f39c581f595b53c5cb19bd0b3f8da6c935e2ca0&marketName=proto_mainnet_v3). \n\nWhen stETH is fully pegged to ETH, then the protocol has a health factor of 275 * 0.795 / 175 = 1.249.\n\nWhen stETH depegs, leading to an increase in leverage, the protocol needs to sell off stETH to bring down the leverage; However since the LTV of stETH is only 68.5%, that means stETH cannot be withdrawn, when stETH price drops to 0.929. \n(The maths comes in this way: 275 * 0.929 => 175) When `collateral * LTV <= borrowed asset`, withdrawal of collateral is disabled in aave. (health factor is still above 1 so the position is free from liquidation.)\n\nNormal withdrawal path would not be possible due to collateral value falls under LTV requirement now\n\nIn this scenario, the protocol can only delever through the use of flashloan:\n1. Flashloan some ETH, deposit in the position to increase the LTV\n2. withdraw the required amount of wstETH, sell-off to ETH.\n3. Withdraw the difference in ETH needed, return the flashloan plus flashloan premium.\n\n## Impact\nprotocol would fails to delever without flashloan when the withdrawal amount exceeds the LTV requirement\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L775-L797\n\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider add a delever path that uses flashloan when the traditional withdrawal fails.","decidedSeverity":"false","decidedDuplication":"protocol would fails to delever without flashloan when the collateral value falls short of the LTV requirement"},{"file":"008.md","watson":{"name":"0xGoodess","days":60,"is_team":false,"payout":1471.42,"score":8.6947821081,"senior":false},"severity":"medium","title":"rebalance would get stuck in the middle of a rebalance if wstETH market reaches supply cap","markdown":"0xGoodess\n\nmedium\n\n# rebalance would get stuck in the middle of a rebalance if wstETH market reaches supply cap\n\n## Summary\nrebalance would get stuck in the middle of a rebalance if wstETH market reaches supply cap\n\n## Vulnerability Detail\n1. rebalance implement a cap of tradeSize and if the need to rebalance require taking more assets than the maxTradeSize, then `twapLeverageRatio` would be set to the targeted leverage.\n2. twapLeverageRatio == 0 is required during `rebalance`.\n\nConsider:\n1. lever is needed during rebalance, the strategy require to borrow more ETH and sell to wstETH\n2. during the 1st call of rebalance the protocol cache the new twapLeverageRatio\n3. However wstETH market in Aave reach supply cap. rebalance/iterateRebalance comes to a halt.\n4. Some times later the price of wstETH drops, the protocol needs to call rebalance to delever.\n5. However the supply cap in wstETH is still at cap, twapLeverageRatio can not be set to 0 and the protocol fails to rebalance.\n\n```solidity\n\n     function rebalance(string memory _exchangeName) external onlyEOA onlyAllowedCaller(msg.sender) {\n        LeverageInfo memory leverageInfo = _getAndValidateLeveragedInfo(\n            execution.slippageTolerance,\n            exchangeSettings[_exchangeName].twapMaxTradeSize,\n            _exchangeName\n        );\n\n        // use globalLastTradeTimestamps to prevent multiple rebalances being called with different exchanges during the epoch rebalance\n        _validateNormalRebalance(leverageInfo, methodology.rebalanceInterval, globalLastTradeTimestamp);\n        _validateNonTWAP();\n\n\n...\n\n    function _validateNonTWAP() internal view {\n        require(twapLeverageRatio == 0, \"Must call iterate\");\n    }\n\n```\n\n## Impact\nthe protocol fails to rebalance in the above scenario.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L304-L333\n## Tool used\n\nManual Review\n\n## Recommendation\n1. Add some checks on whether the supply cap of an Aave market is reached during a rebalance. If so, allows a re-set of twapLeverageRatio","decidedSeverity":"false","decidedDuplication":"rebalance would get stuck in the middle of a rebalance if wstETH market reaches supply cap"},{"file":"009.md","watson":{"name":"0xGoodess","days":60,"is_team":false,"payout":1471.42,"score":8.6947821081,"senior":false},"severity":"high","title":"setExecutionSettings would be halt during a rebalance operation that gets stuck due to supply cap is reached at Aave","markdown":"0xGoodess\n\nhigh\n\n# setExecutionSettings would be halt during a rebalance operation that gets stuck due to supply cap is reached at Aave\n\n## Summary\nsetExecutionSettings would be halt during a rebalance operation that gets stuck due to supply cap is reached at Aave\n\n## Vulnerability Detail\nrebalance implement a cap of tradeSize and if the need to rebalance require taking more assets than the maxTradeSize, then twapLeverageRatio would be set to the targeted leverage.\ntwapLeverageRatio == 0 is required during rebalance.\n\nConsider:\n\nlever is needed during rebalance, the strategy require to borrow more ETH and sell to wstETH\nduring the 1st call of rebalance the protocol cache the new twapLeverageRatio\nHowever wstETH market in Aave reach supply cap. rebalance/iterateRebalance comes to a halt.\n`twapLeverageRatio` remains caching the targeted leverage\n\n`setExecutionSettings` requires a condition in which no rebalance is in progress. With the above case, setExecutionSettings can be halted for an extended period of time until the wstETH market falls under supply cap. \n\nWorth-noting, at the time of writing this issue, [the wstETH market at Aave has been at supply cap](https://app.aave.com/reserve-overview/?underlyingAsset=0x7f39c581f595b53c5cb19bd0b3f8da6c935e2ca0&marketName=proto_mainnet_v3)\n\nIn this case, malicious actor who already has a position in wstETH can do the following:\n- deposit into the setToken, trigger a rebalance.\n\n- malicious trader withdraw his/her position in wstETH so there opens up vacancy for supply again.\n\n- protocol owner see supply vacancy, call rebalance in order to lever as required. Now `twapLeverageRatio` is set to new value since multiple trades are needed\n\n- malicious trade now re-supply the wstETH market at Aave so it reaches suppply cap.\n\n- the protocol gets stuck with a non-zero twapLeverageRatio, setExecutionSettings can not be called.\n\n\n```solidity\n    function setExecutionSettings(ExecutionSettings memory _newExecutionSettings) external onlyOperator noRebalanceInProgress {\n        execution = _newExecutionSettings;\n\n        _validateNonExchangeSettings(methodology, execution, incentive);\n\n        emit ExecutionSettingsUpdated(\n            execution.unutilizedLeveragePercentage,\n            execution.twapCooldownPeriod,\n            execution.slippageTolerance\n        );\n    }\n```\n## Impact\nsetExecution would be halt during a rebalance operation that gets stuck due to supply cap is reached at Aave\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L466-L476\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd some checks on whether the supply cap of an Aave market is reached during a rebalance. If so, allows a re-set of twapLeverageRatio","decidedSeverity":"medium","decidedDuplication":"setMethodologySettings would be halt during a rebalance operation that gets stuck due to supply cap is reached at Aave"},{"file":"010.md","watson":{"name":"0xGoodess","days":60,"is_team":false,"payout":1471.42,"score":8.6947821081,"senior":false},"severity":"high","title":"setIncentiveSettings would be halt during a rebalance operation that gets stuck due to supply cap is reached at Aave","markdown":"0xGoodess\n\nhigh\n\n# setIncentiveSettings would be halt during a rebalance operation that gets stuck due to supply cap is reached at Aave\n\n## Summary\nsetIncentiveSettings would be halt during a rebalance operation that gets stuck due to supply cap is reached at Aave\n\n## Vulnerability Detail\nrebalance implement a cap of tradeSize and if the need to rebalance require taking more assets than the maxTradeSize, then `twapLeverageRatio` would be set to the targeted leverage.\n`twapLeverageRatio` == 0 is required during rebalance.\n\nConsider:\n\nlever is needed during rebalance, the strategy require to borrow more ETH and sell to wstETH\nduring the 1st call of rebalance the protocol cache the new twapLeverageRatio\nHowever wstETH market in Aave reach supply cap. rebalance/iterateRebalance comes to a halt.\n`twapLeverageRatio` remains caching the targeted leverage\n\nsetIncentiveSettings requires a condition in which no rebalance is in progress. With the above case, setIncentiveSettings can be halted for an extended period of time until the wstETH market falls under supply cap.\n\nWorth-noting, at the time of writing this issue, [the wstETH market at Aave has been at supply cap](https://app.aave.com/reserve-overview/?underlyingAsset=0x7f39c581f595b53c5cb19bd0b3f8da6c935e2ca0&marketName=proto_mainnet_v3)\n\nIn this case, malicious actor who already has a position in wstETH can do the following:\n\n- deposit into the setToken, trigger a rebalance.\n\n- malicious trader withdraw his/her position in Aave wstETH market so there opens up vacancy for supply again.\n\n- protocol owner see supply vacancy, call rebalance in order to lever as required. Now twapLeverageRatio is set to new value since multiple trades are needed\n\n- malicious trader now re-supply the wstETH market at Aave so it reaches supply cap again.\n\n- the protocol gets stuck with a non-zero twapLeverageRatio, `setIncentiveSettings` can not be called.\n\n```solidity\n    function setIncentiveSettings(IncentiveSettings memory _newIncentiveSettings) external onlyOperator noRebalanceInProgress {\n        incentive = _newIncentiveSettings;\n\n        _validateNonExchangeSettings(methodology, execution, incentive);\n\n        emit IncentiveSettingsUpdated(\n            incentive.etherReward,\n            incentive.incentivizedLeverageRatio,\n            incentive.incentivizedSlippageTolerance,\n            incentive.incentivizedTwapCooldownPeriod\n        );\n    }\n```\n## Impact\nsetIncentiveSettings would be halt.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L484-L495\n## Tool used\n\nManual Review\n\n## Recommendation\nAdd some checks on whether the supply cap of an Aave market is reached during a rebalance. If so, allows a re-set of twapLeverageRatio\n","decidedSeverity":"medium","decidedDuplication":"setMethodologySettings would be halt during a rebalance operation that gets stuck due to supply cap is reached at Aave"},{"file":"011.md","watson":{"name":"0xGoodess","days":60,"is_team":false,"payout":1471.42,"score":8.6947821081,"senior":false},"severity":"high","title":"withdrawEtherBalance would be halt during a rebalance operation that gets stuck due to supply cap is reached at Aave #4","markdown":"0xGoodess\n\nhigh\n\n# withdrawEtherBalance would be halt during a rebalance operation that gets stuck due to supply cap is reached at Aave #4\n\n## Summary\nwithdrawEtherBalance would be halt during a rebalance operation that gets stuck due to supply cap is reached at Aave #4\n\n## Vulnerability Detail\n\n`rebalance` implement a cap of tradeSize and if the need to rebalance require taking more assets than the maxTradeSize, then `twapLeverageRatio` would be set to the targeted leverage.\n`twapLeverageRatio` == 0 is required during rebalance.\n\nConsider:\n\nlever is needed during rebalance, the strategy require to borrow more ETH and sell to wstETH\nduring the 1st call of rebalance the protocol cache the new twapLeverageRatio\nHowever wstETH market in Aave reach supply cap. rebalance/iterateRebalance comes to a halt.\ntwapLeverageRatio remains caching the targeted leverage\n\n`withdrawEtherBalance` requires a condition in which no rebalance is in progress. With the above case, `withdrawEtherBalance` can be halted for an extended period of time until the wstETH market falls under supply cap.\n\nWorth-noting, at the time of writing this issue, [the wstETH market at Aave has been at supply cap](https://app.aave.com/reserve-overview/?underlyingAsset=0x7f39c581f595b53c5cb19bd0b3f8da6c935e2ca0&marketName=proto_mainnet_v3)\n\nIn this case, malicious actor who already has a position in wstETH can do the following:\n\ndeposit into the setToken, trigger a rebalance.\n\nmalicious trader withdraw his/her position in wstETH so there opens up vacancy for supply again.\n\nprotocol owner see supply vacancy, call rebalance in order to lever as required. Now twapLeverageRatio is set to new value since multiple trades are needed\n\nmalicious trade now re-supply the wstETH market at Aave so it reaches suppply cap.\n\nthe protocol gets stuck with a non-zero twapLeverageRatio, withdrawEtherBalance can not be called.\n\n```solidity\n    function withdrawEtherBalance() external onlyOperator noRebalanceInProgress {\n        msg.sender.transfer(address(this).balance);\n    }\n```\n\n## Impact\nwithdrawEtherBalance would be halt during a rebalance operation that gets stuck due to supply cap is reached at Aave #4\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L583-L585\n## Tool used\n\nManual Review\n\n## Recommendation\nAdd some checks on whether the supply cap of an Aave market is reached during a rebalance. If so, allows a re-set of twapLeverageRatio","decidedSeverity":"medium","decidedDuplication":"setMethodologySettings would be halt during a rebalance operation that gets stuck due to supply cap is reached at Aave"},{"file":"012.md","watson":{"name":"0xGoodess","days":60,"is_team":false,"payout":1471.42,"score":8.6947821081,"senior":false},"severity":"high","title":"setMethodologySettings would be halt during a rebalance operation that gets stuck due to supply cap is reached at Aave","markdown":"0xGoodess\n\nhigh\n\n# setMethodologySettings would be halt during a rebalance operation that gets stuck due to supply cap is reached at Aave\n\n## Summary\nsetMethodologySettings would be halt during a rebalance operation that gets stuck due to supply cap is reached at Aave\n\n## Vulnerability Detail\n\n`rebalance` implement a cap of tradeSize and if the need to rebalance require taking more assets than the maxTradeSize, then twapLeverageRatio would be set to the targeted leverage.\ntwapLeverageRatio == 0 is required during rebalance.\n\nConsider:\n\nlever is needed during rebalance, the strategy require to borrow more ETH and sell to wstETH\nduring the 1st call of rebalance the protocol cache the new twapLeverageRatio\nHowever wstETH market in Aave reach supply cap. rebalance/iterateRebalance comes to a halt.\ntwapLeverageRatio remains caching the targeted leverage\n\n`setMethodologySettings` requires a condition in which no rebalance is in progress. With the above case, `setMethodologySettings` can be halted for an extended period of time until the wstETH market falls under supply cap.\n\nWorth-noting, at the time of writing this issue, [the wstETH market at Aave has been at supply cap](https://app.aave.com/reserve-overview/?underlyingAsset=0x7f39c581f595b53c5cb19bd0b3f8da6c935e2ca0&marketName=proto_mainnet_v3)\n\nIn this case, malicious actor who already has a position in wstETH can do the following:\n\n- deposit into the setToken, trigger a rebalance.\n\n- malicious trader withdraw his/her position in wstETH so there opens up vacancy for supply again.\n\n- protocol owner see supply vacancy, call rebalance in order to lever as required. Now twapLeverageRatio is set to new value since multiple trades are needed\n\n- malicious actor now re-supply the wstETH market at Aave so the market reaches suppply cap again.\n\n- the protocol gets stuck with a non-zero twapLeverageRatio, `setMethodologySettings` can not be called.\n\n```solidity\n    function setMethodologySettings(MethodologySettings memory _newMethodologySettings) external onlyOperator noRebalanceInProgress {\n        methodology = _newMethodologySettings;\n\n        _validateNonExchangeSettings(methodology, execution, incentive);\n\n        emit MethodologySettingsUpdated(\n            methodology.targetLeverageRatio,\n            methodology.minLeverageRatio,\n            methodology.maxLeverageRatio,\n            methodology.recenteringSpeed,\n            methodology.rebalanceInterval\n        );\n    }\n```\n\n## Impact\n`setMethodologySettings` would be halt during a rebalance operation that gets stuck due to supply cap is reached at Aave\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L446-L458\n\n## Tool used\n\nManual Review\n\n## Recommendation\nAdd some checks on whether the supply cap of an Aave market is reached during a rebalance. If so, allows a re-set of twapLeverageRatio","decidedSeverity":"medium","decidedDuplication":"setMethodologySettings would be halt during a rebalance operation that gets stuck due to supply cap is reached at Aave"},{"file":"013.md","watson":{"name":"0xGoodess","days":60,"is_team":false,"payout":1471.42,"score":8.6947821081,"senior":false},"severity":"medium","title":"_calculateMaxBorrowCollateral does not check whether the strategy is in Emode or not leading to inaccurate representation of LTV.","markdown":"0xGoodess\n\nmedium\n\n# _calculateMaxBorrowCollateral does not check whether the strategy is in Emode or not leading to inaccurate representation of LTV.\n\n## Summary\n_calculateMaxBorrowCollateral does not check whether the strategy is in Emode or not\n\n## Vulnerability Detail\nWhile there is integration of aave Emode through the new extension `AaveLeverageStrategyExtension`, the existing function `_calculateMaxBorrowCollateral` does not integrate with this new feature.\n\neMode would increase the LTV and liquidation threshold of the strategy. if the strategy is set to eMode, with the function `_calculateMaxBorrowCollateral` not incorporating the new configuration, the system would behave as if without the emode being enabled.\n\n```solidity\n    function _calculateMaxBorrowCollateral(ActionInfo memory _actionInfo, bool _isLever) internal view returns(uint256) {\n        \n        // Retrieve collateral factor and liquidation threshold for the collateral asset in precise units (1e16 = 1%)\n        ( , uint256 maxLtvRaw, uint256 liquidationThresholdRaw, , , , , , ,) = strategy.aaveProtocolDataProvider.getReserveConfigurationData(address(strategy.collateralAsset));\n\n        // Normalize LTV and liquidation threshold to precise units. LTV is measured in 4 decimals in Aave which is why we must multiply by 1e14\n        // for example ETH has an LTV value of 8000 which represents 80%\n        if (_isLever) {\n            uint256 netBorrowLimit = _actionInfo.collateralValue\n                .preciseMul(maxLtvRaw.mul(10 ** 14))\n                .preciseMul(PreciseUnitMath.preciseUnit().sub(execution.unutilizedLeveragePercentage));\n\n            return netBorrowLimit\n                .sub(_actionInfo.borrowValue)\n                .preciseDiv(_actionInfo.collateralPrice);\n        } else {\n            uint256 netRepayLimit = _actionInfo.collateralValue\n                .preciseMul(liquidationThresholdRaw.mul(10 ** 14))\n                .preciseMul(PreciseUnitMath.preciseUnit().sub(execution.unutilizedLeveragePercentage));\n\n            return _actionInfo.collateralBalance\n                .preciseMul(netRepayLimit.sub(_actionInfo.borrowValue))\n                .preciseDiv(netRepayLimit);\n        }\n    }\n```\n## Impact\nwrong LTV and liquidation threshold might be used.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1095-L1119\n\n## Tool used\n\nManual Review\n\n## Recommendation\nadd checks on whether the setToken is in eMode by calling `getUserEmode`, if so fetch the eModeConfiguration through`getEmodeCategoryData` with argument from `getUserEmode`. If not in emode(userEmode == 0) , follow the existing path of `getReserveConfigurationData`\n","decidedSeverity":"false","decidedDuplication":"_calculateMaxBorrowCollateral does not check whether the strategy is in Emode or not leading to inaccurate representation of LTV."},{"file":"014.md","watson":{"name":"pavankv241"},"severity":"medium","title":"_transferEtherRewardToCaller() may be fails because no payable keyword while sending ETHER.","markdown":"pavankv241\n\nmedium\n\n# _transferEtherRewardToCaller() may be fails because no payable keyword while sending ETHER.\n\n## Summary\nAccording to solidity [docs](https://docs.soliditylang.org/en/v0.8.6/080-breaking-changes.html#new-restrictions) \" compiler cannot determine whether or not these addresses are payable or not, so it now requires an explicit conversion to make this requirement visible. The global variables tx.origin and msg.sender have the type address instead of address payable. One can convert them into address payable by using an explicit conversion, i.e., payable(tx.origin) or payable(msg.sender).\" . Before sending the ether to EOA(External Owned Account) like **payable(0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF)**\n\n## Vulnerability Detail\nFunction  [ripcord()](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L392)  transfer ether to msg.sender  by below code \n```solidity\n        uint256 etherTransferred = _transferEtherRewardToCaller(incentive.etherReward);\n```\n\nIn _transferEtherRewardToCaller(incentive.etherReward) function sends ether like below \n```solidity\n\n        msg.sender.transfer(etherToTransfer);\n```\n\nIf msg.sender is non-payable address then above both function will get fails. Even Solidity compiler cannot identify the msg.sender or tx.origin is payable or not ,it's clearly states in solidity docs.\nAnd Above the ripcord() function clearly states that  **ONLY EOA:** and in onlyEOA modifier looks like below , no conversion to payable address .\n```solidity\n    modifier onlyEOA() {\n        require(msg.sender == tx.origin, \"Caller must be EOA Address\");\n        _;\n    }\n```\n\n\n\n\n\n\n\n\n## Impact\nSending ETHER may be failed due to non-payable External Owned Account (EOA)\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1221\n\n## Tool used\nManual Review\n\n## Reference\nLook into this blog a good example how to send ETH to EOA safely\nhttps://solidity-by-example.org/sending-ether/\n\n## Recommendation\nChange like below\n```solidity\n    function _transferEtherRewardToCaller(uint256 _etherReward) internal returns(uint256) {\n        uint256 etherToTransfer = _etherReward < address(this).balance ? _etherReward : address(this).balance;\n\n       /*@audit change here payable*/  payable(msg.sender).transfer(etherToTransfer);\n\n        return etherToTransfer;\n    }\n```\n\n- And add payable keyword for ripcord() and _transferEtherRewardToCaller()\n\n- Use call instead of transfer because  . \n   The use of the deprecated transfer() function for an address will inevitably \n   make the transaction fail when:\n\n   The msg.sender or  smart contract does not implement a payable function.\n   The msg.sender  does implement a payable fallback which uses \n   more than 2300 gas unit.","decidedSeverity":"false","decidedDuplication":"_transferEtherRewardToCaller() may be fails because no payable keyword while sending ETHER."},{"file":"015.md","watson":{"name":"0xGoodess","days":60,"is_team":false,"payout":1471.42,"score":8.6947821081,"senior":false},"severity":"medium","title":"ripcord uses a static slippageTolerance while being a last-resort measure is unlikely to work","markdown":"0xGoodess\n\nmedium\n\n# ripcord uses a static slippageTolerance while being a last-resort measure is unlikely to work\n\n## Summary\nripcord uses a static slippageTolerance while being a last-resort measure is unlikely to work\n\n## Vulnerability Detail\nripcord allows a 1-time deleverage attempt to sell off collateral in an attempt to respond to volatile market situation, when the leverage hits above the incentivized leverage ratio.\n\nHowever, the static incentivized slippageTolerance from the system is applied to the price from chainlink during ripcord. This is unlikely to work during a volatile market condition. \n\n## Impact\nlikelihood of ripcord as a last-resort function fails to salvage the system.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L376-L400\n\n## Tool used\n\nManual Review\n\n## Recommendation\nconsider a progressive slippage tolerance if ripcord fails in a previous attempt. An cache variable similar to the twapLeverageRatio can be implemented to record `ripcordFailedAttempt`. Final Slippage Tolerance can be like:\n\n```solidity\nuint256 slippageTolerance = _leverageInfo.slippageTolerance + ripcordFailedAttempt * slippageIncreaseInterval\n```\n\nwhere `slippageIncreaseInterval` is an system configuration (10bp 20bp etc)\nand ripcordFailedAttempt is a cached frequency of previous failed ripcord call and would be set to 0 at the end of a successful ripcord.\n","decidedSeverity":"false","decidedDuplication":"ripcord uses a static slippageTolerance while being a last-resort measure is unlikely to work"},{"file":"016.md","watson":{"name":"0xGoodess","days":60,"is_team":false,"payout":1471.42,"score":8.6947821081,"senior":false},"severity":"medium","title":"ripcord may appear unattractive to external monitory if the ETH reward does not have a lower bound","markdown":"0xGoodess\n\nmedium\n\n# ripcord may appear unattractive to external monitory if the ETH reward does not have a lower bound\n\n## Summary\nripcord may appear unattractive to external monitory if the ETH reward does not have a lower bound\n\n## Vulnerability Detail\na call to ripcord would get out reward specified in the incentive configuration, or the remaining balance in the contract, whichever is lower.\n\nHowever a third-party would be un-tempted to make call to this function since their call to ripcord can be front-runned by the contract owner that transferred out ethereum through `withdrawEtherBalance`. Then they would spend all the gas for nothing.\n\n## Impact\nincentives does not work as expected.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1218-L1224\n\n## Tool used\n\nManual Review\n\n## Recommendation\nallow the external caller to specify the minimum reward acceptable.\n","decidedSeverity":"false","decidedDuplication":"ripcord may appear unattractive to external monitory if the ETH reward does not have a lower bound"},{"file":"017.md","watson":{"name":"0xGoodess","days":60,"is_team":false,"payout":1471.42,"score":8.6947821081,"senior":false},"severity":"medium","title":"external keeper can still call rebalance to lever during disengage process","markdown":"0xGoodess\n\nmedium\n\n# external keeper can still call rebalance to lever during disengage process\n\n## Summary\nexternal keeper can still call rebalance during disengage\n\n## Vulnerability Detail\ndisengage aims to bring down the system leverage to 1x or even completely to 0. The deleverage process also follows the step-wise process to chop trade into `twapMaxTradeSize` size.\n\nHowever during disengage, external keeper can/could still call rebalance, which would then lever up the system back to the configured targeted leverage. This create friction to the disengagement operation.\n\n\n## Impact\ndisengage becomes frictional as off-set by lever action from rebalance.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L304-L330\n\n## Tool used\n\nManual Review\n\n## Recommendation\nadd a system checks to pause any rebalance attempt during engagement or disengagement. ","decidedSeverity":"false","decidedDuplication":"external keeper can still call rebalance to lever during disengage process"},{"file":"018.md","watson":{"name":"0xGoodess","days":60,"is_team":false,"payout":1471.42,"score":8.6947821081,"senior":false},"severity":"medium","title":"_repayBorrow would leave a residual allowance when the underlying debtToken is less than the _notionalQuantity","markdown":"0xGoodess\n\nmedium\n\n# _repayBorrow would leave a residual allowance when the underlying debtToken is less than the _notionalQuantity\n\n## Summary\n_repayBorrow would leave a residual allowance when the underlying debtToken is less than the _notionalQuantity\n\n## Vulnerability Detail\ncomponentRedeemHook uses `_repayBorrowForHook` which calls `_repayBorrow`, In `_repayBorrow`, the function first approve the needed amount `notionalDebt` and then call repayBorrow in Aave which pull the amount. \n\nHowever, if the remaining debtTokenBalance is less than the approved amount, then aave would just pull the total of the debtToken:\n\n1. SetToken has a debtToken of 10\n2. SetToken call repayBorrow with amount 10.1\n3. only 10 would be transferred to Aave, leaving 0.1 as a non-zero allowance.\n\n```solidity\n    function componentRedeemHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {\n        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position\n        // exists the loan would be paid down twice, decollateralizing the Set\n        if (!_isEquity) {\n            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n\n            require(componentDebt < 0, \"CMBN\");\n\n            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMulCeil(_setTokenQuantity);\n            _repayBorrowForHook(_setToken, _component, notionalDebt);\n        }\n    }\n```\n\n```solidity\n    function _repayBorrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _repayBorrow(_setToken, IPool(lendingPoolAddressesProvider.getPool()), _asset, _notionalQuantity);\n    }\n```\n\n```solidity\n    function _repayBorrow(ISetToken _setToken, IPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);\n        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);\n    }\n```\n## Impact\nleaving non-zero allowance in setToken.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L715-L726\n\n## Tool used\n\nManual Review\n\n## Recommendation\nre-set the allowance to 0 at the end of each transaction that has called approve.","decidedSeverity":"false","decidedDuplication":"_repayBorrow would leave a residual allowance when the underlying debtToken is less than the _notionalQuantity"},{"file":"019.md","watson":{"name":"BugBusters"},"severity":"medium","title":"USE LATESTROUNDDATA INSTEAD OF LATESTANSWER TO RUN MORE VALIDATIONS","markdown":"BugBusters\n\nmedium\n\n# USE LATESTROUNDDATA INSTEAD OF LATESTANSWER TO RUN MORE VALIDATIONS\n\n## Summary\nThe latestAnswer() function is deprecated and does not throw an error if no answer has been reached, instead it returns 0 which can cause an incorrect price\n\n## Vulnerability Detail\n`AaveLeverageStrategyExtension.sol` contract is calling `latestAnswer` to get the asset prices. The latestAnswer is deprecated. Freshness of the returned price should be checked, since it affects an account’s health (and therefore liquidations). Stale prices that do not reflect the current market price anymore could be used, which would influence the liquidation pricing. This method will return the last value, but you won’t be able to check if the data is fresh. On the other hand, calling the method `latestRoundData` allow you to run some extra validations. Stale prices can put funds in a risk. According to Chainlink’s documentation, This function does not error if no answer has been reached but returns 0, causing an incorrect price\nfed to the Price oracle. (https://docs.chain.link/docs/historical-price-data/#solidity). Furthermore, `latestAnswer` is deprecated.\n(https://docs.chain.link/docs/price-feeds-api-reference/))\n\n## Impact\nAccording to Chainlink's documentation, the latestAnswer function is deprecated. This function might suddenly stop working if Chainlink stop supporting deprecated APIs. And the old API can return stale data.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L895\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L897\n## Tool used\n\nManual Review\n\n## Recommendation\nUse the latestRoundData function to get the price instead. Add checks on the return data with proper revert messages if the price is stale or the round is uncomplete\nhttps://docs.chain.link/docs/price-feeds-api-reference/","decidedSeverity":"medium","decidedDuplication":"Deprecated oracle function `latestAnswer()` could bring fund loss"},{"file":"020.md","watson":{"name":"BugBusters"},"severity":"medium","title":"onlyEOA modifier that ensures call is from EOA might not hold true with the eip 3074","markdown":"BugBusters\n\nmedium\n\n# onlyEOA modifier that ensures call is from EOA might not hold true with the eip 3074\n\n\n## Summary\nmodifier onlyEOAE is used to ensure calls are only made from EOA. However, EIP 3074 suggests that using onlyEOAE modifier to ensure calls are only from EOA might not hold true.\n## Vulnerability Detail\nFor onlyEOAEx, tx.origin is used to ensure that the caller is from an EOA and not a smart contract.\n\n```solidity\n    modifier onlyEOA() {\n        // here we could have serious issue with the upcoming EIP\n        require(msg.sender == tx.origin, \"Caller must be EOA Address\");\n        _;\n    }\n```\n\nHowever, according to [EIP 3074](https://eips.ethereum.org/EIPS/eip-3074#abstract),\n\nThis EIP introduces two EVM instructions AUTH and AUTHCALL. The first sets a context variable authorized based on an ECDSA signature. The second sends a call as the authorized account. This essentially delegates control of the externally owned account (EOA) to a smart contract.\n\nTherefore, using tx.origin to ensure msg.sender is an EOA will not hold true in the event EIP 3074 goes through.\n\nAs the EIP states itself:\n\n****AUTH allows for signatures to be signed by tx.origin. For any such signatures, subsequent AUTHCALLs have msg.sender == tx.origin in their first layer of execution. Without EIP-3074, this situation can only ever arise in the topmost execution layer of a transaction. This EIP breaks that invariant and so affects smart contracts containing require(msg.sender == tx.origin) checks.\n\nAllowing authorized to equal tx.origin has the possibility to:\n\n    Break atomic sandwich protections which rely on tx.origin;\n    Break re-entrancy guards of the style require(tx.origin == msg.sender).\n\nThe authors of this EIP believe the risks of allowing authorized to equal tx.origin are acceptable for the reasons outlined in the Rationale section.****\n\n\nIt gives a false sense of security from flash loan attacks which may not hold through if the eip goes through.\n\nSolodit links for more information on same vulnerability:\n\nhttps://solodit.xyz/issues/6662\nhttps://solodit.xyz/issues/13367\nand link to EIP:\nhttps://eips.ethereum.org/EIPS/eip-3074#allowing-txorigin-as-signer\n\nhttps://eips.ethereum.org/EIPS/eip-3074#allowing-txorigin-as-signer\n## Impact\n\n## Code Snippet\nhttps://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/lib/BaseExtension.sol#L59-L62\n## Tool used\n\nManual Review\n\n## Recommendation\nRecommend using OpenZepellin's isContract function (https://docs.openzeppelin.com/contracts/2.x/api/utils#Address-isContract-address-). Note that there are edge cases like contract in constructor that can bypass this and hence caution is required when using this.\n```solidity\n    modifier onlyEOAEx() {\n        if (!allowContractCalls && !whitelistedContracts[msg.sender]) {\n            if (isContract(msg.sender)) revert NOT_EOA(msg.sender);\n        }\n        _;\n    }\n```\n\n","decidedSeverity":"medium","decidedDuplication":"onlyEOA modifier that ensures call is from EOA might not hold true with the eip 3074"},{"file":"021.md","watson":{"name":"0xStalin","days":3,"is_team":false,"payout":1.16,"score":0.1144522012,"senior":false},"severity":"medium","title":"Not using eMode's risk parameters configurations to calculate the maxBorrow/repayAmount when eMode is activated","markdown":"0xStalin\n\nmedium\n\n# Not using eMode's risk parameters configurations to calculate the maxBorrow/repayAmount when eMode is activated\n\n## Summary\nThe protocol has extended the [AaveLeverageStrategyExtension](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol) contract to be compatible with Aave V3, as part of this upgrade, the protocol has created a [new adapter](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveV3LeverageStrategyExtension.sol) to enable the new eMode feature offered by Aave V3 to enhance capital efficiency.\nThe problem is that **when an eMode category is set for a setToken, the protocols actually don't use the enhanced risk parameters for the eMode category**, instead, all the computation still uses the [**individual collateral's risk parameters**](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1098)\n\n\n## Vulnerability Detail\nThe protocol [allows setting an eMode category on setTokens](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveV3LeverageStrategyExtension.sol#L55-L68), but it doesn't pull the risk parameters of the eMode category when [computing the max borrow/repay amount allowed in base units for lever / delever](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1095-L1119), instead, it [still continues to pull the risk parameters of the individual collateral](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1097-L1098)\n\n- Not using the eMode configurations for a reserve that has been configured to use one of the EMode categories will make that all the users can't take advantage to extract the highest borrowing power out of their collateral.\n- Not using the EMode configurations will limit the borrowing power of the users which that can be translated as limiting how much value users can get out of locking their collaterals.\n  - [eMode configurations store crucial data](https://github.com/aave/aave-v3-core/blob/master/contracts/protocol/libraries/types/DataTypes.sol#L71-L79), such as, `ltv`, `liquidationThreshold`, `liquidationBonus`, `priceSource` (A custom oracle to compute the price for all the assets of the eMode category)\n\n- The fact that a reserve is configured in Aave to use an EMode, but the Index protocol doesn't take it into account and makes all the computations using the normal risk parameters, apart from limiting the user's borrowing power, the Index Protocol will be out of sync compared to Aave, which could lead to breaking the internal mechanisms because the mismatch in the computed values between the Index Protocol and Aave.\n\n- For example, **EMode for stablecoins has a 98% liquidation threshold, compared to an 80% for DAI when EMode is not enabled.**\n- As per the Technical Paper, **If EMode is enabled, Aave overrides the LTV & Liquidation Threshold of the individual collateral and instead uses the risk parameters of the EMode category, which allows higher capital efficiency.**\n\n## Impact\n- Limiting the borrowing power that positions could get out of their collateral because the computation uses the `ltv` value of the individual collateral, positions borrowing less than what they could really borrow for the exact same amount of collateral.\n\n- Not taking advantage of the enhanced `liquidationThreshold` of the eMode category to compute the needed repayment amount, which could be translated as because of not using the `liquidationThreshold` of the eMode category, positions will need to delever and sell a portion of their debt to lower the `liquidationThreshold` below the `liquidationThreshold` of the individual collateral.\n\n- Index Protocol will be out of sync compared to the real values that Aave is operating with.\n  - This could lead to incorrect computations that in the best scenario, it will cause the position to not gain the benefits of the capital efficiency and at worst it could end up breaking the internal accounting, breaking system invariants\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1097-L1098\n\n## Tool used\nManual Review & [Aave V3 Techincal Paper](https://github.com/aave/aave-v3-core/blob/master/techpaper/Aave_V3_Technical_Paper.pdf) & [Official Aave v3 Documentation about Risk Parameters](https://docs.aave.com/risk/asset-risk/risk-parameters)\n\n## Recommendation\n- **When the EMode has been activated**, make sure to ***pull the eMode configuration's data instead of pulling the normal reserve configuration's data.***\n- Make sure to check the Aave documentation for further guidance on how to integrate the pulling of the eMode configuration's data. Hint, eMode configuration's data is accessible only through the IPool interface\nhttps://docs.aave.com/developers/core-contracts/pool#getemodecategorydata\n- A quick example of how this could possibly be done:\n```solidity\nfunction _calculateMaxBorrowCollateral(ActionInfo memory _actionInfo, bool _isLever) internal view returns(uint256) {\n    ...\n    ...\n    uint256 maxLtvRaw\n    uint256 liquidationThresholdRaw\n\n    // Pull the eMode category\n    uint _eModeCategoryId = _pool.getUserEMode(<tokenAddress>);\n\n    // if eMode is activated\n    if (_eModeCategoryId != 0) {\n        DataTypes.EModeCategory memory eModeData;\n        eModeData = _pool.getEModeCategoryData(_eModeCategoryId);\n        maxLtvRaw = eModeData.ltv;\n        liquidationThresholdRaw = eModeData.liquidationThreshold;\n    } else {\n        ( , maxLtvRaw, liquidationThresholdRaw, , , , , , ,) = strategy.aaveProtocolDataProvider.getReserveConfigurationData(address(strategy.collateralAsset));\n    }\n    ...\n    ...\n}\n```\n- Reference about the [EModeCategory Data Type](https://github.com/aave/aave-v3-core/blob/master/contracts/protocol/libraries/types/DataTypes.sol#L71-L79)\n- ","decidedSeverity":"false","decidedDuplication":"Not using eMode's risk parameters configurations to calculate the maxBorrow/repayAmount when eMode is activated"},{"file":"022.md","watson":{"name":"pavankv241"},"severity":"medium","title":"No check of oldFee is equal to _newFee","markdown":"pavankv241\n\nmedium\n\n# No check of oldFee is equal to _newFee\n\n## Summary\nNo check of oldFee is equal to _newFee  leads to  naive manager   try to update the same fee as _newFee.\n\n## Vulnerability Detail\n[updateAirdropFee()](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AirdropModule.sol#L196) fucntion can be called to update new AirDrop fee but there is no check whether the oldfee is not equal to _newFee . From line [204](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AirdropModule.sol#L204) to [209](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AirdropModule.sol#LL209C57-L209C57) checks whether _newFee is not exceed 100% , Absorb all outstanding tokens before fee is updated and update _newFee as airdrop Fee. It's good practice to check before updating  fee as old or new .\n\n\n## Impact\nDue no check, naive manager can update same fee as _newFee.   \n\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AirdropModule.sol#LL196C1-L211C6\n\n## Tool used\nManual Review\n\n## Recommendation\nAdd check like below\n```solidity\n        require(_newFee <=  PreciseUnitMath.preciseUnit(), \"Airdrop fee can't exceed 100%\");\n\n           uint _oldFee = airdropSettings[_setToken].airdropFee; //Audit \n          require( _oldFee != _newFee , \"Same fee cannot updated\"); //Audit \n                  // Absorb all outstanding tokens before fee is updated\n        _batchAbsorb(_setToken, airdropSettings[_setToken].airdrops);\n\n        airdropSettings[_setToken].airdropFee = _newFee;\n\n```\n\n\n----------------------------------------------------------------------------------------------------------------------\n\n## Scenario 2 \n\n## No check whether oldFeeRecipient is no equal  _newFeeRecipient \n\n## Summary \nNo check whether oldFeeRecipient is no equal  _newFeeRecipient . Same address can be updated _newFeeRecipient \n\n## Vulnerability Detail \n[updateFeeRecipient()](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AirdropModule.sol#LL178C5-L178C5) function can be called to update fee recipient address but no checks whether the oldFeeRecipient is not equal to newFeerecipient . Naive manager can update same address as newFeeRecipeint from line [185](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AirdropModule.sol#L185) to [186](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AirdropModule.sol#L186) checks whether address is equal to ZERO or not and update feerecipient address  . It's good practice to check before updating feeRecipient address . \n\n## Impact \noldFeeRecipient address can be updated as _newFeeRecipient .\n\n## Code snippet:-\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AirdropModule.sol#LL178C1-L189C1\n\n## Recommendation \n\nAdd below check \n```solidity\n\n        require(_newFeeRecipient != address(0), \"Passed address must be non-zero\");\n       address _oldFeeRecipient = airdropSettings[_setToken].feeRecipient ; //Audit\n require( _oldFeeRecipient != _newFeeRecipeint ,\"Same Address not allowed\" ); //Audit\n        airdropSettings[_setToken].feeRecipient = _newFeeRecipient;\n        emit FeeRecipientUpdated(_setToken, _newFeeRecipient);\n\n```\n\n\n","decidedSeverity":"false","decidedDuplication":"No check of oldFee is equal to _newFee"},{"file":"023.md","watson":{"name":"Saeedalipoor01988"},"severity":"high","title":"Trade / addLiquidity transactions lack of expiration timestamp control / slippage check","markdown":"Saeedalipoor01988\n\nhigh\n\n# Trade / addLiquidity transactions lack of expiration timestamp control / slippage check\n\n## Summary\nThe Trade / addLiquidity transactions lack of expiration timestamp and slippage control.\n\n## Vulnerability Detail\nLet us look into the heavily forked Uniswap V2 contract addLiquidity function implementation\n\nhttps://github.com/Uniswap/v2-periphery/blob/0335e8f7e1bd1e8d8329fd300aea2ef2f36dd19f/contracts/UniswapV2Router02.sol#L61\n\n// **** ADD LIQUIDITY ****\n```solidity\nfunction _addLiquidity(\n\taddress tokenA,\n\taddress tokenB,\n\tuint amountADesired,\n\tuint amountBDesired,\n\tuint amountAMin,\n\tuint amountBMin\n) internal virtual returns (uint amountA, uint amountB) {\n\t// create the pair if it doesn't exist yet\n\tif (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {\n\t\tIUniswapV2Factory(factory).createPair(tokenA, tokenB);\n\t}\n\t(uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n\tif (reserveA == 0 && reserveB == 0) {\n\t\t(amountA, amountB) = (amountADesired, amountBDesired);\n\t} else {\n\t\tuint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);\n\t\tif (amountBOptimal <= amountBDesired) {\n\t\t\trequire(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n\t\t\t(amountA, amountB) = (amountADesired, amountBOptimal);\n\t\t} else {\n\t\t\tuint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);\n\t\t\tassert(amountAOptimal <= amountADesired);\n\t\t\trequire(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n\t\t\t(amountA, amountB) = (amountAOptimal, amountBDesired);\n\t\t}\n\t}\n}\n```\n\n```solidity\nfunction addLiquidity(\n\taddress tokenA,\n\taddress tokenB,\n\tuint amountADesired,\n\tuint amountBDesired,\n\tuint amountAMin,\n\tuint amountBMin,\n\taddress to,\n\tuint deadline\n) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\n\t(amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n\taddress pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n\tTransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n\tTransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n\tliquidity = IUniswapV2Pair(pair).mint(to);\n}\n```\n\nthe implementation has two point that worth noting,\n\nthe first point is the deadline check\n\n```solidity\nmodifier ensure(uint deadline) {\n\trequire(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');\n\t_;\n}\n```\n\nThe transaction can be pending in mempool for a long and the trading activity is very time senstive. Without deadline check, the trade transaction can be executed in a long time after the user submit the transaction, at that time, the trade can be done in a sub-optimal price, which harms user's position. The deadline check ensure that the transaction can be executed on time and the expired transaction revert.\n\nIn both functions, deadline check by default is block.timestamp–this basically disables the transaction expiration check because the deadline will be set to whatever timestamp the block including the transaction is minted at.\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/integration/exchange/UniswapV2ExchangeAdapter.sol#L62\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/integration/amm/UniswapV2AmmAdapter.sol#L138\n\nthe second point is the slippage control, the slippage control the user can receive the least optimal amount of the token they want to trade.\n\nin the both functions Minimum Receive Quantity is based on the input( Manager ), and there is not any check on the slippage number which does not cause loss or at least not zero. For [Trade ](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/integration/exchange/UniswapV2ExchangeAdapter.sol#L62) function not checked and for [addLiquidity ](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/integration/amm/UniswapV2AmmAdapter.sol#L113):, just check it is lower than liquidityExpectedFromSuppliedTokens.\n\nThe slippage Tolerance is set in[ AaveLeverageStrategyExtension.sol contract](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L244), but your [best check and validation](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L936) is :\n\n```solidity\n        require (\n            _execution.slippageTolerance **<=** PreciseUnitMath.preciseUnit(),\n            **\"Slippage tolerance must be <100%\"**\n        );\n```\n\nSo slippage can set to 100%.\n\n## Impact\nThe transaction can be exploited by a sandwich attack and cause the above transactions to cause losses.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/TradeModule.sol#L253\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/AmmModule.sol#L433\n\n## Tool used\nManual Review\n\n## Recommendation\nprotocol add check for slippage and deadline.","decidedSeverity":"medium","decidedDuplication":"`AaveLeverageStrategyExtension.sol` does not allow user to specify slippage parameter during rebalance or ripcord"},{"file":"024.md","watson":{"name":"0xStalin","days":3,"is_team":false,"payout":1.16,"score":0.1144522012,"senior":false},"severity":"medium","title":"Using a deprecated Chainlink function to pull the asset's price from the Chainlink Oracle","markdown":"0xStalin\n\nmedium\n\n# Using a deprecated Chainlink function to pull the asset's price from the Chainlink Oracle\n\n# Medium Severity\n## Title\nUsing a deprecated Chainlink function to pull the asset's price from the Chainlink Oracle\n\n## Summary\nThe protocol uses Chainlink as the Oracle service to pull the prices of the assets (collateral & borrow).\nThe protocol is using a [**deprecated**](https://docs.chain.link/data-feeds/api-reference#latestanswer) function by the Oracle provider (Chainlink) [to pull the prices](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L895-L898)\n\n## Vulnerability Detail\nThe protocol is using a [**deprecated**](https://docs.chain.link/data-feeds/api-reference#latestanswer) function by the Oracle provider (Chainlink) [to pull the prices](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L895-L898)\n\n- According to Chainlink’s documentation [(API Reference)](https://docs.chain.link/data-feeds/api-reference), **the latestAnswer function is deprecated**. **This function does not throw an error if no answer has been reached, but instead returns 0**, possibly causing an incorrect price to be fed to the different price feeds or even a Denial of Service by a division by zero\n\n- In addition to the above scenario, the fact that the deprecated functions returns a price it doesn't mean that the price is the most recent price, let's remember that Chainlink can returns stale prices, which could end up causing problems when using the returned price to compute other values. The current function in use is capable to only return the price, it doesn't return any of the other values (uint80 baseRoundID , int256 answer , , uint256 baseTimestamp ,uint80 baseAnsweredInRound) as the `latestAnswer()`.\n  - Not able to prevent computing values using a stale price\n\n## Impact\n- In the scenario that the function returns 0 instead of returning the expected price, the engage() function in the `AaveLeverageStrategyExtension` would become unusable.\n- The reason is that when the [engage()](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L256-L292) function is in the process of [computing the max borrow, it makes a division by the value of the price pulled from the oracle](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1107-L1109), ***if the price returned by Chainlink was 0, the division will revert with a mathematical error, thus transactions will be reverting***\n\n\n## Code Snippet\n- https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L895\n- https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L897\n\n## Tool used\nManual Review & [Chainlink Documentation](https://docs.chain.link/data-feeds/api-reference)\n\n## Recommendation\n- It is recommended to use [Chainlink’s latestRoundData()](https://docs.chain.link/data-feeds/api-reference#latestrounddata) function to get the price instead. It is also recommended to add checks on the return data with proper revert messages if the price is stale or the round is incomplete, for example\n```solidity\n( uint80 baseRoundID , int256 answer , , uint256 baseTimestamp ,uint80 baseAnsweredInRound ) = assetChainlinkPriceFeed.latestAnswer();\nrequire ( answer > 0, \" ChainlinkPriceOracle : answer <= 0\");\nrequire ( baseAnsweredInRound >= baseRoundID , \" ChainlinkPriceOracle :Stale price\");\nrequire ( baseTimestamp > 0, \" ChainlinkPriceOracle : Round not complete\");\nuint256 _price = uint256 ( answer );\n```","decidedSeverity":"medium","decidedDuplication":"Deprecated oracle function `latestAnswer()` could bring fund loss"},{"file":"025.md","watson":{"name":"Cryptor","days":26,"is_team":false,"payout":47.1,"score":0.864264114,"senior":false},"severity":"false","title":"Precision loss in _calculateStreamingFee to incorrect calculation of the days in a year","markdown":"Cryptor\n\nfalse\n\n# Precision loss in _calculateStreamingFee to incorrect calculation of the days in a year\n\n## Summary\nThe function  _calculateStreamingFee uses a constant ONE_YEAR_IN_SECONDS to calculate the streaming fees for a manager. This constant is 365.25 days, which is incorrect.\n\n## Vulnerability Detail\n\nThe constant ONE_YEAR_IN_SECONDS calculates the amount of days in a year which is then used to calculate the amount the streaming fees for a manager. \n\n ``` return timeSinceLastFee.mul(_streamingFeePercentage(_setToken)).div(ONE_YEAR_IN_SECONDS);```\n\nThe protocol defines this as 365.25 days which is incorrect. This is likely taking the average of days in a year in a 4 year timespan. The amount of days in a year is 365 days and 366 days in a leap year. This means that the streaming fees will be incorrect in any timeframe less than 4 years as it will not be 365.25. This will result in the incorrect streaming fee for a manger.\n\n## Impact\n\nThere will be a precision loss for streaming fees due to incorrect calculation of days in a year\n\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/StreamingFeeModule.sol#L67\n\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/StreamingFeeModule.sol#L203-L208\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse the follow library instead \n\nhttps://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n","decidedSeverity":"false","decidedDuplication":"Precision loss in _calculateStreamingFee to incorrect calculation of the days in a year"},{"file":"026.md","watson":{"name":"0xnevi"},"severity":"medium","title":"Inconsistent charging of fees in `DebtIssuanceModuleV2.sol` `issue()` and `redeem()` functions","markdown":"0xnevi\n\nmedium\n\n# Inconsistent charging of fees in `DebtIssuanceModuleV2.sol` `issue()` and `redeem()` functions\n\n## Summary\n`DebtIssuanceModuleV2.sol` does not charge a fee when caller calls `issue()` or `redeem()`.\n\n## Vulnerability Detail\nRefer to Impact Section.\n\n## Impact\nIn both `issue()` and `redeem()`, if a fee is specified for manager and protocol fee, `calculateTotalFees()` will calculate the split and then mint `setTokens` for the respective addresses. This is also stated in the protocols [DebtIssuanceModuleV2 docs](https://docs.tokensets.com/developers/contracts/protocol/modules/debtissuancemodulev2). \n\nHowever, based on the current logic of `issue()` and `redeem()`, fees are never charged to caller calling these two functions, but is instead paid to manager and protocol by protocol itself. This can also cause overestimation of `totalSupply()` setToken. \n\n### `DebtIssuanceModuleV2.issue()`\nIn `DebtIssuanceModuleV2.issue()`, caller deposits components to the SetToken, replicates any external module component positions and mints the specified `_quantity` of SetToken. Fees are correctly minted via `_resolveFees()`, but the `_quantity` minted does not account for fees by subtracting `_quantity - managerFee - protocolFee`. This means that caller never pay the fees when calling `issue()`.\n```solidity\nfunction issue(\n    ISetToken _setToken,\n    uint256 _quantity,\n    address _to\n)\n    external\n    override\n    nonReentrant\n    onlyValidAndInitializedSet(_setToken)\n{   \n    ...\n    ...\n    ...\n    (\n        uint256 quantityWithFees,\n        uint256 managerFee,\n        uint256 protocolFee\n    ) = calculateTotalFees(_setToken, _quantity, true);\n\n    // Prevent stack too deep\n    {\n        (\n            address[] memory components,\n            uint256[] memory equityUnits,\n            uint256[] memory debtUnits\n        ) = _calculateRequiredComponentIssuanceUnits(_setToken, quantityWithFees, true);\n\n        /// @audit totaly supply of setToken\n        uint256 finalSetSupply = initialSetSupply.add(quantityWithFees);\n\n        _resolveEquityPositions(_setToken, quantityWithFees, _to, true, components, equityUnits, initialSetSupply, finalSetSupply);\n        _resolveDebtPositions(_setToken, quantityWithFees, true, components, debtUnits, initialSetSupply, finalSetSupply);\n        /// @audit fees correctly minted to manager and protocol address if specified\n        _resolveFees(_setToken, managerFee, protocolFee);\n    }\n    \n        /// @audit `_quantity` minted to caller does not account for fees\n        _setToken.mint(_to, _quantity);    \n\n    emit SetTokenIssued(\n        _setToken,\n        msg.sender,\n        _to,\n        hookContract,\n        _quantity,\n        managerFee,\n        protocolFee\n    );\n}\n```\n\n### `DebtIssuanceModuleV2.redeem()`\nSimilarly, in `DebtIssuanceModuleV2.redeem()`, returns caller components from the SetToken, unwinds any external module component positions and burns the specified `_quantity` of SetToken. Fees are correctly minted via `_resolveFees()`, but the `_quantity` burned does not account for fees by adding `_quantity + managerFee + protocolFee`. This means that caller never pay the fees when calling `redeem()`.\n```solidity\nfunction redeem(\n    ISetToken _setToken,\n    uint256 _quantity,\n    address _to\n)\n    external\n    override\n    nonReentrant\n    onlyValidAndInitializedSet(_setToken)\n{\n    ...\n    ...\n    uint256 initialSetSupply = _setToken.totalSupply();\n\n    // Place burn after pre-redeem hooks because burning tokens may lead to false accounting of synced positions\n    /// @audit `_quantity` burned from caller does not account for fees\n    _setToken.burn(msg.sender, _quantity);\n\n    (\n        uint256 quantityNetFees,\n        uint256 managerFee,\n        uint256 protocolFee\n    ) = calculateTotalFees(_setToken, _quantity, false);\n\n    // Prevent stack too deep\n    {\n        (\n            address[] memory components,\n            uint256[] memory equityUnits,\n            uint256[] memory debtUnits\n        ) = _calculateRequiredComponentIssuanceUnits(_setToken, quantityNetFees, false);\n\n        uint256 finalSetSupply = initialSetSupply.sub(quantityNetFees);\n\n        _resolveDebtPositions(_setToken, quantityNetFees, false, components, debtUnits, initialSetSupply, finalSetSupply);\n        _resolveEquityPositions(_setToken, quantityNetFees, _to, false, components, equityUnits, initialSetSupply, finalSetSupply);\n        /// @audit fees correctly minted to manager and protocol address if specified\n        _resolveFees(_setToken, managerFee, protocolFee);\n    }\n\n    emit SetTokenRedeemed(\n        _setToken,\n        msg.sender,\n        _to,\n        _quantity,\n        managerFee,\n        protocolFee\n    );\n}\n```\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModuleV2.sol#L115\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModuleV2.sol#L159\n\n## Tool used\n\nManual Review\n\n## Recommendation\n```solidity\nfunction issue(\n    ISetToken _setToken,\n    uint256 _quantity,\n    address _to\n)\n    external\n    override\n    nonReentrant\n    onlyValidAndInitializedSet(_setToken)\n{   \n    ...\n    ...\n    ...\n    (\n        uint256 quantityWithFees,\n        uint256 managerFee,\n        uint256 protocolFee\n    ) = calculateTotalFees(_setToken, _quantity, true);\n\n    // Prevent stack too deep\n    {\n        (\n            address[] memory components,\n            uint256[] memory equityUnits,\n            uint256[] memory debtUnits\n        ) = _calculateRequiredComponentIssuanceUnits(_setToken, quantityWithFees, true);\n\n        uint256 finalSetSupply = initialSetSupply.add(quantityWithFees);\n\n        _resolveEquityPositions(_setToken, quantityWithFees, _to, true, components, equityUnits, initialSetSupply, finalSetSupply);\n        _resolveDebtPositions(_setToken, quantityWithFees, true, components, debtUnits, initialSetSupply, finalSetSupply);\n        _resolveFees(_setToken, managerFee, protocolFee);\n    }\n\n--      _setToken.mint(_to, _quantity);    \n++      _setToken.mint(_to, _quantity - managerFee - protocolFee);           \n    emit SetTokenIssued(\n        _setToken,\n        msg.sender,\n        _to,\n        hookContract,\n        _quantity,\n        managerFee,\n        protocolFee\n    );\n}\n```\n\n```solidity\nfunction redeem(\n    ISetToken _setToken,\n    uint256 _quantity,\n    address _to\n)\n    external\n    override\n    nonReentrant\n    onlyValidAndInitializedSet(_setToken)\n{\n    ...\n    ...\n    uint256 initialSetSupply = _setToken.totalSupply();\n\n    // Place burn after pre-redeem hooks because burning tokens may lead to false accounting of synced positions\n--  _setToken.burn(msg.sender, _quantity);\n\n    (\n        uint256 quantityNetFees,\n        uint256 managerFee,\n        uint256 protocolFee\n    ) = calculateTotalFees(_setToken, _quantity, false);\n\n++  _setToken.burn(msg.sender, _quantity + manageFee + protocolFee);\n\n    // Prevent stack too deep\n    {\n        (\n            address[] memory components,\n            uint256[] memory equityUnits,\n            uint256[] memory debtUnits\n        ) = _calculateRequiredComponentIssuanceUnits(_setToken, quantityNetFees, false);\n\n        uint256 finalSetSupply = initialSetSupply.sub(quantityNetFees);\n\n        _resolveDebtPositions(_setToken, quantityNetFees, false, components, debtUnits, initialSetSupply, finalSetSupply);\n        _resolveEquityPositions(_setToken, quantityNetFees, _to, false, components, equityUnits, initialSetSupply, finalSetSupply);\n        _resolveFees(_setToken, managerFee, protocolFee);\n    }\n\n    emit SetTokenRedeemed(\n        _setToken,\n        msg.sender,\n        _to,\n        _quantity,\n        managerFee,\n        protocolFee\n    );\n}\n```","decidedSeverity":"false","decidedDuplication":"Inconsistent charging of fees in `DebtIssuanceModuleV2.sol` `issue()` and `redeem()` functions"},{"file":"027.md","watson":{"name":"0xnevi"},"severity":"medium","title":"`AaveLeverageStrategyExtension.sol` does not allow user to specify slippage parameter during rebalance or ripcord","markdown":"0xnevi\n\nmedium\n\n# `AaveLeverageStrategyExtension.sol` does not allow user to specify slippage parameter during rebalance or ripcord\n\n## Summary\n`AaveLeverageStrategyExtension.sol` does not allow user to specify slippage parameter during rebalance or ripcord, which can expose them to sandwich attacks by MEV bots or other users, leading to loss of funds either by repaying more than expected during delevering or receiving lesser than expected collateral asset in the future when levering.\n\n## Vulnerability Detail\nRefer to Impact section.\n\n## Impact\n\n`execution.slippageTolerance` can only by set by operator via `setExecutionSettings()`. Hence for allowed users calling `rebalance()`, `iterateRebalance()` or `ripcord`, they can never specify their own slippage parameter\n\nThis can lead to the following 3 scenarios:\n\n1. If current leverage ratio greater than new leverage ratio (i.e. `_newLeverageRatio < _leverageInfo.currentLeverageRatio`) then rebalance decreases leverage for a given collateral position by withdrawing `_collateralAsset` from Aave and performing a swap, exchanging the `_collateralAsset` for `_repayAsset`. If slippage set by operator is too high or outdated, user can be sandwiched and repay more than expected `_repayAsset` to Aave module as slippage parameter `minRepayUnits` calculated via `_calculateMinRepayUnits()` will be overestimated.\n\n<br/>\n\n2. If current leverage ratio lesser or equal to new leverage ratio (i.e. `_newLeverageRatio >= _leverageInfo.currentLeverageRatio`), than rebalance increases leverage for a given collateral position by borrowing `_borrowAsset` from Aave and performing a DEX trade, exchanging the `_borrowAsset `for `_collateralAsset` and depositing `_collateralAsset` to Aave and mints corresponding aToken. If slippage set by operator is too high or outdated, user can be sandwiched and deposit lesser `_collateralAsset` to Aave module as slippage parameter `minReceiveCollateralUnits` calculated via `_calculateMinCollateralReceiveUnits()` will be underestimated, resulting lesser minting of aTokens for withdrawals later.\n\n<br/>\n\n3. Similarly, does not allow user to set `execution.slippageTolerance` when calling `ripcord()` to decrease leverage ratio back to maximum leverage ratio via `_delever()`. Similarly, if slippage set by operator is too high or outdated, user can be sandwiched and repay more than expected `_repayAsset` to Aave module.\n\nOverall, users can lose funds either by repaying more than expected during delevering or receiving lesser than expected collateral asset in the future when levering.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L304-L330\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L338-L366\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L376-L400\n\n## Tool used\nManual Review\n\n## Recommendation\nAllow users to specify their own slippage parameters when calling `rebalance()`, `iterateRebalance()` and `ripcord()`.","decidedSeverity":"medium","decidedDuplication":"`AaveLeverageStrategyExtension.sol` does not allow user to specify slippage parameter during rebalance or ripcord"},{"file":"028.md","watson":{"name":"Cryptor","days":26,"is_team":false,"payout":47.1,"score":0.864264114,"senior":false},"severity":"high","title":"Precision loss in calculation of totalRebalanceNotional","markdown":"Cryptor\n\nhigh\n\n# Precision loss in calculation of totalRebalanceNotional\n\n## Summary\nThe function _calculateChunkRebalanceNotional may calculate the wrong value for totalRebalanceNotional, resulting in the wrong leverage ratio in _updateRebalanceState\n\n## Vulnerability Detail\n\nThe function _calculateChunkRebalanceNotional calculates the value for  totalRebalanceNotional as follows\n\n```uint256 totalRebalanceNotional = leverageRatioDifference.preciseDiv(_leverageInfo.currentLeverageRatio).preciseMul(_leverageInfo.action.collateralBalance); ``` \n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1068\n\nThis will result in a precision loss as division is performed before multiplication. This may affect the result of  _updateRebalanceState\nwhich calculates a different leverage ratio depending on the value of totalRebalanceNotional \n\n```  if (_chunkRebalanceNotional < _totalRebalanceNotional) {   twapLeverageRatio = _newLeverageRatio;   } ```\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1169-L1171\n\n\n\n## Impact\nThe function may return the incorrect leverage ratio, when calling critical functions (engage, disengage, ripcord)\n\n\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1068\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1169-L1171\n\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\nPerform multiplication first and then do the division.\n\n","decidedSeverity":"medium","decidedDuplication":"division before multiplication may result in truncation of result"},{"file":"029.md","watson":{"name":"PRAISE","days":64,"is_team":false,"payout":403.7,"score":1.9031785617,"senior":false},"severity":"medium","title":"AmmModule.sol's addLiquidity() and addLiquiditySingleAsset() lacks expiration checks","markdown":"PRAISE\n\nmedium\n\n# AmmModule.sol's addLiquidity() and addLiquiditySingleAsset() lacks expiration checks\n\n## Summary\naddLiquidity() and addLiquiditySingleAsset() functions in AmmModule.sol lacks expiration checks\n\n## Vulnerability Detail\naddLiquidity() and addLiquiditySingleAsset() functions doesn't have expiration checks to help revert the transaction in case of network congestions.\n\nWithout deadline specified and a deadline checker, the trade could stay in the mempool for a very long time. \n\n Network Congestion  situations happens regularly in Mainnet this can cause the transaction to be delayed for a very long time.\n\n\n## Impact\ntransactions could be pending in the mempool for a very long time.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AmmModule.sol#L108\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AmmModule.sol#L155\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\nimplement a deadline and deadline checker like uniswap","decidedSeverity":"false","decidedDuplication":"AmmModule.sol's addLiquidity() and addLiquiditySingleAsset() lacks expiration checks"},{"file":"030.md","watson":{"name":"tsueti_","days":3,"is_team":false,"payout":1.14,"score":0.1133035547,"senior":false},"severity":"medium","title":"Use safeTransferFrom() Instead of transferFrom() For ERC20 Transfers","markdown":"tsueti_\n\nmedium\n\n# Use safeTransferFrom() Instead of transferFrom() For ERC20 Transfers\n\n## Summary\n\nThe transferFrom() function uses the transferFrom() method instead of safeTransferFrom().\n\n## Vulnerability Detail\n\nSome ERC20 tokens that are not compliant with the specification could return false from the transferFrom function call to indicate that the transfer fails, but the calling contract would not notice the failure if the return value is not checked. The EIP-20 specification requires checking the return value.\n\nSee reference for similar issue: [code-423n4/2021-08-yield-findings#36](https://github.com/code-423n4/2021-08-yield-findings/issues/36)\n\n\n## Impact\n\nCallers might not properly handle tokens that are not ERC20 compliant.\n\n## Code Snippet\n\nhttps://github.com/tsueti/index-protocol/blob/1c4ef28cb6cb01081ed9d0164bc89fc569546e74/contracts/protocol/lib/ModuleBase.sol#L118\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nI recommend using the safeTransferFrom() method by OpenZeppelin instead of transferFrom().\n","decidedSeverity":"false","decidedDuplication":"Use safeTransferFrom() Instead of transferFrom() For ERC20 Transfers"},{"file":"031.md","watson":{"name":"tsueti_","days":3,"is_team":false,"payout":1.14,"score":0.1133035547,"senior":false},"severity":"medium","title":"Use safeTransferFrom() Instead of transferFrom().","markdown":"tsueti_\n\nmedium\n\n# Use safeTransferFrom() Instead of transferFrom().\n\n## Summary\n\nThe ERC20.transfer() and ERC20.transferFrom() functions return a boolean value indicating success. This parameter needs to be checked for success. Some tokens do not revert if the transfer failed but return false instead.\n\n## Vulnerability Detail\n\nSome tokens (like USDT) don't correctly implement the EIP20 standard and their transfer/ transferFrom function return void instead of a successful boolean. Calling these functions with the correct EIP20 function signatures will always revert.\n\n## Impact\n\nTokens that don't actually perform the transfer and return false are still counted as a correct transfer and tokens that don't correctly implement the latest EIP20 spec, like USDT, will be unusable in the protocol as they revert the transaction because of the missing return value.\n\n## Code Snippet\n\nhttps://github.com/tsueti/index-protocol/blob/1c4ef28cb6cb01081ed9d0164bc89fc569546e74/contracts/protocol/modules/v1/DebtIssuanceModule.sol#L555\n\nhttps://github.com/tsueti/index-protocol/blob/1c4ef28cb6cb01081ed9d0164bc89fc569546e74/contracts/protocol/modules/v1/DebtIssuanceModule.sol#L602\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nI recommend using the safeTransferFrom() method by OpenZeppelin instead of transferFrom().\n","decidedSeverity":"false","decidedDuplication":"Use safeTransferFrom() Instead of transferFrom()."},{"file":"032.md","watson":{"name":"tsueti_","days":3,"is_team":false,"payout":1.14,"score":0.1133035547,"senior":false},"severity":"medium","title":"Unsafe use of transfer()/transferFrom() with IERC20","markdown":"tsueti_\n\nmedium\n\n# Unsafe use of transfer()/transferFrom() with IERC20\n\n## Summary\n\nSome tokens do not implement the ERC20 standard properly but are still accepted by most code that accepts ERC20 tokens.\n\n## Vulnerability Detail\n\nFor example, Tether (USDT)'s transfer() and transferFrom() functions on L1 do not return booleans as the specification requires, and instead have no return value. \n\n## Impact\n\nWhen these sorts of tokens are cast to IERC20, their [function signatures](https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca) do not match and therefore the calls made, revert (see [this](https://gist.github.com/IllIllI000/2b00a32e8f0559e8f386ea4f1800abc5) link for a test case).\n\n## Code Snippet\n\nhttps://github.com/tsueti/index-coop-smart-contracts/blob/1ab62b3636ccfe7da42c8227923a1598c0a0c21c/contracts/adapters/AaveLeverageStrategyExtension.sol#L584 \n\nhttps://github.com/tsueti/index-coop-smart-contracts/blob/1ab62b3636ccfe7da42c8227923a1598c0a0c21c/contracts/adapters/AaveLeverageStrategyExtension.sol#L1221\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse OpenZeppelin’s SafeERC20's safeTransfer()/safeTransferFrom() instead\n","decidedSeverity":"false","decidedDuplication":"Unsafe use of transfer()/transferFrom() with IERC20"},{"file":"033.md","watson":{"name":"XDZIBEC"},"severity":"medium","title":"XDZIBEC- Integer Division Truncation Vulnerability in \"Vesting\" Contract","markdown":"XDZIBEC\n\nmedium\n\n# XDZIBEC- Integer Division Truncation Vulnerability in \"Vesting\" Contract\n\n## Summary\n\nThere is a vulnerability in the `claim()` function that can be called by anyone, not just the `recipient`, `allowing unauthorized access to the funds`. \nThis security issue it can lead to loss of funds. \nTo fix this vulnerability,the `claim()` function should only be `callable` by the `recipient`. \nThis can be done by adding a modifier to the function that checks if the `caller` is the `recipient`. \nFor example, modifier `onlyRecipient(){ require(msg.sender == recipient, \"TreasuryVester.claim: unauthorized\"); _; }` can be added to the contract, and then the `claim() `function can be modified to include this modifier: function `claim() public onlyRecipient`.\n\n\n## Vulnerability Detail\n\n- https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/token/Vesting.sol#LL49C3-L60C2\n\n ```SOLIDITY\n function claim() public {\n        require(block.timestamp >= vestingCliff, \"TreasuryVester.claim: not time yet\");\n        uint256 amount;\n        if (block.timestamp >= vestingEnd) {\n            amount = IERC20(index).balanceOf(address(this));\n        } else {\n            amount = vestingAmount.mul(block.timestamp.sub(lastUpdate)).div(vestingEnd.sub(vestingBegin));\n            lastUpdate = block.timestamp;\n        }\n        IERC20(index).transfer(recipient, amount);\n    }\n}\n```\nThe vulnerability in the `claim` function arises from the use of integer division without considering the possibility of truncation. In Solidity, when dividing two integers, the result is always truncated towards zero.\nThis means that the fractional part of the division is discarded, leading to potential inaccuracies.\nThe `amount` variable is calculated using integer division with the `div` function. Here's a breakdown of the calculation:\n-` block.timestamp.sub(lastUpdate)` This calculates the time difference between the current timestamp (block.timestamp) and the lastUpdate variable.\n- `vestingEnd.sub(vestingBegin)` This calculates the total time duration between the vesting end and vesting begin timestamps.\n- `vestingAmount.mul(block.timestamp.sub(lastUpdate))` This multiplies the vesting amount by the time difference calculated in step 1.\n- `vestingAmount.mul(block.timestamp.sub(lastUpdate)).div(vestingEnd.sub(vestingBegin))` This performs integer division between the   \n   result of step 3 and the time duration calculated in step 2, assigning the result to the amount variable.\nThe vulnerability lies in the truncation that occurs during the division in step 4. If the division does not yield an exact integer value, the fractional part will be discarded, leading to potential inaccuracies in the transferred amount.\n\n\n## Impact\n\n-If the division truncation occurs, the `amount` variable will hold an incorrect value. \nConsequently, the incorrect `amount` will be transferred to the recipient, potentially resulting in loss or undesired behavior.\n\n- To exploit the vulnerability  An attacker would need to provide input that triggers the claim function. By manipulating the values of `vestingBegin`, `vestingEnd`, `vestingAmount,` and `block.timestamp`, an attacker could cause the division truncation to occur, resulting in an incorrect amount being transferred\n\n## Code Snippet\n\n- https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/token/Vesting.sol#L49C3-L60C2\n- https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/token/Vesting.sol#L49C3-L60C2\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n- It is recommended to use a division method that handles fractional values correctly. One possible approach is to use fixed-point arithmetic, which involves representing fractional numbers as scaled integers. Another option is to use a library or implementation that supports arbitrary precision arithmetic, ensuring accurate calculations with fractional values","decidedSeverity":"false","decidedDuplication":"XDZIBEC- Integer Division Truncation Vulnerability in \"Vesting\" Contract"},{"file":"034.md","watson":{"name":"PRAISE","days":64,"is_team":false,"payout":403.7,"score":1.9031785617,"senior":false},"severity":"medium","title":"in ExplicitERC20.sol, the transferFrom function doesn't ensure that the `from` balance >= `_quantity`","markdown":"PRAISE\n\nmedium\n\n# in ExplicitERC20.sol, the transferFrom function doesn't ensure that the `from` balance >= `_quantity`\n\n## Summary\nthe `from` balance should be = `_quantity` or > `_quantity`\n## Vulnerability Detail\nthe `transferFrom` should have a sanity check to ensure that `from` must have a balance of at least `_quantity`.\n\nchecking OpenZeppelin's implementation of their `transferFrom()` function it is part of their requirements.\n\nsee here-- https://github.com/OpenZeppelin/openzeppelin-contracts/blob/09329f8a18f08df65863a5060f6e776bf7fccacf/contracts/token/ERC20/ERC20.sol#L154\n\n## Impact\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/lib/ExplicitERC20.sol#L43-L70\n## Tool used\n\nManual Review\n\n## Recommendation\nput a check to ensure the `from` address balance is >= `_quantity`","decidedSeverity":"false","decidedDuplication":"in ExplicitERC20.sol, the transferFrom function doesn't ensure that the `from` balance >= `_quantity`"},{"file":"035.md","watson":{"name":"PRAISE","days":64,"is_team":false,"payout":403.7,"score":1.9031785617,"senior":false},"severity":"medium","title":"there should be a check to ensure there's allowance for ``from``'s tokens of at least `_quantity`","markdown":"PRAISE\n\nmedium\n\n# there should be a check to ensure there's allowance for ``from``'s tokens of at least `_quantity`\n\n## Summary\nthe transferFrom() in explicitErc20.sol doesn't check to ensure that there's allowance to spend for `from`'s tokens of at least `_quantity`.\n## Vulnerability Detail\nThis is also one of the requirements of OpenZeppelin's implementation of the transferFrom() function.\nsee here- https://github.com/OpenZeppelin/openzeppelin-contracts/blob/09329f8a18f08df65863a5060f6e776bf7fccacf/contracts/token/ERC20/ERC20.sol#L155-L156\n\nthis is to ensure that the caller, spender/to address has allowance from the `from` address to spend a specific amount of his tokens on his behalf(i.e `_quantity` in our case).\n## Impact\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/lib/ExplicitERC20.sol#L43-L70\n## Tool used\n\nManual Review\n\n## Recommendation\nimplement something similar to how OpenZeppelin implemented theirs\n```solidity\n function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n```\nthen the _spendAllowance should be something like this\n```solidity\n function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n```\n\n\n","decidedSeverity":"false","decidedDuplication":"there should be a check to ensure there's allowance for ``from``'s tokens of at least `_quantity`"},{"file":"036.md","watson":{"name":"lil.eth"},"severity":"medium","title":"Use of Deprecated ChainLink function : latestAnswer()","markdown":"lil.eth\n\nmedium\n\n# Use of Deprecated ChainLink function : latestAnswer()\n\n## Summary\n\nAccording to Chainlink’s documentation (API Reference), the latestAnswer function is deprecated. This function does not throw an error if no answer has been reached, but instead returns 0, possibly causing an incorrect price to be fed to the different price feeds or even a Denial of Service by a division by zero.\n\n## Vulnerability Detail\n\nDeprecated latestAnswer() function usage when gathering price for rawCollateralPrice and rawBorrowPrice\n\n## Impact\n\nrawCollateralPrice and rawBorrowPrice could be set to 0 if an answer if not reach, moreover the fact that no check is made regarding the strict positive value of `strategy.collateralPriceOracle.latestAnswer()` call\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L895-L897\n```solidity\n        int256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer(); \n        int256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer(); \n```\nIt is also present in these out of scope contracts : \n\n- ./index-coop-smart-contracts/contracts/adapters/FlexibleLeverageStrategyExtension.sol:        int256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\n- ./index-coop-smart-contracts/contracts/adapters/FlexibleLeverageStrategyExtension.sol:        int256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer();\n\n## Tool used\n\nManual Review\n\n## Recommendation\nBased on https://docs.chain.link/docs/historical-price-data, the followings can be done to avoid using a stale price returned by the Chainlink price feed.\n\n- The latestRoundData function can be used instead of the deprecated latestAnswer function.\n- roundId and answeredInRound are also returned. \"You can check answeredInRound against the current roundId. If answeredInRound is less than roundId, the answer is being carried over. If answeredInRound is equal to roundId, then the answer is fresh.\"\n- \"A read can revert if the caller is requesting the details of a round that was invalid or has not yet been answered. If you are deriving a round ID without having observed it before, the round might not be complete. To check the round, validate that the timestamp on that round is not 0.\"","decidedSeverity":"medium","decidedDuplication":"Deprecated oracle function `latestAnswer()` could bring fund loss"},{"file":"037.md","watson":{"name":"lil.eth"},"severity":"medium","title":"Adress.call{}() should be used instead of address.transfer()","markdown":"lil.eth\n\nmedium\n\n# Adress.call{}() should be used instead of address.transfer()\n\n## Summary\n\naddress.call{value:x}() should be used instead of address.transfer()\n\n## Vulnerability Detail\n\nUse call instead of transfer to send ether. And return value must be checked if sending ether is successful or not.\nSending ether with the transfer is no longer recommended.\n\n## Impact\n\nWhen withdrawing and refund ETH, the contract uses Solidity’s transfer() function.\n\nThe issues with transfer() are outlined [here](https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/)\n\nUsing Solidity's transfer() function has some notable shortcomings when the withdrawer is a smart contract, which can render ETH deposits impossible to withdraw. Specifically, the withdrawal will inevitably fail when:\n\nThe withdrawer smart contract does not implement a payable fallback function.\nThe withdrawer smart contract implements a payable fallback function which uses more than 2300 gas units.\nThe withdrawer smart contract implements a payable fallback function which needs less than 2300 gas units but is called through a proxy that raises the call’s gas usage above 2300.\n\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L584\nHere msg.sender can be a smart contract then using low-level call.value(amount) with the corresponding result check is recommended\n```solidity\n    function withdrawEtherBalance() external onlyOperator noRebalanceInProgress {\n        msg.sender.transfer(address(this).balance); \n    }\n```\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1221\nHere , msg.sender can only be an EAO then using transfer() is ok If you want to allow contract accounts as receivers or want to future-proof your contract, using .call{value: _}(\"\") is better if you check the return value.\n```solidity\n    function _transferEtherRewardToCaller(uint256 _etherReward) internal returns(uint256) {\n        uint256 etherToTransfer = _etherReward < address(this).balance ? _etherReward : address(this).balance;\n\n        msg.sender.transfer(etherToTransfer); \n\n        return etherToTransfer;\n    }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWhen transferring ETH using low-level call.value(amount) with the corresponding result check or using the OpenZeppelin Address.sendValue is advised, [reference](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L60).\n","decidedSeverity":"false","decidedDuplication":"Adress.call{}() should be used instead of address.transfer()"},{"file":"038.md","watson":{"name":"rvierdiiev","days":240,"is_team":false,"payout":53245.07,"score":59.5872615419,"senior":false},"severity":"medium","title":"Protocol will not work with fee on transfer tokens","markdown":"rvierdiiev\n\nmedium\n\n# Protocol will not work with fee on transfer tokens\n\n## Summary\nProtocol will not work with fee on transfer tokens, as `ExplicitERC20.transferFrom` checks that exactly same balance was received.\n## Vulnerability Detail\n`ExplicitERC20.transferFrom` function is used through the whole protocol in order to make transfers.\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/lib/ExplicitERC20.sol#L43-L70\n```solidity\n    function transferFrom(\n        IERC20 _token,\n        address _from,\n        address _to,\n        uint256 _quantity\n    )\n        internal\n    {\n        // Call specified ERC20 contract to transfer tokens (via proxy).\n        if (_quantity > 0) {\n            uint256 existingBalance = _token.balanceOf(_to);\n\n            SafeERC20.safeTransferFrom(\n                _token,\n                _from,\n                _to,\n                _quantity\n            );\n\n            uint256 newBalance = _token.balanceOf(_to);\n\n            // Verify transfer quantity is reflected in balance\n            require(\n                newBalance == existingBalance.add(_quantity),\n                \"Invalid post transfer balance\"\n            );\n        }\n    }\n```\nAs you can see, this function checks in the end that exactly `_quantity` was received after the transfer.\nBecause of that protocol will not be working with fee on transfer tokens as SetToken components. [Issuing of SetToken](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/BasicIssuanceModule.sol#L107-L112\n) will not be possible as `ModuleBase.transferFrom` function uses `ExplicitERC20.transferFrom` function.\n## Impact\nProtocol is not compatible with fee on transfer tokens.\n## Code Snippet\nProvided above.\n## Tool used\n\nManual Review\n\n## Recommendation\nIn order to make `ExplicitERC20.transferFrom` function work with fee on transfer tokens, you don't need to check exact amount to be received. But, as this function is used across whole protocol, it can not just simple and changing can create another problems.","decidedSeverity":"medium","decidedDuplication":"Protocol will not work with fee on transfer tokens"},{"file":"039.md","watson":{"name":"rvierdiiev","days":240,"is_team":false,"payout":53245.07,"score":59.5872615419,"senior":false},"severity":"medium","title":"AmmModule will not work with usdt","markdown":"rvierdiiev\n\nmedium\n\n# AmmModule will not work with usdt\n\n## Summary\nAmmModule will not work with usdt, because it approves amount without reseting approve to 0 before. Because it's possible that amm will trade not whole approved amount, then next approve will fail.\n## Vulnerability Detail\n`AmmModule.addLiquidity` function allows to provide SetToken components as liquidity into the amm pool.\n`_executeAddLiquidity` function [is called](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AmmModule.sol#L131) in order to provide liquidity.\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AmmModule.sol#L430-L444\n```solidity\n    function _executeAddLiquidity(ActionInfo memory _actionInfo) internal {\n        (\n            address targetAmm, uint256 callValue, bytes memory methodData\n        ) = _actionInfo.ammAdapter.getProvideLiquidityCalldata(\n            address(_actionInfo.setToken),\n            _actionInfo.liquidityToken,\n            _actionInfo.components,\n            _actionInfo.totalNotionalComponents,\n            _actionInfo.liquidityQuantity\n        );\n\n        _executeComponentApprovals(_actionInfo);\n\n        _actionInfo.setToken.invoke(targetAmm, callValue, methodData);\n    }\n```\nFirst of all, amm adapter is called with `totalNotionalComponents` array, which is maximum amounts of components that should be added as liquidity. Later, this amounts [will be approved to the amm pool](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AmmModule.sol#L422-L426). \nThe problem is that it's not guaranteed that amm pool will use whole amount that was provided by user. For example uniswap v3 will adjust user's input amounts to mint liquidity.\n\nAnd in case if usdt is used as token that was not used for the whole approved amount, then next trade will fail as usdt will not provide new approve.\n## Impact\nTrading with usdt token may fail.\n## Code Snippet\nProvided above\n## Tool used\n\nManual Review\n\n## Recommendation\nYou can reset approve to 0 before providing new one. ","decidedSeverity":"medium","decidedDuplication":"AmmModule will not work with usdt"},{"file":"040.md","watson":{"name":"rvierdiiev","days":240,"is_team":false,"payout":53245.07,"score":59.5872615419,"senior":false},"severity":"medium","title":"Using deprecated Chainlink function latestAnswer","markdown":"rvierdiiev\n\nmedium\n\n# Using deprecated Chainlink function latestAnswer\n\n## Summary\n`AaveLeverageStrategyExtension` uses chainlink deprecated `latestAnswer` function. Such function might suddenly stop working if Chainlink will stop supporting deprecated APIs.\n## Vulnerability Detail\n`AaveLeverageStrategyExtension` [uses chainlink `latestAnswer` function](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L895-L897) which [is deprecated](https://docs.chain.link/data-feeds/api-reference#latestanswer).\n\nChainlink says that you should not use this function and in case if they will stop support it, then protocol will face problems.\n## Impact\n`AaveLeverageStrategyExtension` will not work.\n## Code Snippet\nProvided above\n## Tool used\n\nManual Review\n\n## Recommendation\nUse `latestRoundData` function and also add check for stale prices.","decidedSeverity":"medium","decidedDuplication":"Deprecated oracle function `latestAnswer()` could bring fund loss"},{"file":"041.md","watson":{"name":"rvierdiiev","days":240,"is_team":false,"payout":53245.07,"score":59.5872615419,"senior":false},"severity":"medium","title":"Missing checks for whether Arbitrum Sequencer is active","markdown":"rvierdiiev\n\nmedium\n\n# Missing checks for whether Arbitrum Sequencer is active\n\n## Summary\nAaveLeverageStrategyExtension doesn't check whether the Arbitrum Sequencer is active when using prices from chainlink oracle.\n## Vulnerability Detail\nIndex protocol is going to launch on arbitrum network.\n`AaveLeverageStrategyExtension` is using chainlink oracle in order to get prices. Chainlink recommends to check if arbitrum sequencer [is active](https://docs.chain.link/data-feeds/l2-sequencer-feeds#arbitrum) in order to get fresh prices. Otherwise stale prices can be fetched.\n## Impact\n`AaveLeverageStrategyExtension` can calculate leverage/deleverage amounts incorrectly, because of not fresh prices and as result position can become liquidatable, which will cause loss of fund for SetToken share holders.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L895-L897\n## Tool used\n\nManual Review\n\n## Recommendation\nCheck that sequencer is not down.\nPls, see this issue as reference: https://github.com/sherlock-audit/2023-02-gmx-judging/issues/151","decidedSeverity":"medium","decidedDuplication":"Missing checks for whether Arbitrum Sequencer is active"},{"file":"042.md","watson":{"name":"Cryptor","days":26,"is_team":false,"payout":47.1,"score":0.864264114,"senior":false},"severity":"high","title":"Chainlink latestanswer is deprecated","markdown":"Cryptor\n\nhigh\n\n# Chainlink latestanswer is deprecated\n\n## Summary\nThe protocol uses an incorrect implementation of chainlink to calculate prices that are then used in the internal functions lever and delever. \n\n## Vulnerability Detail\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L895\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L897\n\nThe protocol uses the function latestanswer from the V3 aggreagator but this function is deprecated as shown here \n\n\nhttps://docs.chain.link/data-feeds/api-reference#latestanswer\n\n<img width=\"483\" alt=\"image\" src=\"https://github.com/sherlock-audit/2023-05-Index-JJtheAndroid/assets/29849840/c3315bc1-ff54-4aca-bf82-07bfec530d87\">\n\n\n\n\n## Impact\nChainlink oracles will not work properly \n\n\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L895\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L897\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse the updated Chainlink V3 aggregator implementation\n\nhttps://docs.chain.link/data-feeds/api-reference\n","decidedSeverity":"medium","decidedDuplication":"Deprecated oracle function `latestAnswer()` could bring fund loss"},{"file":"043.md","watson":{"name":"Cryptor","days":26,"is_team":false,"payout":47.1,"score":0.864264114,"senior":false},"severity":"high","title":"_calculateMaxBorrowCollateral will return the wrong ltv if eMode is enabled","markdown":"Cryptor\n\nhigh\n\n# _calculateMaxBorrowCollateral will return the wrong ltv if eMode is enabled\n\n## Summary\n\nThe function _calculateMaxBorrowCollateral uses the Aave function getReserveConfigurationData to calculate the max borrow amount for the desired collateral shown here \n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1098\n\nHowever, if eMode is enabled for an asset, the ltv for an asset changes as the eMode allows for a greater ltv than normal.\n\n<img width=\"602\" alt=\"image\" src=\"https://github.com/sherlock-audit/2023-05-Index-JJtheAndroid/assets/29849840/461c203d-e5dd-4dce-888d-bd2fd43c4312\">\n\nThis can result in premature liquidations though ripcord\n\n\n## Vulnerability Detail\n\nsee above \n\n## Impact\nThe function will calculate the wrong ltv for emode assets, resulting in premature ripcords and suboptimal efficiency of collateral\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1098\n\n## Tool used\n\nManual Review\n\n## Recommendation\nAdd a check if emode is enabled and then call the function getEmodeCategoryData which returns the ltv of an asset in eMode\n\nhttps://docs.aave.com/developers/core-contracts/pool#getemodecategorydata\n","decidedSeverity":"false","decidedDuplication":"_calculateMaxBorrowCollateral will return the wrong ltv if eMode is enabled"},{"file":"044.md","watson":{"name":"Cryptor","days":26,"is_team":false,"payout":47.1,"score":0.864264114,"senior":false},"severity":"high","title":"RemoveModule in AMM module does not check if there is outstanding liquidity in an AMM","markdown":"Cryptor\n\nhigh\n\n# RemoveModule in AMM module does not check if there is outstanding liquidity in an AMM\n\n## Summary\nThe function remove module in AMMmodule.sol. removes a module from the protocol. However, the module involves investing user funds in AMM pools, and with no check to make sure that all liquidity has been removed. \n\n\n\n## Vulnerability Detail\n\nThe function remove module removes a module from the protocol. However, the module has several functions that allows the manager to add and remove liquidity to AMM pools shown here.\n\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AmmModule.sol#L108-L118\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AmmModule.sol#L206-L213\n\n\nHowever, the function removeModule does not remove liquidity. \n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AmmModule.sol#L310\n\n\nSo there could be a situation where liquidity is added and then Removemodule is called leaving funds stranded in various AMM protocols. This could be a problem when interacting with a protocol like uniswap where after adding liquidity, a settoken contract is given an NFT as a representation of the LP position. If removemodule is called and a user tries to redeem tokens, then there may be an accounting error where users are receiving less collateral than they should receive. This is because the protocol is not designed to handle NFTs\n\n\n\n## Impact\n\nAccounting error when removemodule is called due to not being able to handle LP NFTs left in the contract\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AmmModule.sol#L310\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd check to make sure that all liquidity is removed before removing a module when using an AMM module \n","decidedSeverity":"false","decidedDuplication":"RemoveModule in AMM module does not check if there is outstanding liquidity in an AMM"},{"file":"045.md","watson":{"name":"coffiasd"},"severity":"high","title":"When streamingFee is a small value, _calculateStreamingFee will lose precision","markdown":"coffiasd\n\nhigh\n\n# When streamingFee is a small value, _calculateStreamingFee will lose precision\n\n## Summary\nThe `streamingFeePercentage` does not have a minimum value set. When it is set to a relatively small value, even after a considerable amount of time has passed (let's say one year), due to precision loss, the calculated `inflationFeePercentage` value would be 0. This results in the `lastStreamingFeeTimestamp` being updated without actually receiving the deserved funds\n\n## Vulnerability Detail\nAdd test to streamingFeeModule.spec.ts:\n```javascript\n    describe(\"When streamingFee is a small value, _calculateStreamingFee will lose precision\", async () => {\n      beforeEach(async () => {\n        //set fee to a small value.\n        await streamingFeeModule.updateStreamingFee(subjectSetToken, 1);\n      });\n\n      it(\"should update the last timestamp\", async () => {\n        const txnTimestamp = await getTransactionTimestamp(subject());\n\n        const feeState: any = await streamingFeeModule.feeStates(subjectSetToken);\n\n        expect(feeState.lastStreamingFeeTimestamp).to.eq(txnTimestamp);\n      });\n\n      it(\"calculateStreamingFee should be zero\", async () => {\n      //increase timestamp(one year)\n        await increaseTimeAsync(BigNumber.from(31557600 - 1));\n        const calculateStreamingFee: any = await streamingFeeModule.getFee(subjectSetToken);\n        expect(calculateStreamingFee).to.eq(ZERO);\n      });\n    });\n```\n\n## Impact\nManager and protocol will lost fee \n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/StreamingFeeModule.sol#L203#L208\n## Tool used\n\nManual Review\n\n## Recommendation\nstreamingFee need a minimum value to ensure not lose precision","decidedSeverity":"false","decidedDuplication":"When streamingFee is a small value, _calculateStreamingFee will lose precision"},{"file":"046.md","watson":{"name":"Bauer","days":121,"is_team":false,"payout":12011.73,"score":21.4221078132,"senior":false},"severity":"medium","title":"The protocol doesn't check If Arbitrum sequencer is down in Chainlink feeds","markdown":"Bauer\n\nmedium\n\n# The protocol doesn't check If Arbitrum sequencer is down in Chainlink feeds\n\n## Summary\nNot checking if the sequencer is down may result in bd actors obtaining inconsistent and unfair prices.\n\n\n## Vulnerability Detail\nThe `engage()` function is responsible for initializing and managing the leverage position of a SetToken on a specific exchange.  Inside the function ,it retrieves the latest price of the asset from the Chainlink oracle. However, it does not check whether Arbitrum Sequencer is active.\nThe protocol intends to deploy to arbtrium as well!\nChainlink recommends that users using price oracles, check whether the Arbitrum sequencer is active\nhttps://docs.chain.link/data-feeds#l2-sequencer-uptime-feeds\nIf the sequencer goes down, the index oracles may have stale prices, since L2-submitted transactions (i.e. by the aggregating oracles) will not be processed.\n```solidity\n function _createActionInfo() internal view returns(ActionInfo memory) {\n        ActionInfo memory rebalanceInfo;\n\n        // Calculate prices from chainlink. Chainlink returns prices with 8 decimal places, but we need 36 - underlyingDecimals decimal places.\n        // This is so that when the underlying amount is multiplied by the received price, the collateral valuation is normalized to 36 decimals. \n        // To perform this adjustment, we multiply by 10^(36 - 8 - underlyingDecimals)\n        int256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\n        rebalanceInfo.collateralPrice = rawCollateralPrice.toUint256().mul(10 ** strategy.collateralDecimalAdjustment);\n        int256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer();\n```\n\n## Impact\nCould potentially be exploited by malicious actors to gain an unfair advantage.\n\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L889-L907\n## Tool used\n\nManual Review\n\n## Recommendation\nCheck if sequencer is down","decidedSeverity":"medium","decidedDuplication":"Missing checks for whether Arbitrum Sequencer is active"},{"file":"047.md","watson":{"name":"Bauer","days":121,"is_team":false,"payout":12011.73,"score":21.4221078132,"senior":false},"severity":"medium","title":"Chainlink's reported answer can be being carried over and stale","markdown":"Bauer\n\nmedium\n\n# Chainlink's reported answer can be being carried over and stale\n\n## Summary\nThere is  no check for round completeness\n## Vulnerability Detail\nhttps://docs.chain.link/data-feeds/price-feeds/historical-data#getrounddata-return-values mentions: \"You can check answeredInRound against the current roundId. If answeredInRound is less than roundId, the answer is being carried over. If answeredInRound is equal to roundId, then the answer is fresh.\" However, the latestAnswer function, which is shown in the Code Snippet section, does not check answeredInRound against the current roundId, where answeredInRound and roundId are returned . This can lead to unreliable reported price based on the Chainlink's reported answer that is being carried over and stale.\n```solidity\nfunction _createActionInfo() internal view returns(ActionInfo memory) {\n        ActionInfo memory rebalanceInfo;\n\n        // Calculate prices from chainlink. Chainlink returns prices with 8 decimal places, but we need 36 - underlyingDecimals decimal places.\n        // This is so that when the underlying amount is multiplied by the received price, the collateral valuation is normalized to 36 decimals. \n        // To perform this adjustment, we multiply by 10^(36 - 8 - underlyingDecimals)\n        int256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\n```\n\n## Impact\nWhen the Chainlink's reported answer is being carried over and stale, such answer is not reliable. Using the reported price based on such unreliable answer can cause critical user actions, that should be disallowed to be allowed, or vice versa.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L895\n## Tool used\n\nManual Review\n\n## Recommendation\nAdd the below check for returned data\n\n```solidity\n\n (uint80 roundID, int256 answer, uint256 timestamp, uint256 updatedAt, ) = strategy.collateralPriceOracle.latestRoundData(\n            token,\n            USD\n        );\n        require(updatedAt >= roundID, \"Stale price\");\n        require(timestamp != 0,\"Round not complete\");\n        require(answer > 0,\"Chainlink answer reporting 0\");\n\n        if (updatedAt < block.timestamp - maxDelayTime)\n            revert PRICE_OUTDATED(_token);\n```\n","decidedSeverity":"medium","decidedDuplication":"Chainlink's latestRoundData return stale or incorrect result"},{"file":"048.md","watson":{"name":"yy","days":3,"is_team":false,"payout":0,"score":0.0011486465,"senior":false},"severity":"high","title":"Lack of access control in `SetTokenCreator.sol` (`create()` function)","markdown":"yy\n\nhigh\n\n# Lack of access control in `SetTokenCreator.sol` (`create()` function)\n\n## Summary\nAllowing anyone to call the SetTokenCreator to create and register new SetTokens that could be an issue.\n\n## Vulnerability Detail\nBased on the document description of SetTokenCreator and the comment of code, it should be \"Factory contract that is enabled by the controller to create and register new SetTokens\" (https://docs.indexcoop.com/index-coop-community-handbook/protocols/index-protocol#modules). However, the `create()` function in SetTokenCreator.sol is set to public (everyone could call the function).\n\n```solidity\nfunction create(\n        address[] memory _components,\n        int256[] memory _units,\n        address[] memory _modules,\n        address _manager,\n        string memory _name,\n        string memory _symbol\n    )\n        external ...\n```\n\n## Impact\nThe lack of access control allowed everyone call this function to create and register new `SetToken`.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/SetTokenCreator.sol#L66\n\n## Tool used\nManual Review\n\n## Recommendation\nOnly allow certain addresses to create SetTokens. These could be admin addresses, or addresses that have been vetted and approved in some way.","decidedSeverity":"false","decidedDuplication":"Lack of access control in `SetTokenCreator.sol` (`create()` function)"},{"file":"049.md","watson":{"name":"Bauer","days":121,"is_team":false,"payout":12011.73,"score":21.4221078132,"senior":false},"severity":"medium","title":"Precision loss to update position","markdown":"Bauer\n\nmedium\n\n# Precision loss to update position\n\n## Summary\nLoss of precision to  update position\n## Vulnerability Detail\nThe `_updateLeverPositions()` function is responsible for updating the collateral and borrow positions for a given SetToken.  Inside the function ,it  calls the \"_updateCollateralPosition()\" function to the calculated collateral position.The calculation formula is as follows.\n```solidity\ncollateralNotionalBalance.preciseDiv(_setTotalSupply)\n```\nThen, it  updates the collateral position for the specified SetToken and aToken.\n```solidity\ndivDown(a.mul(PRECISE_UNIT_INT), b)\n```\nIn Solidity division can result in rounding down errors, hence to minimize any rounding errors we always want to perform multiplication before division. Hence ,there is a precision loss here. \nhttps://dacian.me/precision-loss-errors#heading-division-before-multiplication\n\nIn the given scenario, the collateralNotionalBalance is 10000000000030000, the _setTotalSupply is 5999999999999999999999, and b is 99999999999999999.\n\nIf we calculate the result by dividing and then multiplying, we have:\na = 10000000000030000 * 1e18 / 5999999999999999999999 = 1666666666671\nc = a * 1e18 / 99999999999999999 = 16666666666710\n\nOn the other hand, if we calculate the result by multiplying and then dividing, we have:\nc=10000000000030000 * 1e18 * 1e18 / 5999999999999999999999 / 99999999999999999 = 16666666666716\n\n There is a slight difference between the two results.\n\nThe same issue for updating borrow position.\n## Impact\nLoss of precision to  update position\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveLeverageModule.sol#L840-L848\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveLeverageModule.sol#L850-L858\n## Tool used\n\nManual Review\n\n## Recommendation\n","decidedSeverity":"medium","decidedDuplication":"division before multiplication may result in truncation of result"},{"file":"050.md","watson":{"name":"yy","days":3,"is_team":false,"payout":0,"score":0.0011486465,"senior":false},"severity":"medium","title":"Solidity 0.6.10 version is using in `SetTokenCreator.sol` which would result in an out-of-gas error.","markdown":"yy\n\nmedium\n\n# Solidity 0.6.10 version is using in `SetTokenCreator.sol` which would result in an out-of-gas error.\n\n## Summary\nSolidity 0.6.10 version is using in `SetTokenCreator.sol` which would result in an out-of-gas error.\n\n## Vulnerability Detail\nThe caller of the `create()` function could potentially pass in a very large array of _components, _units, or _modules, causing the for loop to consume more gas than the block gas limit. The length of these arrays is not limited, and the function does not check the length of these arrays before proceeding. This wouldn't cause an overflow but would result in an out-of-gas error.\n\n## Impact\nLead to wasted resources, as users are paying for gas for transactions that ultimately fail.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/SetTokenCreator.sol#L19\n\n## Tool used\nManual Review\n\n## Recommendation\nThe contract could implement a limit on the length of the arrays that can be passed to the create() function, ensuring that it won't exceed the block gas limit. ","decidedSeverity":"false","decidedDuplication":"Solidity 0.6.10 version is using in `SetTokenCreator.sol` which would result in an out-of-gas error."},{"file":"051.md","watson":{"name":"saidam017","days":26,"is_team":false,"payout":1006,"score":12.5523939942,"senior":false},"severity":"medium","title":"`validateCollateralizationPostTransferInPreHook` could not work with token that have fee on transfer","markdown":"saidam017\n\nmedium\n\n# `validateCollateralizationPostTransferInPreHook` could not work with token that have fee on transfer\n\n## Summary\n\n`validateCollateralizationPostTransferInPreHook()` used inside `DebtIssuanceModuleV2` to verify the transferred token is at least (position unit of the component x initial supply) + amount transferred. However, if token with fee on transfer is used, the received value for set token is less than the actual amount, and make the call mistakenly revert.\n\n## Vulnerability Detail\n\n`validateCollateralizationPostTransferInPreHook()` is used to verify that `_initialSetSupply.preciseMulCeil(defaultPositionUnit).add(_componentQuantity)`  is at least equal `newComponentBalance` : \n\n```solidity\n  function validateCollateralizationPostTransferInPreHook(\n    ISetToken _setToken,\n    address _component,\n    uint256 _initialSetSupply,\n    uint256 _componentQuantity\n  ) internal view {\n    uint256 newComponentBalance = IERC20(_component).balanceOf(address(_setToken));\n\n    uint256 defaultPositionUnit = _setToken\n      .getDefaultPositionRealUnit(address(_component))\n      .toUint256();\n    // @audit - this not work for fee on transfer\n    require(\n      newComponentBalance >=\n        _initialSetSupply.preciseMulCeil(defaultPositionUnit).add(_componentQuantity),\n      \"Invalid transfer in. Results in undercollateralization\"\n    );\n  }\n```\n\n` newComponentBalance` is calculated from current balance of set token and will always increase less than the `_componentQuantity` if fee on transfer token is used.\n\n## Impact\n\nThe hook could revert and make the `DebtIssuanceModuleV2` not support tokens with fee on transfer.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/lib/IssuanceValidationUtils.sol#L61-L65\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCalculate the initial set token's component balance before transfer : \n\n```solidity\n          ....\n          // get the initial balance before transfer\n         uint256 _initialBalance = IERC20(component).balanceOf(address(_setToken));\n\n          // Call SafeERC20#safeTransferFrom instead of ExplicitERC20#transferFrom\n          SafeERC20.safeTransferFrom(\n            IERC20(component),\n            msg.sender,\n            address(_setToken),\n            componentQuantity\n          );\n\n          IssuanceValidationUtils.validateCollateralizationPostTransferInPreHook(\n            _setToken,\n            component,\n            _initialSetSupply,\n            _initialBalance, // New param, pass it to the hook\n          );\n         ....\n```\n\nPass it to ` validateCollateralizationPostTransferInPreHook()` to check it using the balance change instead of `_componentQuantity`. :  \n\n```solidity\n  function validateCollateralizationPostTransferInPreHook(\n    ISetToken _setToken,\n    address _component,\n    uint256 _initialSetSupply,\n    uint256 _initialBalance\n  ) internal view {\n    uint256 newComponentBalance = IERC20(_component).balanceOf(address(_setToken));\n    uint256 defaultPositionUnit = _setToken\n      .getDefaultPositionRealUnit(address(_component))\n      .toUint256();\n    // @audit - this not work for fee on transfer\n    require(\n      // Use preciseMulCeil to increase the lower bound and maintain over-collateralization\n      newComponentBalance >=\n        _initialSetSupply.preciseMulCeil(defaultPositionUnit).add(_initialBalance.sub(newComponentBalance)),\n      \"Invalid transfer in. Results in undercollateralization\"\n    );\n  }\n```\n","decidedSeverity":"false","decidedDuplication":"`validateCollateralizationPostTransferInPreHook` could not work with token that have fee on transfer"},{"file":"052.md","watson":{"name":"saidam017","days":26,"is_team":false,"payout":1006,"score":12.5523939942,"senior":false},"severity":"medium","title":"`lever()` and `delever()` of `AaveV3LeverageModule` could revert if used collateral token has blacklist","markdown":"saidam017\n\nmedium\n\n# `lever()` and `delever()` of `AaveV3LeverageModule` could revert if used collateral token has blacklist\n\n## Summary\n\nWhen `lever()` and `delever()` of `AaveV3LeverageModule` called, it will eventually call `_accrueProtocolFee()` to calculate the protocol fee and try to send the fee to the fee recipient. However, If the fee recipient is blocked from the token, the process will revert.\n\n## Vulnerability Detail\n\n`lever()` and `delever()` will call  `_accrueProtocolFee()` : \n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L281\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L342\n\n\n```solidity\n...\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);\n...\n```\n\n`_accrueProtocolFee()` will calculate the fee and call `payProtocolFeeFromSetToken()` to send the fee : \n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L840-L846\n\n```solidity\n    function _accrueProtocolFee(ISetToken _setToken, IERC20 _receiveToken, uint256 _exchangedQuantity) internal returns(uint256) {\n        uint256 protocolFeeTotal = getModuleFee(PROTOCOL_TRADE_FEE_INDEX, _exchangedQuantity);\n\n        payProtocolFeeFromSetToken(_setToken, address(_receiveToken), protocolFeeTotal);\n\n        return protocolFeeTotal;\n    }\n```\n\n`payProtocolFeeFromSetToken()` will be called and try to send the token to fee recipient using `strictInvokeTransfer()` : \n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/lib/ModuleBase.sol#L153-L157\n\n```solidity\n  function payProtocolFeeFromSetToken(\n    ISetToken _setToken,\n    address _token,\n    uint256 _feeQuantity\n  ) internal {\n    if (_feeQuantity > 0) {\n      // @audit - if fee recipient is blocked, this will revert\n      _setToken.strictInvokeTransfer(_token, controller.feeRecipient(), _feeQuantity);\n    }\n  }\n```\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/lib/Invoke.sol#L89-L112\n\n```solidity\n    function strictInvokeTransfer(\n        ISetToken _setToken,\n        address _token,\n        address _to,\n        uint256 _quantity\n    )\n        internal\n    {\n        if (_quantity > 0) {\n            // Retrieve current balance of token for the SetToken\n            uint256 existingBalance = IERC20(_token).balanceOf(address(_setToken));\n\n            Invoke.invokeTransfer(_setToken, _token, _to, _quantity);\n\n            // Get new balance of transferred token for SetToken\n            uint256 newBalance = IERC20(_token).balanceOf(address(_setToken));\n\n            // Verify only the transfer quantity is subtracted\n            require(\n                newBalance == existingBalance.sub(_quantity),\n                \"Invalid post transfer balance\"\n            );\n        }\n    }\n```\n\nThen `invokeTransfer` will be triggered : \n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/lib/Invoke.sol#L66-L78\n\n```solidity\n    function invokeTransfer(\n        ISetToken _setToken,\n        address _token,\n        address _to,\n        uint256 _quantity\n    )\n        internal\n    {\n        if (_quantity > 0) {\n            bytes memory callData = abi.encodeWithSignature(\"transfer(address,uint256)\", _to, _quantity);\n            _setToken.invoke(_token, 0, callData);\n        }\n    }\n```\n\nAnd eventually Set Token will try to `invoke()` this call, but the call will revert : \n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/SetToken.sol#L197-L212\n\n```solidity\n    function invoke(\n        address _target,\n        uint256 _value,\n        bytes calldata _data\n    )\n        external\n        onlyModule\n        whenLockedOnlyLocker\n        returns (bytes memory _returnValue)\n    {\n        _returnValue = _target.functionCallWithValue(_data, _value);\n\n        emit Invoked(_target, _value, _data, _returnValue);\n\n        return _returnValue;\n    }\n```\n\n\n## Impact\n\nIf fee recipient is blocked, any set token in the protocol that used this token can't to `lever()` and `delever()`  process.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L281\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L342\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L840-L846\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/lib/ModuleBase.sol#L153-L157\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider to use pull over push method to manage the protocol fee.","decidedSeverity":"false","decidedDuplication":"`lever()` and `delever()` of `AaveV3LeverageModule` could revert if used collateral token has blacklist"},{"file":"053.md","watson":{"name":"Saeedalipoor01988"},"severity":"high","title":"componentDebt and SetToken are assumed to have the same decimal","markdown":"Saeedalipoor01988\n\nhigh\n\n# componentDebt and SetToken are assumed to have the same decimal\n\n## Summary\ncomponentDebt tokens and SetToken are assumed to have the same decimal.\n\n## Vulnerability Detail\nThe below code is an example of this mistake. componentDebt can be USDT with 6 decimals and _setTokenQuantity is with 18 decimals.\n\n```solidity\n    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {\n        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position\n        // exists the loan would be taken out twice potentially leading to liquidation\n        if (!_isEquity) {\n            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n\n            require(componentDebt < 0, \"CMBN\");\n\n            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);\n            _borrowForHook(_setToken, _component, notionalDebt);\n        }\n    }\n```\nAnother example is when AaveV3LeverageModule calculate fee and pays protocol fee from SetToken (18 decimals). feePercentage  with 16 decimals, _quantity ([different USDT balance for AaveV3LeverageModule](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L827)) with 6 decimals. getModuleFee function should return fee in 18 decimals to pays protocol fee from SetToken.\n\n```solidity\n    /**\n     * Gets the total fee for this module of the passed in index (fee % * quantity)\n     */\n    function getModuleFee(uint256 _feeIndex, uint256 _quantity) internal view returns(uint256) {\n        uint256 feePercentage = controller.getModuleFee(address(this), _feeIndex);\n        return _quantity.preciseMul(feePercentage);\n    }\n```\n\n```solidity\n    // Mapping of modules to fee types to fee percentage. A module can have multiple feeTypes\n    // Fee is denominated in precise unit percentages (100% = 1e18, 1% = 1e16)\n    mapping(address => mapping(uint256 => uint256)) public fees;\n```\n\npreciseMul, **PRECISE_UNIT = 10 ** 18** :\n\n```solidity\n    function preciseMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a.mul(b).div(PRECISE_UNIT);\n    }\n```\n\n## Impact\nThe assumption would lead to incorrect accounting and potential loss of funds if the 2 tokens did not have the same decimal.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L703\n\n## Tool used\nManual Review\n\n## Recommendation\nmaking sure the 2 tokens share the same decimals before any calculation.","decidedSeverity":"false","decidedDuplication":"componentDebt and SetToken are assumed to have the same decimal"},{"file":"054.md","watson":{"name":"yy","days":3,"is_team":false,"payout":0,"score":0.0011486465,"senior":false},"severity":"high","title":"Lack of access control in `removeModule()`","markdown":"yy\n\nhigh\n\n# Lack of access control in `removeModule()`\n\n## Summary\nThe `removeModule()` in `ClaimModule.sol` marked as external. Everyone could call this function to execute the function and remove modules from the contract.\n\n## Vulnerability Detail\nAnyone could remove modules to cause a major disruption in the protocol's operation.\nLet's say Alice is able to call `removeModule()`,  she may able to stop the protocol's services. \n\n## Impact\nUser may lose funds.\nAll claim settings, adapters, and reward pool entries associated with the caller's ISetToken and msg.sender would be deleted. If unauthorized parties invoke this function, legitimate claim settings and reward pool data could be lost, leading to disruptions in the reward distribution or staking mechanisms.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/ClaimModule.sol#L264\n\n## Tool used\nManual Review\n\n## Recommendation\nOnly allow the contract owner or a governance mechanism to call `removeModule()`","decidedSeverity":"high","decidedDuplication":"Lack of access control in `removeModule()`"},{"file":"055.md","watson":{"name":"0xStalin","days":3,"is_team":false,"payout":1.16,"score":0.1144522012,"senior":false},"severity":"high","title":"Liquidity providers may lose funds when adding liquidity","markdown":"0xStalin\n\nhigh\n\n# Liquidity providers may lose funds when adding liquidity\n\n## Summary\nWhen adding liquidity there is no protection to prevent that users receive a non-optimal amount of tokens which will end up creating an excess of tokens that won't be redeemable for the amount of LP tokens minted.\n\n## Vulnerability Detail\nOne of the functionalities in the `AmmModule` contract is to [`addLiquidity()`](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AmmModule.sol#L97-L140) to an AMM pool for a specified AMM.\nWhen adding liquidity to existing Liquidity Pools, all liquidity providers must provide liquidity proportionally to current pool reserves. \nSince a pool is made of two tokens and liquidity is provided in both tokens, there's a possibility for a discrepancy: token amounts may be provided in different proportions. When this happens, [the smaller of the proportions is chosen to calculate the amount of LP tokens minted](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/integration/amm/UniswapV2AmmAdapter.sol#L108-L111)\n```solidity\nuint256 liquidityExpectedFromSuppliedTokens = Math.min(\n    maxTokensIn[0].mul(totalSupply).div(reserveA),\n    maxTokensIn[1].mul(totalSupply).div(reserveB)\n);\n```\nAs a result, the difference in proportions will create an excess of tokens that won't be redeemable for the amount of LP tokens minted. The excess of tokens gets, basically, donated to the pool: it'll be shared among all liquidity providers of the pool.\nWhile the `_minPoolTokenPositionUnit` argument of the [`addLiquidity()` function](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AmmModule.sol#L112) allows liquidity providers to set the minimal amount of LP tokens they want to receive, it doesn't allow them to minimize the disproportion of token amounts or avoid it at all.\n\n\n## Impact\nLiquidity providers may lose a portion of provided liquidity. While the [`_minPoolTokenPositionUnit`](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AmmModule.sol#L112) protects from slippage when adding liquidity, it doesn't protect from providing liquidity at different K. (x * y = K)\n\n## Code Snippet\n- [addLiquidity()](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AmmModule.sol#L108-L140)\n- [_executeAddLiquidity()](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AmmModule.sol#L430-L444)\n- [getProviderLiquidityCalldata()](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/integration/amm/UniswapV2AmmAdapter.sol#L64-L140)\n\n## Tool used\nManual Review\n\n## Recommendation\n- At some point in the addLiquidity flow, consider calculating optimal token amounts based on the amounts specified by user, current pool reserves, and the minimal LP tokens amount specified by user, and make sure to validate if the `optimalAmount is >= minPoolTokenPositionUnit`. As a reference, consider this code from the Uniswap V2 Router: [UniswapV2Router02.sol#L45-L60](https://github.com/Uniswap/v2-periphery/blob/master/contracts/UniswapV2Router02.sol#L45-L60).","decidedSeverity":"false","decidedDuplication":"Liquidity providers may lose funds when adding liquidity"},{"file":"056.md","watson":{"name":"Bauer","days":121,"is_team":false,"payout":12011.73,"score":21.4221078132,"senior":false},"severity":"medium","title":"call() should be used instead of transfer() on an address payable","markdown":"Bauer\n\nmedium\n\n# call() should be used instead of transfer() on an address payable\n\n## Summary\nUse call() instead of transfer()\n\n## Vulnerability Detail\nThe transfer() and send() functions forward a fixed amount of 2300 gas. Historically, it has often been recommended to use these functions for value transfers to guard against reentrancy attacks. However, the gas cost of EVM instructions may change significantly during hard forks which may break already deployed contract systems that make fixed assumptions about gas costs. For example. EIP 1884 broke several existing smart contracts due to a cost increase of the SLOAD instruction.\n\n## Impact\nThe use of the deprecated transfer() function for an address will inevitably make the transaction fail when:\n\nThe claimer smart contract does not implement a payable function.\nThe claimer smart contract does implement a payable fallback which uses more than 2300 gas unit.\nThe claimer smart contract implements a payable fallback function that needs less than 2300 gas units but is called through proxy, raising the call's gas usage above 2300.\nAdditionally, using higher than 2300 gas might be mandatory for some multisig wallets.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L584\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1221\n## Tool used\n\nManual Review\n\n## Recommendation\nUse call() instead of transfer()","decidedSeverity":"false","decidedDuplication":"call() should be used instead of transfer() on an address payable"},{"file":"057.md","watson":{"name":"Bauer","days":121,"is_team":false,"payout":12011.73,"score":21.4221078132,"senior":false},"severity":"high","title":"Dos attack to engage()","markdown":"Bauer\n\nhigh\n\n# Dos attack to engage()\n\n## Summary\nBy monitoring the transaction pool and transferring a negligible amount (1 wei) of the borrow asset into the contract beforehand, the malicious actor can cause the engage() function to fail at the require statement that checks for a zero borrow balance. Consequently, this disruption prevents the intended transaction from taking place, undermining the normal operation of the contract and potentially exposing it to exploitation.\n\n## Vulnerability Detail\nThe `engage()` function performs several validations, calculates rebalance notional amounts, executes leverage trading, and updates the rebalance state.The borrow balance represent the amounts of borrow asset held by the \"setToken\" contract. As the code below,it requires that the borrow balance is zero.   Here is the problem,a bad actor can monitor the transactions in the pool and preemptively transfer a minimal amount (1 wei) of the borrow asset into the contract. When the engage() function is executed, the require statement require(engageInfo.borrowBalance == 0, \"Debt must be 0\"); will fail because the borrow balance is not zero, even though the actor's transfer is negligible.\n```solidity\n    function engage(string memory _exchangeName) external onlyOperator {\n        ActionInfo memory engageInfo = _createActionInfo();\n\n        require(engageInfo.setTotalSupply > 0, \"SetToken must have > 0 supply\");\n        require(engageInfo.collateralBalance > 0, \"Collateral balance must be > 0\");\n        require(engageInfo.borrowBalance == 0, \"Debt must be 0\");\n```\n\n## Impact\nAs a result, this failure in the require statement prevents the transaction from proceeding, effectively blocking the engage() function from executing and disrupting the intended behavior of the contract.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L261\n## Tool used\n\nManual Review\n\n## Recommendation\n","decidedSeverity":"false","decidedDuplication":"Dos attack to engage()"},{"file":"058.md","watson":{"name":"Bauer","days":121,"is_team":false,"payout":12011.73,"score":21.4221078132,"senior":false},"severity":"high","title":"Precision loss to totalRebalanceNotional in AaveLeverageStrategyExtension._calculateChunkRebalanceNotional()","markdown":"Bauer\n\nhigh\n\n# Precision loss to totalRebalanceNotional in AaveLeverageStrategyExtension._calculateChunkRebalanceNotional()\n\n## Summary\nPrecision loss to totalRebalanceNotional \n## Vulnerability Detail\nExamine AaveLeverageStrategyExtension._calculateChunkRebalanceNotional() [L1068](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1068):\n```solidity\n        uint256 totalRebalanceNotional = leverageRatioDifference.preciseDiv(_leverageInfo.currentLeverageRatio).preciseMul(_leverageInfo.action.collateralBalance);\n\n```\nHere  has had a division performed then gets multiplied again, resulting in an unnecessary loss of precision due to [Division Before Multiplication](https://dacian.me/precision-loss-errors#heading-division-before-multiplication).\n\n## Impact\nLoss of precision to totalRebalanceNotional \n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L106\n## Tool used\n\nManual Review\n\n## Recommendation\n","decidedSeverity":"medium","decidedDuplication":"division before multiplication may result in truncation of result"},{"file":"059.md","watson":{"name":"shogoki","days":3,"is_team":false,"payout":409.37,"score":41.5791826772,"senior":false},"severity":"medium","title":"AAVEv3 deposits will stop working at some point because deprecated function is used.","markdown":"shogoki\n\nmedium\n\n# AAVEv3 deposits will stop working at some point because deprecated function is used.\n\n## Summary\n\nIn the `AAVEv3` library there is a function `getDepositCalldata` to get the calldata for a deposit call. However, there is the  signature of the `deposit` function used, which was deprecated and might be removed by the Aaave team.\n\n## Vulnerability Detail\n\nTo deposit/supply assets to AAVeV2 there was a `deposit` function on the main Pool contract. But with AAVEv3 they changed the interface and the function to be used is now called `supply`. \nHowever, the developers seem to have missed this while updating their library for the use with AAVEv3, as the `getDepositCalldata` still encodes a Signature of `deposit`.\nFor now this will still work, as there is a `deposit` function on AAVeV3 pool for backwards compatability. \nBut this function is deprecated and might be removed in the future by the AAVE protocol. \n\n```solidity\n/// @inheritdoc IPool\n/// @dev Deprecated: maintained for compatibility purposes\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external virtual override\n```\n\nhttps://github.com/aave/aave-v3-core/blob/29ff9b9f89af7cd8255231bc5faf26c3ce0fb7ce/contracts/protocol/pool/Pool.sol#L719-L739\n\nIn the [AAVE docs](https://docs.aave.com/developers/core-contracts/pool) there is not even a mention of the `deposit` function anymore.\n\nIf they remove the function  it will result in a revert, when this calldata is actually used in the `SetToken` contract using the `invokeDeposit` function. \n\n## Impact\n\nSetToken´s cannot deposit to AAVE in future as the transaction will always revert.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/integration/lib/AaveV3.sol#L52-L72\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/integration/lib/AaveV3.sol#L100\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse correct Signature for new `supply` function.\n\n```solidity\n bytes memory callData = abi.encodeWithSignature(\n            \"supply(address,uint256,address,uint16)\"\n            _asset, \n            _amountNotional, \n            _onBehalfOf,\n            _referralCode\n        );\n```\n","decidedSeverity":"medium","decidedDuplication":"AaveV3 library uses deprecated deposit function"},{"file":"060.md","watson":{"name":"yy","days":3,"is_team":false,"payout":0,"score":0.0011486465,"senior":false},"severity":"medium","title":"Solidity 0.6.10 version is using in `ClaimModule.sol`, integer overflow or underflow may happen","markdown":"yy\n\nmedium\n\n# Solidity 0.6.10 version is using in `ClaimModule.sol`, integer overflow or underflow may happen\n\n## Summary\nSolidity 0.6.10 version is using in `ClaimModule.sol` which does not imported SafeMath against integer overflow or underflow.\n\n## Vulnerability Detail\nEven through the `AddressArrayUtils` library has been imported, the library does not provide any safeguards against integer overflow or underflow. It is a utility library for manipulating arrays of addresses.\n\nBased on the code e.g `emit RewardClaimed(_setToken, _rewardPool, adapter, finalRewardsBalance.sub(initRewardsBalance));`. There is a calculation, the `sub()` is from AddressArrayUtils which does not provide any safeguards against integer overflow or underflow.\n\n## Impact\nInteger overflow or underflow may happen\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/ClaimModule.sol#L15\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/ClaimModule.sol#L395\n\n## Tool used\nManual Review\n\n## Recommendation\nSuggest to import OpenZeppelin SafeMath library if using Solidity 0.6.x","decidedSeverity":"false","decidedDuplication":"Solidity 0.6.10 version is using in `ClaimModule.sol`, integer overflow or underflow may happen"},{"file":"061.md","watson":{"name":"0xStalin","days":3,"is_team":false,"payout":1.16,"score":0.1144522012,"senior":false},"severity":"medium","title":"All functions that uses the transferFrom() of the ExplicitERC20 library will fail if the token to be transfered is a fee-on-transfer token","markdown":"0xStalin\n\nmedium\n\n# All functions that uses the transferFrom() of the ExplicitERC20 library will fail if the token to be transfered is a fee-on-transfer token\n\n## Summary\nAll erc20 tokens that charge fees on transfer will revert because the strictly equal comparisson to validate if the exact amount of specified quantity was transferred without considering the fees\n\n## Vulnerability Detail\nThe implementation of the `transferFrom()` in the `ExplicitERC20` library uses a [strict equal check operator to validate that the `post-transferFrom balance is exactly equal to the pre-transferFrom balance + the amount of tokens that were requested to be transferred`](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/lib/ExplicitERC20.sol#L65-L68), the issue is if the token charges fees on the transfer, the actual received amount will be slightly less than what was requested, thus, [the strict equal check will fail, and the whole tx will be reverted](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/lib/ExplicitERC20.sol#L65-L68)\n\n- [Checkout this doc for further reference about fee-on-transfer tokens](https://github.com/d-xo/weird-erc20#fee-on-transfer)\n\n## Impact\nAll erc20 tokens that charge fees on transfer will revert because the strictly equal comparisson to validate if the exact amount of specified quantity was transferred without considering the fees\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/lib/ExplicitERC20.sol#L43-L70\n\n## Tool used\nManual Review\n\n## Recommendation\nInstead of using the current check, update it to validate that the post-transferFrom balance is greater than the pre-transferFrom balance, in this way, if the erc20 charged fees, the tx won't revert\n```solidity\nfunction transferFrom(\n    IERC20 _token,\n    address _from,\n    address _to,\n    uint256 _quantity\n)\n    internal\n{\n    \n    if (_quantity > 0) {\n        uint256 existingBalance = _token.balanceOf(_to);\n\n        SafeERC20.safeTransferFrom(\n            _token,\n            _from,\n            _to,\n            _quantity\n        );\n\n        uint256 newBalance = _token.balanceOf(_to);\n\n        // Verify transfer quantity is reflected in balance\n        require(\n-           newBalance == existingBalance.add(_quantity),\n+           newBalance > existingBalance,\n            \"Invalid post transfer balance\"\n        );\n    }\n}\n);\n```","decidedSeverity":"medium","decidedDuplication":"Protocol will not work with fee on transfer tokens"},{"file":"062.md","watson":{"name":"0xStalin","days":3,"is_team":false,"payout":1.16,"score":0.1144522012,"senior":false},"severity":"medium","title":"Can't disengage strategies if the collateral's pool has not enough liquidity","markdown":"0xStalin\n\nmedium\n\n# Can't disengage strategies if the collateral's pool has not enough liquidity\n\n## Summary\nA malicious third party could cause a DoS to disengage strategies and decrease the leverage or close the position on Aave by forcing no liquidity on the pool by frontrunning tx to disengage and [borrowing the entire pool reserves](https://medium.com/aave/understanding-the-risks-of-aave-43334dbfc6d0#:~:text=This%20situation%20can%20be%20problematic%20if%20depositors%20wish%20to%20withdraw%20their%20liquidity%2C%20but%20no%20funds%20are%20available.)\n\n## Vulnerability Detail\n- The logic to disengage strategies and repay the loans is to [withdraw() the collateral from Aave](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveLeverageModule.sol#L338), and then exchange it for the repayAsset and then repay the debt.\n\n- **AAVE, by design, will lend out all of its reserves, meaning that the amount lent out should not be assumed as liquid.**\n\n- The problem is that an attacker can deny this operation [by borrowing all reserves from AAVE](https://medium.com/aave/understanding-the-risks-of-aave-43334dbfc6d0#:~:text=This%20situation%20can%20be%20problematic%20if%20depositors%20wish%20to%20withdraw%20their%20liquidity%2C%20but%20no%20funds%20are%20available.).\n- By borrowing all the reserves from Aave, the withdrawal will fail and the tx to disengage the strategy will be reverted\n  - **In a market turndown this can quickly turn open strategies to go below their Liquidation Threshold and cause them to be liquidated on Aave.**\n  - The attacker can be incentivized to cause the DoS to cause the strategies to be liquidated on Aave, which will end up making the attacker gain all the collateral of these opened strategies and causing the protocol to accrue losses because strategies were not able to be disengaged\n    - The attack can be performed maliciously without the need for a front-run, a sandwich (front-run + back-run) will just make it less costly (less interest paid) for the attacker.\n\n## Impact\nBy causing a DoS to disengage strategies if the collateral's pool has not had enough liquidity, which could end up causing the positions to be liquidated on Aave\n\n## Code Snippet\n- [AaveLeverageStrategyExtension:disengage()](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L412-L438)\n- [AaveLeverageModule:delever()](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveLeverageModule.sol#LL338C7-L338C7)\n- [AaveLeverageModule:deleverToZeroBorrowBalance()](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveLeverageModule.sol#L407)\n\n## Tool used\nManual Review\n\n## Recommendation\n- Think about adding a safeguard path in case the pool has no liquidity. Instead of making the disengage() revert if there is no liquidity, force it to follow the safeguard path.\n- The safeguard path could implement a functionality to allow the caller to transfer the amount of tokens required to disengage the strategy, by allowing the caller to transfer the required tokens to repay the debt, the fact that the pool has no liquidity won't prevent the disengage tx to be executed, which will end up reducing the probabilities of an attacker to forcing the pool running out of liquidity.","decidedSeverity":"false","decidedDuplication":"Can't disengage strategies if the collateral's pool has not enough liquidity"},{"file":"063.md","watson":{"name":"0xStalin","days":3,"is_team":false,"payout":1.16,"score":0.1144522012,"senior":false},"severity":"medium","title":"Removing an enabled borrow asset can be denied","markdown":"0xStalin\n\nmedium\n\n# Removing an enabled borrow asset can be denied\n\n## Summary\nA malicious user can front-run the tx and send as little as 1 wei of the borrowAsset into the setToken contract, which will make the [check](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveLeverageModule.sol#L630) to revert, which will cause the removal of the borrowed asset impossible as long as the malicious user continues to front-run the tx to remove the borrowedAsset\n\n## Vulnerability Detail\n-  Even though the administrators send a tx to repay the leftover debt before sending the tx to remove the enabled borrowed asset, the malicious user can order the tx so when the tx to remove the borrowed asset is executed, the leftover debt is != 0\n- A malicious user can front-run the tx and send as little as 1 wei of the borrowAsset into the setToken contract, which will make the [check](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveLeverageModule.sol#L630) to revert, which will cause the removal of the borrowed asset impossible as long as the malicious user continues to front-run the tx to remove the borrowedAsset\n\n## Impact\nA malicious user can front-run the tx and send as little as 1 wei of the borrowAsset into the setToken contract, which will cause the removal of the borrowed asset to fail\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveLeverageModule.sol#L624-L636\n\n## Tool used\nManual Review\n\n## Recommendation\nThe recommendation is to make sure the [`removeBorrowAssets()`](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveLeverageModule.sol#L624-L636)  is capable of repaying any leftover debt (if there is any), instead of assuming that the remaining debt is 0.","decidedSeverity":"false","decidedDuplication":"Removing an enabled borrow asset can be denied"},{"file":"064.md","watson":{"name":"0xStalin","days":3,"is_team":false,"payout":1.16,"score":0.1144522012,"senior":false},"severity":"medium","title":"Anybody can create new setTokens which could cause a DoS when enough setTokens have been added to the controller.sets[] array","markdown":"0xStalin\n\nmedium\n\n# Anybody can create new setTokens which could cause a DoS when enough setTokens have been added to the controller.sets[] array\n\n## Summary\nAnybody can create new setTokens which could cause a DoS when enough setTokens have been added to the [controller.sets[] array](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/Controller.sol#L66-L67)\n\n## Vulnerability Detail\n- The creation of real setTokens can be compromised by malicious actors whose intentions are to cause damage to the protocol\n- The cost of causing the DoS will be the same as the cost to revert it. Yes, the protocol can remove the fake setTokens, but the cost of removing the fake setTokens will be similar to the cost of causing the DoS.\n- A malicious third party who might gain some benefit by causing DoS to the protocol might be willing to absorb the costs if the end goal is not directly gaining an economic incentive from the DoS, but any other type of benefit such as causing a bad reputation of the Index protocol.\n\n## Impact\nCausing a DoS on the protocol to add real setTokens.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/SetTokenCreator.sol#L66-L109\n\n## Tool used\nManual Review\n\n## Recommendation\nAdd an  Access Control to limit the creation of new setTokens to only authorized parties","decidedSeverity":"false","decidedDuplication":"Anybody can create new setTokens which could cause a DoS when enough setTokens have been added to the controller.sets[] array"},{"file":"065.md","watson":{"name":"0xStalin","days":3,"is_team":false,"payout":1.16,"score":0.1144522012,"senior":false},"severity":"medium","title":"Functions implementing the `invokeApprove()` of the Invoke Library could revert for non-standard token like USDT","markdown":"0xStalin\n\nmedium\n\n# Functions implementing the `invokeApprove()` of the Invoke Library could revert for non-standard token like USDT\n\n## Summary\nWhen functions implementing the `Invoke.invokeApprove()` attempts to approve non-standard tokens like USDT will revert when a contract or a user tries to approve an allowance when the spender allowance has already been set to a non zero value\n\n## Vulnerability Detail\nWhen functions implementing the `Invoke.invokeApprove()` attempts to approve non-standard tokens like USDT will revert when a contract or a user tries to approve an allowance when the spender allowance has already been set to a non zero value.\n\nIn theory, in most of the functions where the invokeApprove() is implemented, after the transfer is completed, the approval is lowered to 0 again.\n- However, if the approval is not lowered to exactly 0 (due to a rounding error or another unforeseen situation) then all the next approvals will fail (assuming a token like USDT is used), causing all the functions dependant on `invokeTransfer()` to become unnusable.\n\n## Impact\nWhen functions implementing the `Invoke.invokeApprove()` attempts to approve non-standard tokens like USDT will revert when a contract or a user tries to approve an allowance when the spender allowance has already been set to a non zero value\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/lib/Invoke.sol#L46-L56\n\n## Tool used\nManual Review\n\n## Recommendation\n- In addition to the described issue, the code is using the direct `approve()` of the ERC20 token, as per [this blog by OpenZeppellin](https://forum.openzeppelin.com/t/explain-the-practical-use-of-increaseallowance-and-decreaseallowance-functions-on-erc20/15103), the usage of the `approve()` is discouraged, and instead, is recommended to use `increaseAllowance` and `decreaseAllowance`.\n- Adopt a safer approach to cover edge cases such as the abovementioned USDT token and implement a similar solution as the following:\n```solidity\nfunction invokeApprove(\n    ISetToken _setToken,\n    address _token,\n    address _spender,\n    uint256 _quantity\n)\n    internal\n{\n-   bytes memory callData = abi.encodeWithSignature(\"approve(address,uint256)\", _spender, _quantity);\n-   _setToken.invoke(_token, 0, callData);\n\n+   uint256 allowance = _token.allowance(address(this), address(_setToken));\n+   if (allowance > 0) {\n+       _token.safeDecreaseAllowance(address(_setToken), allowance);\n+   }\n+   _token.safeIncreaseAllowance(address(_setToken), amount);\n}\n```","decidedSeverity":"medium","decidedDuplication":"AmmModule will not work with usdt"},{"file":"066.md","watson":{"name":"Bauer","days":121,"is_team":false,"payout":12011.73,"score":21.4221078132,"senior":false},"severity":"high","title":"Precision loss to `_calculateMinRepayUnits()` function","markdown":"Bauer\n\nhigh\n\n# Precision loss to `_calculateMinRepayUnits()` function\n\n## Summary\nPrecision loss to `_calculateMinRepayUnits()` function\n## Vulnerability Detail\nExamine AaveLeverageStrategyExtension._calculateMinRepayUnits() [L1152](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1147-L1152)\nHere has had a division performed then gets multiplied again, resulting in an unnecessary loss of precision due to [Division Before Multiplication](https://dacian.me/precision-loss-errors#heading-division-before-multiplication).\n```solidity\n    function _calculateMinRepayUnits(uint256 _collateralRebalanceUnits, uint256 _slippageTolerance, ActionInfo memory _actionInfo) internal pure returns (uint256) {\n        return _collateralRebalanceUnits\n            .preciseMul(_actionInfo.collateralPrice)\n            .preciseDiv(_actionInfo.borrowPrice)\n            .preciseMul(PreciseUnitMath.preciseUnit().sub(_slippageTolerance));\n    }\n```\n\n## Impact\nPrecision loss to `_calculateMinRepayUnits()` function\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1147-L1152\n\n## Tool used\n\nManual Review\n\n## Recommendation\n","decidedSeverity":"medium","decidedDuplication":"division before multiplication may result in truncation of result"},{"file":"067.md","watson":{"name":"saidam017","days":26,"is_team":false,"payout":1006,"score":12.5523939942,"senior":false},"severity":"high","title":"using `transfer()` for send eth could cause issue","markdown":"saidam017\n\nhigh\n\n# using `transfer()` for send eth could cause issue\n\n## Summary\n\n`AaveLeverageStrategyExtension` contract use `transfer()` for send eth for sending reward. This could cause `ripcord()` call unexpectedly revert.\n\n## Vulnerability Detail\n\nAny smart contract that uses `transfer()`  is taking a hard dependency on gas costs by forwarding a fixed amount of gas: 2300.  Each opcode supported by the EVM has an associated gas cost, If gas costs are subject to change, then smart contracts can’t depend on any particular gas costs (like fixed amount 2300).\n\n## Impact\n\nThis can cause function that depend on this call, could revert\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L583-L585\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1218-L1224\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nswitch to using call() instead : \n\n```solidity\n    function _transferEtherRewardToCaller(uint256 _etherReward) internal returns(uint256) {\n        uint256 etherToTransfer = _etherReward < address(this).balance ? _etherReward : address(this).balance;\n \n        (bool success, ) = msg.sender.call.value(etherToTransfer)(\"\");\n        require(success, \"Transfer failed.\");\n\n        return etherToTransfer;\n    }\n```\n\n```solidity\n    function withdrawEtherBalance() external onlyOperator noRebalanceInProgress {\n        (bool success, ) = msg.sender.call.value(address(this).balance)(\"\");\n        require(success, \"Transfer failed.\");\n    }\n```\n","decidedSeverity":"false","decidedDuplication":"using `transfer()` for send eth could cause issue"},{"file":"068.md","watson":{"name":"saidam017","days":26,"is_team":false,"payout":1006,"score":12.5523939942,"senior":false},"severity":"medium","title":"Chainlink oracle data call in `AaveLeverageStategyExtension` is not validated, could return unwanted price value.","markdown":"saidam017\n\nmedium\n\n# Chainlink oracle data call in `AaveLeverageStategyExtension` is not validated, could return unwanted price value.\n\n## Summary\n\nNecessary sanity checked against Chainlink price feeds data is not performed. The functions rely on this data may not work properly and could result in set token processing wrong value.\n\n## Vulnerability Detail\n\n`AaveLeverageStategyExtension` is calling chainlink price feed's `latestAnswer()` to get the price of the token, besides that this uses Chainlink's deprecated `latestAnswer()` function, this also not done any necessary sanity checked (returned price, timestamp and round completeness) is performed.\n\nAccording to [Chainlink's documentation](https://docs.chain.link/data-feeds/historical-data) :\n\n1. this function does not error if no answer has been reached but returns 0 or outdated stale price.\n2. \"A read can revert if the caller is requesting the details of a round that was invalid or has not yet been answered. If you are deriving a round ID without having observed it before, the round might not be complete. To check the round, validate that the timestamp on that round is not 0.\"\n3. roundId and answeredInRound are also returned. “You can check answeredInRound against the current roundId. If answeredInRound is less than roundId, the answer is being carried over. If answeredInRound is equal to roundId, then the answer is fresh.”\n\n## Impact\n\nIf there is a problem with chainlink (node problem, congestion or attack on system), Not checking the returned price at least greater than 0, or using stale price could make strategy used wrong price value. and due to this price is crucial part on function execution inside aave leverage strategy extension, this could lead to completely break the set token.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L889-L907\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUpdate the code to use recommended `latestRoundData` and also perform these check :\n\n```solidity\n....\n  (uint80 roundId, int256 price, , uint256 updatedAt, uint80 answeredInRound) = strategy.collateralPriceOracle.latestRoundData();\n  require(answeredInRound >= roundId, \"round is stale\");\n  require(updatedAt > 0, \"round is incomplete\");\n  require(price > 0, \"Invalid feed answer\");\n....\n  (uint80 roundId, int256 price, , uint256 updatedAt, uint80 answeredInRound) = strategy.borrowPriceOracle.latestRoundData();\n  require(answeredInRound >= roundId, \"round is stale\");\n  require(updatedAt > 0, \"round is incomplete\");\n  require(price > 0, \"Invalid feed answer\");\n...\n```\n","decidedSeverity":"medium","decidedDuplication":"Chainlink's latestRoundData return stale or incorrect result"},{"file":"069.md","watson":{"name":"Cryptor","days":26,"is_team":false,"payout":47.1,"score":0.864264114,"senior":false},"severity":"false","title":"false","markdown":"Cryptor\n\nfalse\n\n# false\n\n","decidedSeverity":"false","decidedDuplication":"false"},{"file":"070.md","watson":{"name":"MohammedRizwan"},"severity":"medium","title":"call() should be used instead of transfer() on an address payable","markdown":"MohammedRizwan\n\nmedium\n\n# call() should be used instead of transfer() on an address payable\n\n## Summary\ncall() should be used instead of transfer() on an address payable\n\n## Vulnerability Detail\nThe transfer() and send() functions forward a fixed amount of 2300 gas. Historically, it has often been recommended to use these functions for value transfers to guard against reentrancy attacks. However, the gas cost of EVM instructions may change significantly during hard forks which may break already deployed contract systems that make fixed assumptions about gas costs. For example. EIP 1884 broke several existing smart contracts due to a cost increase of the SLOAD instruction.\n\n## Impact\nThe use of the deprecated transfer() function for an address will inevitably make the transaction fail when:\n• The claimer smart contract does not implement a payable function.\n• The claimer smart contract does implement a payable fallback which uses more than 2300 gas unit.\n• The claimer smart contract implements a payable fallback function that needs less than 2300 gas units but is called through proxy, \n   raising the call's gas usage above 2300.\n• Additionally, using higher than 2300 gas might be mandatory for some multisig wallets.\n\n## Code Snippet\nIn AaveLeverageStrategyExtension.sol, withdrawEtherBalance() function is given as below,\n\n```solidity\nFile: contracts/adapters/AaveLeverageStrategyExtension.sol\n\n583    function withdrawEtherBalance() external onlyOperator noRebalanceInProgress {\n584        msg.sender.transfer(address(this).balance);\n585    }\n```\n[Link to code](https://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/adapters/AaveLeverageStrategyExtension.sol#L583-L585)\n\nIn AaveLeverageStrategyExtension.sol, _transferEtherRewardToCaller() function is given as below,\n\n```solidity\nFile: contracts/adapters/AaveLeverageStrategyExtension.sol\n\n    function _transferEtherRewardToCaller(uint256 _etherReward) internal returns(uint256) {\n        uint256 etherToTransfer = _etherReward < address(this).balance ? _etherReward : address(this).balance;\n\n        msg.sender.transfer(etherToTransfer);\n\n        return etherToTransfer;\n    }\n```\n[Link to code](https://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/adapters/AaveLeverageStrategyExtension.sol#L1218-L1224)\n\n\n## Tool used\nManual Review\n\n## Recommendation\nUse call() instead of transfer(), but be sure to respect the Check Effect Interaction(CEI) pattern. \n\nMore info on; https://swcregistry.io/docs/SWC-134\n\nFor example:\n\n```solidity\n\n    function withdrawEtherBalance() external onlyOperator noRebalanceInProgress {\n-        msg.sender.transfer(address(this).balance);\n+       uint256 amount = address(this).balance;\n+       (bool success, ) = msg.sender.call{value:amount}(\"\");\n+        require(success, \"transfer failed\");\n    }\n```","decidedSeverity":"false","decidedDuplication":"call() should be used instead of transfer() on an address payable"},{"file":"071.md","watson":{"name":"rvierdiiev","days":240,"is_team":false,"payout":53245.07,"score":59.5872615419,"senior":false},"severity":"medium","title":"Operator will not be able to call withdrawEtherBalance after disengage call, when twapLeverageRatio is not 0","markdown":"rvierdiiev\n\nmedium\n\n# Operator will not be able to call withdrawEtherBalance after disengage call, when twapLeverageRatio is not 0\n\n## Summary\nIn case if `twapLeverageRatio != 0` and operator will call `disengage` in order to make full deleverage, then after that it will be not possible to withdraw ether from balance using `withdrawEtherBalance` function.\n## Vulnerability Detail\nIn case, when it was not possible to leverage/deleverage to the target level, then target level [is set to the `twapLeverageRatio` variable](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1169-L1171), so later users can continue rebalancing using `iterateRebalance` function. Also `twapLeverageRatio` variable [can be deleted](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1183-L1185) in this function.\n\nIn case when operator wants to repay whole loan to upgrade contract or shut down strategy, then he can call `disengage` function. After that SetToken will not have debt in aave as it will fully repay it in this function.\n\n`AaveLeverageStrategyExtension` is going to contain ether balance, which is used to pay users for rebalancing. Operator can call `withdrawEtherBalance` function in order to withdraw funds. It is possible only when `twapLeverageRatio == 0`, as `noRebalanceInProgress` modifier is used.\n\nSo now i am ready to explain possible problem.\nIn case if `twapLeverageRatio != 0`(active rebalancing) an operator calls `disengage` in order to shut down strategy, then it is not possible for him to call `withdrawEtherBalance` function in order to withdraw ether from extension.\nThe only solution to remove `twapLeverageRatio` is to call `iterateRebalance` function. But it will fail, once whole debt is repaid. Because, [`_getAndValidateLeveragedInfo` function](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L339-L343) requires [that debt is not 0](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L867).\n## Impact\nIt is not possible to withdraw balance from extension contract.\n## Code Snippet\nProvided above\n## Tool used\n\nManual Review\n\n## Recommendation\nMaybe, you need to delete `twapLeverageRatio` when debt is fully repaid.","decidedSeverity":"false","decidedDuplication":"Operator will not be able to call withdrawEtherBalance after disengage call, when twapLeverageRatio is not 0"},{"file":"072.md","watson":{"name":"rvierdiiev","days":240,"is_team":false,"payout":53245.07,"score":59.5872615419,"senior":false},"severity":"medium","title":"AaveV3LeverageStrategyExtension should check that position is not close to liquidation after emode category change","markdown":"rvierdiiev\n\nmedium\n\n# AaveV3LeverageStrategyExtension should check that position is not close to liquidation after emode category change\n\n## Summary\nAaveV3LeverageStrategyExtension should check that position is not close to liquidation after emode category change. In case if category is changed, so LTV has decreased, then position can become close to liquidation which is dangerous.\n## Vulnerability Detail\n`AaveV3LeverageStrategyExtension` allows to provide emode category for the `SetToken`. Currently there is no any check after the change and the call can be done any time by operator.\nemode allows account to have better LTV for specific assets. For example before emode category is swithced on for you, you can have 80% and after that you can get 95% LTV. That actually means that you can borrow much more using same collateral amount.\nWhen you change category, then aave check that account is not liquidatable after the change. But this is not enough, as `AaveV3LeverageStrategyExtension` has such term as `unutilizedLeveragePercentage`, which is the collateral buffer to protect from liqudation in case of price changes.\n\nSo next situation is possible.\nSuppose that emode is switched for some category, so SetToken has 95% LTV for the collateral asset. But current LTV of SetToken is 80%. Then operator calls change emode category to another one, which drops LTV for the collateral asset to 80% now and liquidation threshold is 82%, so changing category is done. The problem now is that position of SetToken is not safe now, as `unutilizedLeveragePercentage` buffer is not checked and in case of collateral/debt token price change, SetToken position can become liquidatable and holders can loose funds.\n## Impact\nSetToken holders can loose funds.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1105\n## Tool used\n\nManual Review\n\n## Recommendation\nI think that check should be done, that after emode category change, LTV is safe and `unutilizedLeveragePercentage` buffer is preserved.","decidedSeverity":"false","decidedDuplication":"AaveV3LeverageStrategyExtension should check that position is not close to liquidation after emode category change"},{"file":"073.md","watson":{"name":"rvierdiiev","days":240,"is_team":false,"payout":53245.07,"score":59.5872615419,"senior":false},"severity":"medium","title":"Users still can call rebalance/iterateRebalance after disengage is called","markdown":"rvierdiiev\n\nmedium\n\n# Users still can call rebalance/iterateRebalance after disengage is called\n\n## Summary\nUsers still can call rebalance/iterateRebalance after disengage that doesn't repaid full debt is called, because it doesn't clear state.\n## Vulnerability Detail\nWhen operator calls `disengage` that means that he wants to shut down strategy an fully repay debt.\nIt's possible that he will not be able to do that [through the one step](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L426-L430). In this case it will be needed to call `disengage` several times.\n\n`disengage` function doesn't make any state changes to the contract. Because of that users are still able to call `rebalance`/`iterateRebalance` function. In case if this rebalancing will be done in lever side, this will not help operator to delever positions.\n\nExample.\n1.`twapLeverageRatio` is not 0, so `iterateRebalance` can be called.\n2.operator calls `disengage`, and does partial delever.\n3.any user calls `iterateRebalance` and make lever again.\n4.as result user can make problems for operator to make full deleverage.\n## Impact\nUsers still allowed to lever position\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L412-L438\n## Tool used\n\nManual Review\n\n## Recommendation\nMaybe there is a need to add some global state variable that pauses users ability to call functions, when `disengage` is called.","decidedSeverity":"false","decidedDuplication":"Users still can call rebalance/iterateRebalance after disengage is called"},{"file":"074.md","watson":{"name":"BAHOZ","days":11,"is_team":false,"payout":767.52,"score":21.3510306557,"senior":false},"severity":"medium","title":"Anybody can launch products on index protocol, breaking trust assumptions","markdown":"BAHOZ\n\nmedium\n\n# Anybody can launch products on index protocol, breaking trust assumptions\n\n## Summary\n\nFactory is not gated and lets anybody to launch new products. This breaks trusts assumptions and Index protocol guarantees.\n\n## Vulnerability Detail\n\nThis quote from Index Protocol docs states that:\n\n> In contrast to Set Protocol v2, Index Protocol is not intended to be a self-service platform for third parties to launch products permissionlessly; rather, it exists to support secure and accessible structured products launched by Index Coop and its partners.\n\nhttps://docs.indexcoop.com/index-coop-community-handbook/protocols/index-protocol\n\nHowever, it can bee seen that this guarantee is not reflected into the contracts. Anybody can call `create()` from SetTokenCreator.sol resulting in creation of a new Set token product with the `manager` of the token being chosen by the caller.\n\nhttps://github.com/IndexCoop/index-protocol/blob/86be7ee76d9a7e4f7e93acfc533216ebef791c89/contracts/protocol/SetTokenCreator.sol#L66\n\n\nFurthermore, it can bee seen that this newly created token gets registered in the controller as a valid Set Token and part of the System.\n\nhttps://github.com/IndexCoop/index-protocol/blob/86be7ee76d9a7e4f7e93acfc533216ebef791c89/contracts/protocol/SetTokenCreator.sol#L104\n\nhttps://github.com/IndexCoop/index-protocol/blob/86be7ee76d9a7e4f7e93acfc533216ebef791c89/contracts/protocol/Controller.sol#L160\n\nhttps://github.com/IndexCoop/index-protocol/blob/86be7ee76d9a7e4f7e93acfc533216ebef791c89/contracts/protocol/Controller.sol#L365\n\nThese issues both invalidate the guaranties made by the index protocol in the official docs and enables scammers to disguise as official system contracts and possibly scam protocol users.\n\nThere is no way to distinguish protocol created- trusted products from third party untrusted products since the contracts store them equally and `isSystemContract()` and `isSet()` returns `true` for both.\n\nAn attacker can create a new SetToken that will be registered in the `controller.sol` as a system contract and a valid set token, then steal investors funds using the unrestricted manager rights. Since the investors are guaranteed that all the products in the protocol are launched by Index Coop and its partners, they may be easily convinced to invest in such malicious tokens.\n\n## Impact\n\nBroken trust assumptions and guarantees may causes malicious products to harm users of the protocol \n\n## Code Snippet\n\nhttps://github.com/IndexCoop/index-protocol/blob/86be7ee76d9a7e4f7e93acfc533216ebef791c89/contracts/protocol/SetTokenCreator.sol#L66\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRequire token creators to be whitelisted by the owner.\n","decidedSeverity":"false","decidedDuplication":"Anybody can launch products on index protocol, breaking trust assumptions"},{"file":"075.md","watson":{"name":"paspe"},"severity":"medium","title":"``` withdrawEtherBalance``` and ```_transferEtherRewardToCaller``` functions lacks payable on msg.sender, causing potential compilation errors when transferring Ether.","markdown":"paspe\n\nmedium\n\n# ``` withdrawEtherBalance``` and ```_transferEtherRewardToCaller``` functions lacks payable on msg.sender, causing potential compilation errors when transferring Ether.\n\n## Summary\nThe ```withdrawEtherBalance``` function in the provided code snippet has a vulnerability where msg.sender is not wrapped with payable, potentially leading to compilation errors when transferring Ether.\n\n## Vulnerability Detail\nThe Solidity compiler enforces strict type-checking and requires an explicit indication of addresses that can receive Ether. By omitting payable when attempting to transfer Ether to msg.sender, the compiler would raise an error similar to: \"TypeError: Member 'transfer' not found or not visible after argument-dependent lookup in the address\".\n\n## Impact\nThe vulnerability results in a compilation error, preventing the successful deployment of the contract. Consequently, there would be no way to withdraw the funds from the contract.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L584\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1221\n\n## Tool used\n\nManual Review\n\n## Recommendation\nTo resolve this issue, it is recommended to wrap msg.sender with payable in the `withdrawEtherBalance` function. This ensures the address can receive Ether and avoids compilation errors during the transfer process.\n","decidedSeverity":"false","decidedDuplication":"``` withdrawEtherBalance``` and ```_transferEtherRewardToCaller``` functions lacks payable on msg.sender, causing potential compilation errors when transferring Ether."},{"file":"076.md","watson":{"name":"rvierdiiev","days":240,"is_team":false,"payout":53245.07,"score":59.5872615419,"senior":false},"severity":"medium","title":"AaveLeverageStrategyExtension._calculateMaxBorrowCollateral function should not use unutilizedLeveragePercentage when delever to 0","markdown":"rvierdiiev\n\nmedium\n\n# AaveLeverageStrategyExtension._calculateMaxBorrowCollateral function should not use unutilizedLeveragePercentage when delever to 0\n\n## Summary\nAaveLeverageStrategyExtensionю_calculateMaxBorrowCollateral function should not use unutilizedLeveragePercentage when delever to 0.\n## Vulnerability Detail\nWhen operator wants to close strategy, then he can call `disengage` function.\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L412-L438\n```solidity\n    function disengage(string memory _exchangeName) external onlyOperator {\n        LeverageInfo memory leverageInfo = _getAndValidateLeveragedInfo(\n            execution.slippageTolerance,\n            exchangeSettings[_exchangeName].twapMaxTradeSize,\n            _exchangeName\n        );\n\n        uint256 newLeverageRatio = PreciseUnitMath.preciseUnit();\n\n        (\n            uint256 chunkRebalanceNotional,\n            uint256 totalRebalanceNotional\n        ) = _calculateChunkRebalanceNotional(leverageInfo, newLeverageRatio, false);\n\n        if (totalRebalanceNotional > chunkRebalanceNotional) {\n            _delever(leverageInfo, chunkRebalanceNotional);\n        } else {\n            _deleverToZeroBorrowBalance(leverageInfo, totalRebalanceNotional);\n        }\n\n        emit Disengaged(\n            leverageInfo.currentLeverageRatio,\n            newLeverageRatio,\n            chunkRebalanceNotional,\n            totalRebalanceNotional\n        );\n    }\n```\n\nAs you can see, this function calculates `chunkRebalanceNotional` and `totalRebalanceNotional` in order to undrstand if it's possible to delever to 0 in one call. In such case `_deleverToZeroBorrowBalance` function will be called. Otherwise operator should call `disengage` another time.\n\n`_calculateChunkRebalanceNotional` function [calls `_calculateMaxBorrowCollateral`](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1070) to find how many collateral asset it can use for one call.\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1095-L1119\n```solidity\n    function _calculateMaxBorrowCollateral(ActionInfo memory _actionInfo, bool _isLever) internal view returns(uint256) {\n        \n        // Retrieve collateral factor and liquidation threshold for the collateral asset in precise units (1e16 = 1%)\n        ( , uint256 maxLtvRaw, uint256 liquidationThresholdRaw, , , , , , ,) = strategy.aaveProtocolDataProvider.getReserveConfigurationData(address(strategy.collateralAsset));\n\n        // Normalize LTV and liquidation threshold to precise units. LTV is measured in 4 decimals in Aave which is why we must multiply by 1e14\n        // for example ETH has an LTV value of 8000 which represents 80%\n        if (_isLever) {\n            uint256 netBorrowLimit = _actionInfo.collateralValue\n                .preciseMul(maxLtvRaw.mul(10 ** 14))\n                .preciseMul(PreciseUnitMath.preciseUnit().sub(execution.unutilizedLeveragePercentage));\n\n            return netBorrowLimit\n                .sub(_actionInfo.borrowValue)\n                .preciseDiv(_actionInfo.collateralPrice);\n        } else {\n            uint256 netRepayLimit = _actionInfo.collateralValue\n                .preciseMul(liquidationThresholdRaw.mul(10 ** 14))\n                .preciseMul(PreciseUnitMath.preciseUnit().sub(execution.unutilizedLeveragePercentage));\n\n            return _actionInfo.collateralBalance\n                .preciseMul(netRepayLimit.sub(_actionInfo.borrowValue))\n                .preciseDiv(netRepayLimit);\n        }\n    }\n```\n\nAs you can see, to find the maximum amount of collateral assets that can be traded to receive repayment token, first `collateralValue` is multiplied by `liquidationThresholdRaw` and then by `unutilizedLeveragePercentage`.\nHowever in case if operator wants to fully delever to 0, then this `unutilizedLeveragePercentage` should not be counted. Because of this buffer, it's possible that operator will not be able to delever to 0 using one call, even when he should be able to do that.\n\nExample:\n1.SetToken has 1000$ collateral and 400$ debt, `unutilizedLeveragePercentage == 10%`, `liquidationThresholdRaw == 85%`.\n2.`netRepayLimit` = 1000*85%*90%=765.\n3.`netRepayLimit.sub(_actionInfo.borrowValue)` = 765-400=365, which is not eniugh to repay 400$ debt\n4.however if you don't use `unutilizedLeveragePercentage` variable here, then `netRepayLimit` = 850 and `netRepayLimit.sub(_actionInfo.borrowValue)` = 850-400=450 and it's enough to delever to 0 in one call.\n## Impact\nOperator needs more time to call delever to 0.\n## Code Snippet\nProvided above\n## Tool used\n\nManual Review\n\n## Recommendation\nIn case of `disengage` you need to calculate if it's possible to delever to 0 for 1 time call. For this calculation you don't need to preserve `unutilizedLeveragePercentage`.","decidedSeverity":"false","decidedDuplication":"AaveLeverageStrategyExtension._calculateMaxBorrowCollateral function should not use unutilizedLeveragePercentage when delever to 0"},{"file":"077.md","watson":{"name":"Saeedalipoor01988"},"severity":"medium","title":"Protocol can't work with AAVE V3 in L2 networks","markdown":"Saeedalipoor01988\n\nmedium\n\n# Protocol can't work with AAVE V3 in L2 networks\n\n## Summary\nDue to the input of functions in the L2Pool.sol smart contract on layer 2 networks, Protocol can't use AAVE V3 in L2 networks.\n\n## Vulnerability Detail\nFor example, let's check the [borrow function from L2Pool.sol in the Arbitrum network](https://github.com/aave/aave-v3-core/blob/29ff9b9f89af7cd8255231bc5faf26c3ce0fb7ce/contracts/protocol/pool/L2Pool.sol#L50), input data for borrow function is bytes32.\n\n```solidity\n  /// @inheritdoc IL2Pool\n  function borrow(bytes32 args) external override {\n    (address asset, uint256 amount, uint256 interestRateMode, uint16 referralCode) = CalldataLogic\n      .decodeBorrowParams(_reservesList, args);\n\n    borrow(asset, amount, interestRateMode, referralCode, msg.sender);\n  }\n```\n\nNow let's check how Index protocol is creating [Borrow Calldata from getBorrowCalldata function](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/integration/lib/AaveV3.sol#L194),  it is using \"borrow(address,uint256,uint256,uint16,address)\" Signature. different from [\"borrow(bytes32)\" signature for L2 network](https://github.com/aave/aave-v3-core/blob/29ff9b9f89af7cd8255231bc5faf26c3ce0fb7ce/contracts/protocol/pool/L2Pool.sol#L50).\n\n```solidity\n    function getBorrowCalldata(\n        IPool _lendingPool,\n        address _asset, \n        uint256 _amountNotional,\n        uint256 _interestRateMode,\n        uint16 _referralCode,\n        address _onBehalfOf\n    )\n        public\n        pure\n        returns (address, uint256, bytes memory)\n    {\n        bytes memory callData = abi.encodeWithSignature(\n            \"borrow(address,uint256,uint256,uint16,address)\", \n            _asset, \n            _amountNotional, \n            _interestRateMode,\n            _referralCode,\n            _onBehalfOf\n        );\n        \n        return (address(_lendingPool), 0, callData);\n    }\n```\nAAVE V3 smart contract is different between chains where the INDEX smart contracts will be deployed.\n\n## Impact\nProtocol can't make interaction with AAVE V3 smart contract deployed in L2 networks.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/integration/lib/AaveV3.sol#L207\nhttps://github.com/aave/aave-v3-core/blob/master/contracts/protocol/pool/L2Pool.sol#L50\nhttps://github.com/aave/aave-v3-core/blob/29ff9b9f89af7cd8255231bc5faf26c3ce0fb7ce/contracts/protocol/pool/Pool.sol#L221\n\n## Tool used\nManual Review\n\n## Recommendation\nChange getBorrowCalldata logic for L2 networks.","decidedSeverity":"false","decidedDuplication":"Protocol can't work with AAVE V3 in L2 networks"},{"file":"078.md","watson":{"name":"jasonxiale","days":32,"is_team":false,"payout":170.12,"score":1.3684321955,"senior":false},"severity":"medium","title":"Deprecated Chainlink oracle API","markdown":"jasonxiale\n\nmedium\n\n# Deprecated Chainlink oracle API\n\n## Summary\nDeprecated Chainlink oracle API. API might stop working. Prices could be outdated. Protocol might need to be redeployed or false prices might lead to users losing funds.\n\n## Vulnerability Detail\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L895-L897\n\n## Impact\n\nThe contracts use Chainlink’s deprecated API latestAnswer(). Such functions might suddenly stop working if Chainlink stopped supporting deprecated APIs.\nAdditionally, one cannot check if the returned price is fresh. The price might by stale (old historical price).\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\nUse the latestRoundData() function to get the price instead.","decidedSeverity":"medium","decidedDuplication":"Deprecated oracle function `latestAnswer()` could bring fund loss"},{"file":"079.md","watson":{"name":"jasonxiale","days":32,"is_team":false,"payout":170.12,"score":1.3684321955,"senior":false},"severity":"medium","title":"Chainlink oracle missing check to see if the L2 sequencer is down","markdown":"jasonxiale\n\nmedium\n\n# Chainlink oracle missing check to see if the L2 sequencer is down\n\n## Summary\nWhen working with chainlink in L2's its important to remember the centralization risk of the sequencer.\n## Vulnerability Detail\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L895C57-L897\n\n## Impact\nIf a sequencer becomes unavailable, it is impossible to access read/write APIs that consumers are using and applications on the L2 network will be down for most users without interacting directly through the L1 optimistic rollup contracts. \n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\nFollow the chainlink docs https://docs.chain.link/data-feeds/l2-sequencer-feeds","decidedSeverity":"medium","decidedDuplication":"Missing checks for whether Arbitrum Sequencer is active"},{"file":"080.md","watson":{"name":"jasonxiale","days":32,"is_team":false,"payout":170.12,"score":1.3684321955,"senior":false},"severity":"medium","title":"Use call() instead of transfer() when transferring ETH","markdown":"jasonxiale\n\nmedium\n\n# Use call() instead of transfer() when transferring ETH\n\n## Summary\ncall() should be used instead of transfer() on an address payable.\n\n## Vulnerability Detail\nThe transfer() and send() functions forward a fixed amount of 2300 gas. Historically, it has often been recommended to use these functions for value transfers to guard against reentrancy attacks. However, the gas cost of EVM instructions may change significantly during hard forks which may break already deployed contract systems that make fixed assumptions about gas costs.\n\n## Impact\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L584\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1221\n\n## Tool used\n\nManual Review\n\n## Recommendation\n","decidedSeverity":"false","decidedDuplication":"Use call() instead of transfer() when transferring ETH"},{"file":"081.md","watson":{"name":"volodya","days":18,"is_team":false,"payout":346.86,"score":12.1469219611,"senior":false},"severity":"high","title":"Side effects of LTV = 0 assets: Index's users will not be able to withdraw (collateral), borrow","markdown":"volodya\n\nhigh\n\n# Side effects of LTV = 0 assets: Index's users will not be able to withdraw (collateral), borrow\n\n## Summary\n[Link to report from spearbit](https://solodit.xyz/issues/16216) \nWhen an AToken has LTV = 0, Aave restricts the usage of some operations. In particular, if the user\nowns at least one AToken as collateral that has LTV = 0, operations could revert.\n1) Withdraw: if the asset withdrawn is collateral, the user is borrowing something, the operation will revert if the\nwithdrawn collateral is an AToken with LTV > 0.\n2) Transfer: if the from is using the asset as collateral, is borrowing something and the asset transferred is an\nAToken with LTV > 0 the operation will revert.\n3) Set the reserve of an AToken as not collateral: if the AToken you are trying to set as non-collateral is an\nAToken with LTV > 0 the operation will revert.\nNote that all those checks are done on top of the \"normal\" checks that would usually prevent an operation, de-\npending on the operation itself \n## Vulnerability Detail\n```solidity\n    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {\n        require(!collateralAssetEnabled[_setToken][_asset], \"Collateral already enabled\");\n\n        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));\n        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, \"Invalid aToken address\");\n\n        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));\n        // An active reserve is an alias for a valid reserve on Aave.\n        // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,\n        // because our mappings can be out-of-date if a new reserve is added to Aave\n        require(isActive, \"IAR\");\n        // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals\n        require(!isFrozen, \"FAR\");\n        require(usageAsCollateralEnabled, \"CNE\");\n    }\n\n```\n[v1/AaveV3LeverageModule.sol#L1101](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L1101)\n## Impact\nThe Index protocol might stop working for users who would use those particular markets.\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\nAdd restriction to those markets and add documentation to restrict those markets\nE.x.\n\n```diff\n    function _validateNewCollateralAsset(ISetToken _setToken, IERC20 _asset) internal view {\n        require(!collateralAssetEnabled[_setToken][_asset], \"Collateral already enabled\");\n\n        (address aToken, , ) = protocolDataProvider.getReserveTokensAddresses(address(_asset));\n        require(address(underlyingToReserveTokens[_asset].aToken) == aToken, \"Invalid aToken address\");\n\n-        ( , , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));\n+        ( , uint256 ltv , , , , bool usageAsCollateralEnabled, , , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));\n\n        // An active reserve is an alias for a valid reserve on Aave.\n        // We are checking for the availability of the reserve directly on Aave rather than checking our internal `underlyingToReserveTokens` mappings,\n        // because our mappings can be out-of-date if a new reserve is added to Aave\n        require(isActive, \"IAR\");\n+      require(ltv != 0, \"ltv should be non zero\");\n\n        // A frozen reserve doesn't allow any new deposit, borrow or rate swap but allows repayments, liquidations and withdrawals\n        require(!isFrozen, \"FAR\");\n        require(usageAsCollateralEnabled, \"CNE\");\n    }\n\n```\n","decidedSeverity":"medium","decidedDuplication":"Side effects of LTV = 0 assets: Index's users will not be able to withdraw (collateral), borrow"},{"file":"082.md","watson":{"name":"Saeedalipoor01988"},"severity":"medium","title":"Index protocol cannot interact with L2 AAVE V3 Pool smart contract","markdown":"Saeedalipoor01988\n\nmedium\n\n# Index protocol cannot interact with L2 AAVE V3 Pool smart contract\n\n## Summary\nIndex protocol cannot interact with L2 AAVE V3 Pool smart contract because Index protocol is using different Signatures for functions.\n\n## Vulnerability Detail\nThe below code is used in [AAVE V3 to deposit assets into the Pool contract](https://github.com/aave/aave-v3-core/blob/29ff9b9f89af7cd8255231bc5faf26c3ce0fb7ce/contracts/protocol/pool/Pool.sol#L145). as you can see this function is \"supply\" with Signature \"supply(address,uint256,address,uint16)\".\n\n```solidity\n  /// @inheritdoc IPool\n  function supply(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) public virtual override {\n    SupplyLogic.executeSupply(\n      _reserves,\n      _reservesList,\n      _usersConfig[onBehalfOf],\n      DataTypes.ExecuteSupplyParams({\n        asset: asset,\n        amount: amount,\n        onBehalfOf: onBehalfOf,\n        referralCode: referralCode\n      })\n    );\n  }\n```\n\nAnd below code is used in the [AaveV3.sol library to create Deposit Calldata](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/integration/lib/AaveV3.sol#L64). As you can see it is using \"deposit(address,uint256,address,uint16)\" Signature.\n\n```solidity\n    function getDepositCalldata(\n        IPool _lendingPool,\n        address _asset, \n        uint256 _amountNotional,\n        address _onBehalfOf,\n        uint16 _referralCode\n    )\n        public\n        pure\n        returns (address, uint256, bytes memory)\n    {\n        bytes memory callData = abi.encodeWithSignature(\n            \"deposit(address,uint256,address,uint16)\", \n            _asset, \n            _amountNotional, \n            _onBehalfOf,\n            _referralCode\n        );\n        \n        return (address(_lendingPool), 0, callData);\n    }\n```\nplease check Borrow, Withdraw, Repay and setUserUseReserveAsCollateral.\n\n## Impact\nIncreases leverage for a given collateral position by [lever function](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L285) will not work.\n\n## Code Snippet\nhttps://github.com/aave/aave-v3-core/blob/29ff9b9f89af7cd8255231bc5faf26c3ce0fb7ce/contracts/protocol/pool/Pool.sol#L145\nhttps://github.com/aave/aave-v3-core/blob/master/contracts/protocol/pool/Pool.sol#L145\n\n## Tool used\nManual Review\n\n## Recommendation\nUse the correct signature.","decidedSeverity":"false","decidedDuplication":"Index protocol cannot interact with L2 AAVE V3 Pool smart contract"},{"file":"083.md","watson":{"name":"shogoki","days":3,"is_team":false,"payout":409.37,"score":41.5791826772,"senior":false},"severity":"medium","title":"Missing Check for eMode side effects in certain functions","markdown":"shogoki\n\nmedium\n\n# Missing Check for eMode side effects in certain functions\n\n## Summary\n\nThe `AaveV3LeverageModule` allows the manager to set an eMode category. However this can lead to various unwanted side effects, which are not checked or accounted for.\n\n## Vulnerability Detail\n\nFrom [AAVE docs](https://docs.aave.com/developers/whats-new/efficiency-mode-emode):\n\n> The protocol allows user to set the user eMode category to any of the eModeCategories configured by the PoolConfigurator given the following conditions holds true:\n>\n> - all the borrowed assets of the user are in the chosen category.\n> - changing eMode doesn’t leave user position under-collateralised\n\nGiven this, it might be a problem, that when activating eMode there is no check, if the SetToken already has borrowed Assets outside the eMode category or is using assets outside the category as collateral. When activating the eMode inside `AaveV3LeverageModule` there is no check to account for that. However, this might not be a big deal as the call to AAVE will revert.\n\nBut there´s more to it. As there is no check for the assets enabled in the module to fit the eMode category, we can imagine that eMode was able to get activated, but in our list of `collateralAssetEnabled` or `borrowAssetEnabled` we still have other assets.\n\nIt is also possible that new assets, which are not compliant with the eMode category, are added after the eMode was already activated, using the `addBorrowAssets` and `addCollateralAssets` functions.\n\nThis will result in future deposits might not counted correctly as collateral, and borrows of these assets to fail.\n\n## Impact\n\n- Deposits might not count as collateral as expected\n- Borrows might fail \n- Misconfiguration of SetToken, because Assets are enabled which are not supported by eMode category.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L566-L568\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L607-L619\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L637-L649\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L987-L998\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L1004-L1014\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChecks should be implemented for the eMode category of the ReserveAssets.\nThe ReserveTokens struct could be extended to hold the category:\n\n```solidity\n struct ReserveTokens {\n        IAToken aToken;                         // Reserve's aToken instance\n        IVariableDebtToken variableDebtToken;   // Reserve's variable debt token instance\n        uint256 eModeCategory;                  // Reserve´s eModeCategory\n    }\n```\n\nand the category be fetched like this:\n\n```solidity\n      IAaveProtocolDataProvider.TokenData[] memory reserveTokens = _protocolDataProvider.getAllReservesTokens();\n        for(uint256 i = 0; i < reserveTokens.length; i++) { \n            (address aToken, , address variableDebtToken) = _protocolDataProvider.getReserveTokensAddresses(reserveTokens[i].tokenAddress);\n            uint256 eModeCategory = _protocolDataProvider.getReserveEModeCategory(reserveTokens[i].tokenAddress);\n            underlyingToReserveTokens[IERC20(reserveTokens[i].tokenAddress)] = ReserveTokens(IAToken(aToken), IVariableDebtToken(variableDebtToken), eModeCategory);\n        }\n```\n\n- When the eMode category will be changed there should be a check if all enabled assets are belonging to the eMode category.\n\n```solidity\n function setEModeCategory(ISetToken _setToken, uint8 _categoryId) external onlyManagerAndValidSet(_setToken) {\n        if(_categoryId > 0) //no check required for 0 category {\n            address[] memory _collAssets = enabledAssets[_setToken].collateralAssets;\n            for(uint i= 0; i < _collAssets.length; i++) {\n                require(underlyingToReserveTokens[IERC20(_collAssets[i])].eModeCategory == _categoryId, \"Unsupported Category Id\");\n            } \n            address[] memory _borrowAssets = enabledAssets[_setToken].borrowAssets;\n            for(uint i= 0; i < _borrowAssets.length; i++) {\n                require(underlyingToReserveTokens[IERC20(_borrowAssets[i])].eModeCategory == _categoryId, \"Unsupported Category Id\");\n            } \n        }\n        _setToken.invokeSetUserEMode(IPool(lendingPoolAddressesProvider.getPool()), _categoryId);\n    }\n``` \n\n- When new assets will be added, there should be check that they belong to the currently set eMode category.\n","decidedSeverity":"false","decidedDuplication":"Missing Check for eMode side effects in certain functions"},{"file":"084.md","watson":{"name":"MohammedRizwan"},"severity":"medium","title":"onlyEOA modifier that ensures call is from EOA address might not hold true in the future(EIP 3074)","markdown":"MohammedRizwan\n\nmedium\n\n# onlyEOA modifier that ensures call is from EOA address might not hold true in the future(EIP 3074)\n\n## Summary\nmodifier onlyEOA is used to ensure calls are only made from EOA. However, EIP 3074 suggests that using onlyEOA modifier to ensure calls are only from Externally owned Account(EOA) address might not hold true.\n\n## Vulnerability Detail\nFor onlyEOA, tx.origin is used to ensure that the caller is from an EOA and not a smart contract.\n\nIn BaseExtension.sol, onlyEOA() modifier is given as below,\n\n```solidity\nFile: contracts/lib/BaseExtension.sol\n\n59    modifier onlyEOA() {\n60        require(msg.sender == tx.origin, \"Caller must be EOA Address\");\n61        _;\n62    }\n```\n[Link to code](https://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/lib/BaseExtension.sol#L59-L62)\n\nHowever, according to [EIP 3074](https://eips.ethereum.org/EIPS/eip-3074#abstract),\n\nThis EIP introduces two EVM instructions AUTH and AUTHCALL. The first sets a context variable authorized based on an ECDSA signature. The second sends a call as the authorized account. This essentially delegates control of the externally owned account (EOA) to a smart contract.\n\nTherefore, using tx.origin to ensure msg.sender is an EOA will not hold true in the event EIP 3074 goes through.\n\n## Impact\nUsing modifier onlyEOA to ensure calls are made only from EOA will not hold true in the event EIP 3074 goes through.\n\n## Code Snippet\nFollowing smart contract functions are using onlyEOA modifier,\n\nIn AaveLeverageStrategyExtension.sol contract, rebalance() function is given as shown  below,\n\n```solidity\nFile:  contracts/adapters/AaveLeverageStrategyExtension.sol\n\n304     function rebalance(string memory _exchangeName) external onlyEOA onlyAllowedCaller(msg.sender) {\n```\n[Link to code](https://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/adapters/AaveLeverageStrategyExtension.sol#L304-L309)\n\nIn AaveLeverageStrategyExtension.sol contract, iterateRebalance() function is given as shown  below,\n\n```solidity\nFile:  contracts/adapters/AaveLeverageStrategyExtension.sol\n\n338    function iterateRebalance(string memory _exchangeName) external onlyEOA onlyAllowedCaller(msg.sender) {\n```\n[Link to code](https://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/adapters/AaveLeverageStrategyExtension.sol#L338-L343)\n\nIn AaveLeverageStrategyExtension.sol contract, ripcord() function is given as shown  below,\n\n```solidity\nFile:  contracts/adapters/AaveLeverageStrategyExtension.sol\n\n376    function ripcord(string memory _exchangeName) external onlyEOA {\n```\n[Link to code](https://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/adapters/AaveLeverageStrategyExtension.sol#L376-L381)\n\nReference link for similar finding in Blueberry audit at Sherlock- https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/21\n\n## Tool used\nManual Review\n\n## Recommendation\n\nRecommend using OpenZeppelin’s isContract function\n\n\n[Link to isContract function code](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/5420879d9b834a0579423d668fb60c5fc13b60cc/contracts/utils/Address.sol#L40-L46)\n\n[Link to openzeppelin doc reference](https://docs.openzeppelin.com/contracts/2.x/api/utils#Address-isContractaddress-)\n\n\n\n\n*Note that there are edge cases like contract in constructor that can bypass this and hence caution is required when using this. *\n\nFor example:\n\n```solidity\n\n+   error NOT_EOA(address from);\n\n    modifier onlyEOA() {\n-        require(msg.sender == tx.origin, \"Caller must be EOA Address\");\n+               if (isContract(msg.sender))\n+                revert NOT_EOA(msg.sender);\n        _;\n    }\n```","decidedSeverity":"medium","decidedDuplication":"onlyEOA modifier that ensures call is from EOA might not hold true with the eip 3074"},{"file":"085.md","watson":{"name":"MohammedRizwan"},"severity":"medium","title":"Using deprecated Chainlink function latestAnswer()","markdown":"MohammedRizwan\n\nmedium\n\n# Using deprecated Chainlink function latestAnswer()\n\n## Summary\nUse of deprecated Chainlink oracle aggregator function latestAnswer()\n\n## Vulnerability Detail\n## Impact\nAccording to Chainlink's documentation, the latestAnswer() function is deprecated. This function does not error if no answer has been reached but returns 0.\n\n[Link to chainlink reference](https://docs.chain.link/data-feeds/api-reference#latestanswer) where it says \"THIS FUNCTION IS DEPRECATED. DO NOT USE THIS FUNCTION.\"\n\nlatestAnswer( ) function is not present in the latest API reference [latest API reference](https://docs.chain.link/data-feeds/api-reference)\n\nAlso AggregatorV3Interface does not have latestAnswer() function , [Link to reference ](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol)\n\n## Code Snippet\n\nFollowing smart contract function uses latestAnswer(), \n\nIn AaveLeverageStrategyExtension.sol contract, _createActionInfo() function is given by,\n\n```solidity\nFile: contracts/adapters/AaveLeverageStrategyExtension.sol\n\n895        int256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\n\n897        int256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer();\n```\n[Link to code ](https://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/adapters/AaveLeverageStrategyExtension.sol#L895-L897)\n\nReference link for similar issue in JPEG'd audit at Code4rena- https://github.com/code-423n4/2022-04-jpegd-findings/issues/34\n\n## Tool used\nManual Review\n\n## Recommendation\n\nUse the [latestRoundData()](https://docs.chain.link/data-feeds/api-reference#latestrounddata-1) function to get the price instead of deprecated latestAnswer(). \n\nAdd checks on the return data with proper revert messages if the price is stale or the round is incomplete. \n\nFor example:\n\n```solidity\n\n(uint80 roundID, int256 price, , uint256 timeStamp, uint80 answeredInRound) = oracle.latestRoundData();\nrequire(answeredInRound >= roundID, \"stale data\");\nrequire(timeStamp != 0, \"round is not complete\");\nrequire(price != 0, \"Chainlink Malfunction”);\n```","decidedSeverity":"medium","decidedDuplication":"Deprecated oracle function `latestAnswer()` could bring fund loss"},{"file":"086.md","watson":{"name":"0x8chars"},"severity":"medium","title":"Chainlink’s latestAnswer() is deprecated","markdown":"0x8chars\n\nmedium\n\n# Chainlink’s latestAnswer() is deprecated\n\n## Summary\nThe use of chainlink's `latestAnswer()` is deprecated.\n\n## Vulnerability Detail\nThe `latestAnswer()` function returns 0 instead of erroring out if no answers can be reached. This will return the wrong prices for the underlying collateral and borrow tokens.\n\n## Impact\nWhen calling the function `_createActionInfo()`, the collateral and borrow values will have a value of 0 if their price is 0 (if no answers can be reached). This will lead to `_calculateMaxBorrowCollateral()` reverting because of the division by zero error. As such, functions like `disengage()` or `ripcord()` cannot be called.\n\n## Code Snippet\n- https://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/adapters/AaveLeverageStrategyExtension.sol#L895\n- https://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/adapters/AaveLeverageStrategyExtension.sol#L897\n\n## Tool used\nManual Review\n[comment in the aggregator contract](https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.7/dev/AggregatorProxy.sol#L33-L43)\n\n## Recommendation\nUse `latestRoundData()` as per their [documentation](https://docs.chain.link/getting-started/consuming-data-feeds#examine-the-sample-contract) and add an additional sanity check to ensure that prices are not stale (old round). For example\n```solidity\n(uint80 roundID, int256 price, , uint256 timeStamp, uint80 answeredInRound) = oracle.latestRoundData();\nrequire(answeredInRound >= roundID, \"...\");\nrequire(timeStamp != 0, \"...\");\n```","decidedSeverity":"medium","decidedDuplication":"Deprecated oracle function `latestAnswer()` could bring fund loss"},{"file":"087.md","watson":{"name":"saidam017","days":26,"is_team":false,"payout":1006,"score":12.5523939942,"senior":false},"severity":"medium","title":"`deleverToZeroBorrowBalance()` prone to sandwich attack in case of low debt to repay","markdown":"saidam017\n\nmedium\n\n# `deleverToZeroBorrowBalance()` prone to sandwich attack in case of low debt to repay\n\n## Summary\n\n`AaveV3LeverageModule` 's`deleverToZeroBorrowBalance()` is used to pays down the borrow asset to 0 selling off a given amount of collateral asset. However, incase of low debt to repay, this execution prone to sandwich attack when executing trade from collateral asset to repay asset.\n\n## Vulnerability Detail\n\n`deleverToZeroBorrowBalance()` will first withdraw the provided collateral amount from calculated from `_redeemQuantityUnits` calldata. Then trade it to repay asset, but incase of low debt left calculated from here :\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L393\n\n```solidity\n        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));\n```\n\nThe executed trade not limit and check the `notionalRedeemQuantity` that will be traded, so attacker can see this call, and if this favorable for him, he can sandwich this `deleverToZeroBorrowBalance()` call.\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L409\n\n```solidity\n        // @audit - this trade is prone to sandwich attack, due to no control of slippage between notionalRedeemQuantity and notionalRepayQuantity\n        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n```\n\nthis trade inside delever to zero process is prone to sandwich attack, due to no control of slippage between `notionalRedeemQuantity` and `notionalRepayQuantity`\n\n\n## Impact\n\nWhile the extension contract do have mechanism to send `_redeemQuantityUnits` only to match the leverage equal to 1, so it will protect from sandwich attack. \n\nBUT this module is not exclusively enforced to work only with the Aave leverage strategy extension, any EOA manager that use this module can suffer sandwich attack due to lack of slippage  protection inside module.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L376-L426\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nMove the necessary `_redeemQuantityUnits` proper calculation from extension to this module, so the slippage protection is on module level.\n","decidedSeverity":"false","decidedDuplication":"`deleverToZeroBorrowBalance()` prone to sandwich attack in case of low debt to repay"},{"file":"088.md","watson":{"name":"volodya","days":18,"is_team":false,"payout":346.86,"score":12.1469219611,"senior":false},"severity":"high","title":"whole AaveLeverageStrategyExtension might not work properly, external contracts and keeper bots will not be able to integrate with Index protocol properly due to not taking into account aave v3 borrow caps","markdown":"volodya\n\nhigh\n\n# whole AaveLeverageStrategyExtension might not work properly, external contracts and keeper bots will not be able to integrate with Index protocol properly due to not taking into account aave v3 borrow caps\n\n## Summary\nExternal contracts and keeper bots will not be able to integrate with Index protocol properly due to not taking into account aave v3 borrow caps and whole AaveLeverageStrategyExtension will not work properly due to max borrow not calculating correctly\n## Vulnerability Detail\nThere is a function called getChunkRebalanceNotional that external protocols will be using to integrate with Index.\n```solidity\n\n    /**\n     * Calculates the chunk rebalance size. This can be used by external contracts and keeper bots to calculate the optimal exchange to rebalance with.\n     * Note: this function does not take into account timestamps, so it may return a nonzero value even when shouldRebalance would return ShouldRebalance.NONE for\n     * all exchanges (since minimum delays have not elapsed)\n     *\n     * @param _exchangeNames    Array of exchange names to get rebalance sizes for\n     *\n     * @return sizes            Array of total notional chunk size. Measured in the asset that would be sold\n     * @return sellAsset        Asset that would be sold during a rebalance\n     * @return buyAsset         Asset that would be purchased during a rebalance\n     */\n    function getChunkRebalanceNotional(\n        string[] calldata _exchangeNames\n    )\n        external\n        view\n        returns(uint256[] memory sizes, address sellAsset, address buyAsset)\n    {\n...\n    }\n```\n[adapters/AaveLeverageStrategyExtension.sol#L614](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L614)\n\nThat function is using another function to get max borrow from aave which doesn't take into account [borrow caps](https://docs.aave.com/developers/whats-new/supply-borrow-caps) which have been introduced in aave  v3. E.x. dai has a borrow cap of 16000000 on [optimism pool](https://optimistic.etherscan.io/token/0xda10009cbd5d07dd0cecc66161fc93d7c9000da1)\n\n```solidity\n    function _calculateMaxBorrowCollateral(ActionInfo memory _actionInfo, bool _isLever) internal view returns(uint256) {\n        \n        // Retrieve collateral factor and liquidation threshold for the collateral asset in precise units (1e16 = 1%)\n        ( , uint256 maxLtvRaw, uint256 liquidationThresholdRaw, , , , , , ,) = strategy.aaveProtocolDataProvider.getReserveConfigurationData(address(strategy.collateralAsset));\n\n        // Normalize LTV and liquidation threshold to precise units. LTV is measured in 4 decimals in Aave which is why we must multiply by 1e14\n        // for example ETH has an LTV value of 8000 which represents 80%\n        if (_isLever) {\n            uint256 netBorrowLimit = _actionInfo.collateralValue\n                .preciseMul(maxLtvRaw.mul(10 ** 14))\n                .preciseMul(PreciseUnitMath.preciseUnit().sub(execution.unutilizedLeveragePercentage));\n\n            return netBorrowLimit\n                .sub(_actionInfo.borrowValue)\n                .preciseDiv(_actionInfo.collateralPrice);\n        } else {\n            uint256 netRepayLimit = _actionInfo.collateralValue\n                .preciseMul(liquidationThresholdRaw.mul(10 ** 14))\n                .preciseMul(PreciseUnitMath.preciseUnit().sub(execution.unutilizedLeveragePercentage));\n\n            return _actionInfo.collateralBalance\n                .preciseMul(netRepayLimit.sub(_actionInfo.borrowValue))\n                .preciseDiv(netRepayLimit);\n        }\n    }\n\n```\n[contracts/adapters/AaveLeverageStrategyExtension.sol#L1095](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1095)\n## Impact \n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\nYou can look at how Morpho is handling this\n```solidity\n    function _authorizeBorrow(address underlying, uint256 amount, Types.Indexes256 memory indexes) internal view {\n        DataTypes.ReserveConfigurationMap memory config = _pool.getConfiguration(underlying);\n...\n        if (config.getBorrowCap() != 0) {\n            Types.Market storage market = _market[underlying];\n\n            uint256 trueP2PBorrow = market.trueP2PBorrow(indexes);\n            uint256 borrowCap = config.getBorrowCap() * (10 ** config.getDecimals());\n            uint256 poolDebt =\n                ERC20(market.variableDebtToken).totalSupply() + ERC20(market.stableDebtToken).totalSupply();\n\n            if (amount + trueP2PBorrow + poolDebt > borrowCap) revert Errors.ExceedsBorrowCap();\n        }\n    }\n\n```\n[src/PositionsManagerInternal.sol#L123](https://github.com/morpho-org/morpho-aave-v3/blob/0f494b8321d20789692e50305532b7f1b8fb23ef/src/PositionsManagerInternal.sol#L123)\n\nSo it will look something like this\n\n```diff\n    function _calculateChunkRebalanceNotional(\n        LeverageInfo memory _leverageInfo,\n        uint256 _newLeverageRatio,\n        bool _isLever\n    )\n        internal\n        view\n        returns (uint256, uint256)\n    {\n        // Calculate absolute value of difference between new and current leverage ratio\n        uint256 leverageRatioDifference = _isLever ? _newLeverageRatio.sub(_leverageInfo.currentLeverageRatio) : _leverageInfo.currentLeverageRatio.sub(_newLeverageRatio);\n\n        uint256 totalRebalanceNotional = leverageRatioDifference.preciseDiv(_leverageInfo.currentLeverageRatio).preciseMul(_leverageInfo.action.collateralBalance);\n\n        uint256 maxBorrow = _calculateMaxBorrowCollateral(_leverageInfo.action, _isLever);\n+        (uint256 decimals ,,, , , , , , ,) = strategy.aaveProtocolDataProvider.getReserveConfigurationData(address(strategy.collateralAsset));\n+        (uint256 borrowCap,) = strategy.aaveProtocolDataProvider.getReserveCaps(address(strategy.collateralAsset));\n+        uint256 borrowCap = borrowCap * (10 ** decimals);\n\n-        uint256 chunkRebalanceNotional = Math.min(Math.min(maxBorrow, totalRebalanceNotional), _leverageInfo.twapMaxTradeSize);\n+        uint256 chunkRebalanceNotional = Math.min(Math.min(Math.min(maxBorrow, totalRebalanceNotional), _leverageInfo.twapMaxTradeSize),borrowCap);\n\n        return (chunkRebalanceNotional, totalRebalanceNotional);\n    }\n\n```\n","decidedSeverity":"false","decidedDuplication":"whole AaveLeverageStrategyExtension might not work properly, external contracts and keeper bots will not be able to integrate with Index protocol properly due to not taking into account aave v3 borrow caps"},{"file":"089.md","watson":{"name":"saidam017","days":26,"is_team":false,"payout":1006,"score":12.5523939942,"senior":false},"severity":"medium","title":"Missing add and remove of collateral and borrow assets function inside Aave leverage strategy extension","markdown":"saidam017\n\nmedium\n\n# Missing add and remove of collateral and borrow assets function inside Aave leverage strategy extension\n\n## Summary\n\n`AaveLeverageStrategyExtension` and `AaveV3LeverageStrategyExtension` is defined and integrated with Manager smart contract to interact with the SetToken and Aave leverage module. However, it is not implement add and remove of collateral and borrow assets function inside extension. This can lead to harder and more complicated management of strategy.\n\n## Vulnerability Detail\n\nadd and remove of collateral and borrow assets are defined inside `AaveV3LeverageModule`. This function serve as crucial part of the strategy, so the lever and delever mechanism can work expectedly.\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L598-L649\n\n```solidity\n    function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {\n        _addCollateralAssets(_setToken, _newCollateralAssets);\n    }\n\n    /**\n     * @dev MANAGER ONLY: Remove collateral assets. Disable deposited assets to be used as collateral on Aave market.\n     * @param _setToken             Instance of the SetToken\n     * @param _collateralAssets     Addresses of collateral underlying assets to remove\n     */\n    function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {\n\n        for(uint256 i = 0; i < _collateralAssets.length; i++) {\n            IERC20 collateralAsset = _collateralAssets[i];\n            require(collateralAssetEnabled[_setToken][collateralAsset], \"CNE\");\n\n            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);\n\n            delete collateralAssetEnabled[_setToken][collateralAsset];\n            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));\n        }\n        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);\n    }\n\n    /**\n     * @dev MANAGER ONLY: Add borrow assets. Debt tokens corresponding to borrow assets are tracked for syncing positions.\n     * Note: Reverts with \"Borrow already enabled\" if there are duplicate assets in the passed _newBorrowAssets array.\n     * @param _setToken             Instance of the SetToken\n     * @param _newBorrowAssets      Addresses of borrow underlying assets to add\n     */\n    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {\n        _addBorrowAssets(_setToken, _newBorrowAssets);\n    }\n\n    /**\n     * @dev MANAGER ONLY: Remove borrow assets.\n     * Note: If there is a borrow balance, borrow asset cannot be removed\n     * @param _setToken             Instance of the SetToken\n     * @param _borrowAssets         Addresses of borrow underlying assets to remove\n     */\n    function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {\n\n        for(uint256 i = 0; i < _borrowAssets.length; i++) {\n            IERC20 borrowAsset = _borrowAssets[i];\n\n            require(borrowAssetEnabled[_setToken][borrowAsset], \"BNE\");\n            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, \"VDR\");\n\n            delete borrowAssetEnabled[_setToken][borrowAsset];\n            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));\n        }\n        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);\n    }\n```\n\nHowever, these interaction are not defined inside `AaveLeverageStrategyExtension` and `AaveV3LeverageStrategyExtension`.\n\n## Impact\n\nConsider this scenario, the initial EOA manager have setup all the allowed collateral and borrowed assets, after manager is transferred to contract manager that have aave leverage extension, some collateral or borrow asset is no longer a good strategy or even worse, has a huge price change. After done disengage protocol want to remove the dangerous asset from allowed borrow or collateral asset, but don't have the mechanism inside the extension. Have to transfer the manager first to EOA, done the change, and transfer manager back to contract, but this not safe such that while the ownership is transferred, a lot of interaction still can happen with this strategy (such as debt issue from debt issuance module etc).\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L598-L649\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveV3LeverageStrategyExtension.sol\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nImplement the add and remove of collateral and borrow assets function interaction inside  Aave leverage strategy extension.\n","decidedSeverity":"false","decidedDuplication":"Missing add and remove of collateral and borrow assets function inside Aave leverage strategy extension"},{"file":"090.md","watson":{"name":"saidam017","days":26,"is_team":false,"payout":1006,"score":12.5523939942,"senior":false},"severity":"high","title":"SetToken that use Aave leverage module prone to DoS, attacker can send collateral tokens with LTV = 0","markdown":"saidam017\n\nhigh\n\n# SetToken that use Aave leverage module prone to DoS, attacker can send collateral tokens with LTV = 0\n\n## Summary\n\nWhen an aToken with LTV = 0 is owned by setToken, it will be restricted by Aave to perform operations that require not having collateral with 0 LTV. Some of the operations are crucial and required for `AaveV3LeverageModule` and can break `AaveV3LeverageModule` functionalities if attacker send this aToken to setToken. \n\n## Vulnerability Detail\n\nAave restrict and will revert some operations that have `hasZeroLtvCollateral` is true. such as withdraw, transfer. \n\nhttps://github.com/aave/aave-v3-core/blob/master/contracts/protocol/libraries/logic/ValidationLogic.sol#L606-L609\n\n```solidity\n    require(\n      !hasZeroLtvCollateral || reserve.configuration.getLtv() == 0,\n      Errors.LTV_VALIDATION_FAILED\n    );\n```\n\nIf these functions revert, it will break some setToken functionality : \n\n1. delever function that rely on withdraw functionality : \nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L313-L359\n\n2. redeem function on basic issuance module : \nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/BasicIssuanceModule.sol#L129-L163\n\n3. redeem function on debt issuance module : \nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModuleV2.sol#L142-L190\n\nAttacker can simply send LTV = 0 aToken to setToken so make this happen.\n\n## Impact\n\nThis will break at least the mentioned functionalities on mentioned modules. \n\n## Code Snippet\n\nhttps://github.com/aave/aave-v3-core/blob/master/contracts/protocol/libraries/logic/ValidationLogic.sol#L606-L609\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L313-L359\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModuleV2.sol#L142-L190\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nImplement functionality to withdraw, transfer or set that asset with LTV = 0 as non-collateral on Aave leverage module and Aave leverage strategy extension\n","decidedSeverity":"false","decidedDuplication":"SetToken that use Aave leverage module prone to DoS, attacker can send collateral tokens with LTV = 0"},{"file":"091.md","watson":{"name":"volodya","days":18,"is_team":false,"payout":346.86,"score":12.1469219611,"senior":false},"severity":"medium","title":"borrowing might be disabled by aave, which will lead to external contracts and keeper bots not working properly","markdown":"volodya\n\nmedium\n\n# borrowing might be disabled by aave, which will lead to external contracts and keeper bots not working properly\n\n## Summary\nAccording to [whitepaper aave v3](https://github.com/aave/aave-v3-core/blob/master/techpaper/Aave_V3_Technical_Paper.pdf) borrowing can be disabled and borrowing can be disabled by aave operator\n>Price Oracle sentinel The Sentinel feature has been designed for L2s to handle eventual downtime of the sequencer (but can be extended to handle\nother cases, even on L1s, in the future). It introduces a grace period for\nliquidations and disables borrowing under specific circumstances.\n\nThis means that whenever external contracts or bots will request get data(max borrow and other Index parameters) from protocol via `getChunkRebalanceNotional` the transaction will go through while it should be reverted.\n\nHere you can see how Morpho is handling this issue - reverting when borrowing is not enabled and when Sentinel`s oracle doesn't\n allow borrowing.\n```solidity\n    function _authorizeBorrow(address underlying, uint256 amount, Types.Indexes256 memory indexes) internal view {\n        DataTypes.ReserveConfigurationMap memory config = _pool.getConfiguration(underlying);\n        if (!config.getBorrowingEnabled()) revert Errors.BorrowNotEnabled();\n\n        address priceOracleSentinel = _addressesProvider.getPriceOracleSentinel();\n        if (priceOracleSentinel != address(0) && !IPriceOracleSentinel(priceOracleSentinel).isBorrowAllowed()) {\n            revert Errors.SentinelBorrowNotEnabled();\n        }\n...\n    }\n```\n[PositionsManagerInternal.sol#L110](https://github.com/morpho-org/morpho-aave-v3/blob/0f494b8321d20789692e50305532b7f1b8fb23ef/src/PositionsManagerInternal.sol#L110)\n## Vulnerability Detail\n```solidity\n    function _calculateMaxBorrowCollateral(ActionInfo memory _actionInfo, bool _isLever) internal view returns(uint256) {\n        \n        // Retrieve collateral factor and liquidation threshold for the collateral asset in precise units (1e16 = 1%)\n        ( , uint256 maxLtvRaw, uint256 liquidationThresholdRaw, , , , , , ,) = strategy.aaveProtocolDataProvider.getReserveConfigurationData(address(strategy.collateralAsset));\n\n        // Normalize LTV and liquidation threshold to precise units. LTV is measured in 4 decimals in Aave which is why we must multiply by 1e14\n        // for example ETH has an LTV value of 8000 which represents 80%\n        if (_isLever) {\n            uint256 netBorrowLimit = _actionInfo.collateralValue\n                .preciseMul(maxLtvRaw.mul(10 ** 14))\n                .preciseMul(PreciseUnitMath.preciseUnit().sub(execution.unutilizedLeveragePercentage));\n\n            return netBorrowLimit\n                .sub(_actionInfo.borrowValue)\n                .preciseDiv(_actionInfo.collateralPrice);\n        } else {\n            uint256 netRepayLimit = _actionInfo.collateralValue\n                .preciseMul(liquidationThresholdRaw.mul(10 ** 14))\n                .preciseMul(PreciseUnitMath.preciseUnit().sub(execution.unutilizedLeveragePercentage));\n\n            return _actionInfo.collateralBalance\n                .preciseMul(netRepayLimit.sub(_actionInfo.borrowValue))\n                .preciseDiv(netRepayLimit);\n        }\n    }\n\n```\n[adapters/AaveLeverageStrategyExtension.sol#L1095](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1095)\n## Impact\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n```diff\n function _calculateMaxBorrowCollateral(ActionInfo memory _actionInfo, bool _isLever) internal view returns(uint256) {\n        \n        // Retrieve collateral factor and liquidation threshold for the collateral asset in precise units (1e16 = 1%)\n-        ( , uint256 maxLtvRaw, uint256 liquidationThresholdRaw, , , , , , ,) = strategy.aaveProtocolDataProvider.getReserveConfigurationData(address(strategy.collateralAsset));\n+        ( , uint256 maxLtvRaw, uint256 liquidationThresholdRaw, , , ,bool borrowingEnabled , , ,) = strategy.aaveProtocolDataProvider.getReserveConfigurationData(address(strategy.collateralAsset));\n\n+        if(!borrowingEnabled) revert(\"borrowing not Enabled\");\n+        address priceOracleSentinel = _addressesProvider.getPriceOracleSentinel();// its a global param that needs to be introduced\n+        if (priceOracleSentinel != address(0) && !IPriceOracleSentinel(priceOracleSentinel).isBorrowAllowed()) {\n+            revert Errors.SentinelBorrowNotEnabled();\n+        }\n        // Normalize LTV and liquidation threshold to precise units. LTV is measured in 4 decimals in Aave which is why we must multiply by 1e14\n        // for example ETH has an LTV value of 8000 which represents 80%\n        if (_isLever) {\n            uint256 netBorrowLimit = _actionInfo.collateralValue\n                .preciseMul(maxLtvRaw.mul(10 ** 14))\n                .preciseMul(PreciseUnitMath.preciseUnit().sub(execution.unutilizedLeveragePercentage));\n\n            return netBorrowLimit\n                .sub(_actionInfo.borrowValue)\n                .preciseDiv(_actionInfo.collateralPrice);\n        } else {\n            uint256 netRepayLimit = _actionInfo.collateralValue\n                .preciseMul(liquidationThresholdRaw.mul(10 ** 14))\n                .preciseMul(PreciseUnitMath.preciseUnit().sub(execution.unutilizedLeveragePercentage));\n\n            return _actionInfo.collateralBalance\n                .preciseMul(netRepayLimit.sub(_actionInfo.borrowValue))\n                .preciseDiv(netRepayLimit);\n        }\n    }\n```\n\n","decidedSeverity":"false","decidedDuplication":"borrowing might be disabled by aave, which will lead to external contracts and keeper bots not working properly"},{"file":"092.md","watson":{"name":"cryptostellar5","days":7,"is_team":false,"payout":1070.01,"score":51.2759268686,"senior":false},"severity":"medium","title":"Extensions can be added in Emergencies","markdown":"cryptostellar5\n\nmedium\n\n# Extensions can be added in Emergencies\n\n## Summary\n\nIdeally whenever `emergencies > 0` , No extension can be added. However there is a bypass, using which extensions can be added even in emergencies.\n\n## Vulnerability Detail\n\nThe [BaseManagerV2.sol#addExtension()](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/manager/BaseManagerV2.sol#L228-L233) function has a modifier `upgradesPermitted` applied which makes sure that user can proceed with the function only if `emergencies == 0` . This means that no extension can be added even if there is 1 emergency.\n\nHowever, [authorizeExtension()](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/manager/BaseManagerV2.sol#L258-L268) is able to add extensions even in emergencies, which should not be allowed as explained above.\n\n`authorizeExtension()` calls [_authorizeExtension()](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/manager/BaseManagerV2.sol#L579) which further calls [_addExtension()](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/manager/BaseManagerV2.sol#L535-L541) to add an extension if it is not already added.\n\nIt is nowhere checked whether `emergencies==0` or not.\n\nAlso assume a scenario:\n\n1. **Methodologist** calls `authorizeExtension()` . `authorizeExtension` will still not execute as it has to be run by the **Operator** as well\n2. Now there is some emergency and `emergencies ` count is incremented to 1\n3. `addExtension()` and `authorizeExtension()` are both able to add extensions just by the operator. However since an emergency exists - the `addExtension()` function will revert but `authorizeExtension()` will add an extension even in emergency\n\n\n## Impact\n\nExtensions can be added even in emergencies\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n`upgradesPermitted` should be applied to the internal function: `_addExtension()`\n\n```solidity\n    function _addExtension(address _extension) upgradesPermitted internal {\n        extensions.push(_extension);\n\n        isExtension[_extension] = true;\n\n        emit ExtensionAdded(_extension);\n    }\n``` ","decidedSeverity":"false","decidedDuplication":"Extensions can be added in Emergencies"},{"file":"093.md","watson":{"name":"saidam017","days":26,"is_team":false,"payout":1006,"score":12.5523939942,"senior":false},"severity":"high","title":"Isolated assets could not work properly on Set Token with Aave leverage strategy","markdown":"saidam017\n\nhigh\n\n# Isolated assets could not work properly on Set Token with Aave leverage strategy\n\n## Summary\n\nIf set token already have non-isolated aToken position on Aave, then supplying isolated asset to Aave for leverage strategy, the supplied asset will only set to earning yield but not as collateral. This will make `AaveV3LeverageModule` will not work properly.\n\n## Vulnerability Detail\n\n[Aave docs about Isolation mode](https://docs.aave.com/developers/whats-new/isolation-mode) : \n\n\"Borrower in Isolation Mode cannot enable any other assets including the other isolated assets as collateral.\"\n\nThese check will prevent the supplied asset to be used as collateral : \n\nhttps://github.com/aave/aave-v3-core/blob/master/contracts/protocol/libraries/logic/SupplyLogic.sol#L78-L83\n\nThis could lead to 2 issue : \n\n1. If set token already have non-isolated aToken position on Aave, then supplying isolated asset to Aave for leverage strategy, the supplied asset will only set to earning yield but not as collateral.\n2. First set token supply asset with isolated asset, then try to interact with non-isolated asset, then the non-isolated asset can't be used as collateral.\n\n## Impact\n\n This will make Set token that use `AaveV3LeverageModule` will not work properly when handling aToken positions that contain isolation mode.\n\n## Code Snippet\n\nhttps://github.com/aave/aave-v3-core/blob/master/contracts/protocol/libraries/logic/SupplyLogic.sol#L78-L83\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nDepend on strategy, consider to reject isolated assets if already use non-isolated assets. Or check if the supplied asset is set as collateral after supplied.\n","decidedSeverity":"false","decidedDuplication":"Isolated assets could not work properly on Set Token with Aave leverage strategy"},{"file":"094.md","watson":{"name":"saidam017","days":26,"is_team":false,"payout":1006,"score":12.5523939942,"senior":false},"severity":"medium","title":"Siloed assets borrowed on Set Token AaveV3LeverageModule could cause problem","markdown":"saidam017\n\nmedium\n\n# Siloed assets borrowed on Set Token AaveV3LeverageModule could cause problem\n\n## Summary\n\nIf an asset is configured as siloed, it can't be borrowed in a position at the same time as with other assets. This could lead to unexpected behavior for `AaveV3LeverageModule` and `DebtIssuanceModule` that require borrow on other asset when withdraw.\n\n## Vulnerability Detail\n\n[Aave V3 docs on siloed borrow](https://docs.aave.com/developers/whats-new/siloed-borrowing) : \n\n\"A user borrowing a siloed asset can't borrow the siloed asset in a position at the same time as borrowing other assets.\" \n\nWith this behavior, using asset with siloed borrow on set Token that have AaveV3Leverage and debt issuance for multiple asset could not work properly.\n\nFor instance, debt issuance rely on borrow when issue a token : \n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModule.sol#L677-L697\n\n```solidity\n    function _executeExternalPositionHooks(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        IERC20 _component,\n        bool _isIssue,\n        bool _isEquity\n    )\n        internal\n    {\n        address[] memory externalPositionModules = _setToken.getExternalPositionModules(address(_component));\n        uint256 modulesLength = externalPositionModules.length;\n        if (_isIssue) {\n            for (uint256 i = 0; i < modulesLength; i++) {\n                IModuleIssuanceHook(externalPositionModules[i]).componentIssueHook(_setToken, _setTokenQuantity, _component, _isEquity);\n            }\n        } else {\n            for (uint256 i = 0; i < modulesLength; i++) {\n                IModuleIssuanceHook(externalPositionModules[i]).componentRedeemHook(_setToken, _setTokenQuantity, _component, _isEquity);\n            }\n        }\n    }\n```\n\n\n\n## Impact\n\nSetToken that use `AaveV3LeverageModule` and `DebtIssuanceModule` could not work properly, especially if it using functions that depend on borrow multiple asset.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModuleV2.sol\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModule.sol\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider to not allow siloed borrow, or make it explicit (create parameter e.g `isAllowSiloed`) when create the leverage strategy to make sure if user want to interact with siloed asset.\n","decidedSeverity":"false","decidedDuplication":"Siloed assets borrowed on Set Token AaveV3LeverageModule could cause problem"},{"file":"095.md","watson":{"name":"saidam017","days":26,"is_team":false,"payout":1006,"score":12.5523939942,"senior":false},"severity":"medium","title":"E-Mode configured using `AaveV3LeverageModule` could make other Module that need to borrow on outside category fail","markdown":"saidam017\n\nmedium\n\n# E-Mode configured using `AaveV3LeverageModule` could make other Module that need to borrow on outside category fail\n\n## Summary\n\nIf setToken `AaveV3LeverageModule` is set category to any of the `eModeCategories` configured by the `PoolConfigurator`, then the borrowed can only in the chosen category. This could lead to issue if `AaveV3LeverageModule` or other module that interact with Aave and require to borrow asset not in the chosen category.\n\n## Vulnerability Detail\n\n[According to Aave V3 docs](https://docs.aave.com/faq/aave-v3-features#how-does-e-mode-affect-my-borrowing-power) :\n\n\"Only assets of the same category (for example stablecoins) can be borrowed in E-mode.\"\n\nWith this behavior, using asset with E-Mode enabled on set Token that have AaveV3Leverage and debt issuance for multiple asset that is outside of the chosen category could not work properly.\n\nFor instance, debt issuance rely on borrow when issue a token : \n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModule.sol#L677-L697\n\n```solidity\n    function _executeExternalPositionHooks(\n        ISetToken _setToken,\n        uint256 _setTokenQuantity,\n        IERC20 _component,\n        bool _isIssue,\n        bool _isEquity\n    )\n        internal\n    {\n        address[] memory externalPositionModules = _setToken.getExternalPositionModules(address(_component));\n        uint256 modulesLength = externalPositionModules.length;\n        if (_isIssue) {\n            for (uint256 i = 0; i < modulesLength; i++) {\n                IModuleIssuanceHook(externalPositionModules[i]).componentIssueHook(_setToken, _setTokenQuantity, _component, _isEquity);\n            }\n        } else {\n            for (uint256 i = 0; i < modulesLength; i++) {\n                IModuleIssuanceHook(externalPositionModules[i]).componentRedeemHook(_setToken, _setTokenQuantity, _component, _isEquity);\n            }\n        }\n    }\n```\n\nOn the other hand, currently no restriction inside `addBorrowAssets()` that it only accept asset in the same category : \n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L627-L629\n\n```solidity\n    function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {\n        _addBorrowAssets(_setToken, _newBorrowAssets);\n    }\n```\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L1120-L1130\n\n```solidity\n    function _validateNewBorrowAsset(ISetToken _setToken, IERC20 _asset) internal view {\n        require(!borrowAssetEnabled[_setToken][_asset], \"Borrow already enabled\");\n\n        ( , , address variableDebtToken) = protocolDataProvider.getReserveTokensAddresses(address(_asset));\n        require(address(underlyingToReserveTokens[_asset].variableDebtToken) == variableDebtToken, \"Invalid variable debt token address\");\n\n        (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));\n        require(isActive, \"IAR\");\n        require(!isFrozen, \"FAR\");\n        require(borrowingEnabled, \"BNE\");\n    }\n```\n\n## Impact\n\n This could lead to issue if `AaveV3LeverageModule` or other module that interact with Aave and require to borrow asset not in the chosen category.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModule.sol#L677-L697\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L1120-L1130\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L627-L629\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWhen E-Mode is planned to be configured, add restriction that allowed borrow is only asset in the chosen category of E-Mode.\n","decidedSeverity":"false","decidedDuplication":"E-Mode configured using `AaveV3LeverageModule` could make other Module that need to borrow on outside category fail"},{"file":"096.md","watson":{"name":"jasonxiale","days":32,"is_team":false,"payout":170.12,"score":1.3684321955,"senior":false},"severity":"medium","title":"Division before multiplication incurs unnecessary precision loss","markdown":"jasonxiale\n\nmedium\n\n# Division before multiplication incurs unnecessary precision loss\n\n## Summary\nDivision before multiplication incurs unnecessary precision loss\n\n## Vulnerability Detail\nIn AaveLeverageStrategyExtension.sol, there are some division-before-multiplication which might cause unnecessary lost.\nTake [_calculateMinRepayUnits](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1147C14-L1152) as an example, the function is used to calculate the [minRepayUnits](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#LL783C33-L783C56) which is used as **slippage protection**\n```solidity\n    function _calculateMinRepayUnits(uint256 _collateralRebalanceUnits, uint256 _slippageTolerance, ActionInfo memory _actionInfo) internal pure returns (uint256) {\n        return _collateralRebalanceUnits\n            .preciseMul(_actionInfo.collateralPrice)\n            .preciseDiv(_actionInfo.borrowPrice)\n            .preciseMul(PreciseUnitMath.preciseUnit().sub(_slippageTolerance));\n    }\n```\n\n\nSimilar issue:\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1068\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#LL1128C42-L1128C52\n\n## Impact\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1148-L1152\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1068\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#LL1128C42-L1128C52\n\n## Tool used\n\nManual Review\n\n## Recommendation\n","decidedSeverity":"medium","decidedDuplication":"division before multiplication may result in truncation of result"},{"file":"097.md","watson":{"name":"jasonxiale","days":32,"is_team":false,"payout":170.12,"score":1.3684321955,"senior":false},"severity":"medium","title":"Unbounded loop may cause denial of service due to maximum gas limit reached","markdown":"jasonxiale\n\nmedium\n\n# Unbounded loop may cause denial of service due to maximum gas limit reached\n\n## Summary\nUnbounded loop may cause denial of service due to maximum gas limit reached.\nMalicious actor can  **permissionlessly** repeat creating `SetToken` by calling [SetTokenCreator.create](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/SetTokenCreator.sol#L66-L73), lots of `SetToken` is added into [controller's set](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/Controller.sol#L67). \nAfter that, if the protocol owner wants to call [Controller.removeSet](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/Controller.sol#LL175C14-L175C23) to remove a SetToken, the `removeSet` function will iterate tons of SetToken created by malicious actor to find the matching one, which might run out of gas\n\n## Vulnerability Detail\n\n\nWithin [Controller.addSet](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/Controller.sol#LL160C1-L169C1), the `_setToken` is pushed into `sets` array\n```solidity\n    function addSet(address _setToken) external onlyInitialized onlyFactory {\n        require(!isSet[_setToken], \"Set already exists\");\n\n        isSet[_setToken] = true;\n\n        sets.push(_setToken);\n\n        emit SetAdded(_setToken, msg.sender);\n    }\n```\n\nAnd when calling [Controller.removeSet](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/Controller.sol#L175C14-L183) to remove an `SetToken` from the `sets`, function **remove** is called\n```solidity\n    function removeSet(address _setToken) external onlyInitialized onlyOwner {\n        require(isSet[_setToken], \"Set does not exist\");\n\n        sets = sets.remove(_setToken);\n\n        isSet[_setToken] = false;\n\n        emit SetRemoved(_setToken);\n    }\n```\n\nIn the function [AddressArrayUtils.remove](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/lib/AddressArrayUtils.sol#L84-L96) `indexOf` is called\n```solidity\n    function remove(address[] memory A, address a)\n        internal\n        pure\n        returns (address[] memory)\n    {\n        (uint256 index, bool isIn) = indexOf(A, a);\n        if (!isIn) {\n            revert(\"Address not in array.\");\n        } else {\n            (address[] memory _A,) = pop(A, index);\n            return _A;\n        }\n    }\n```\n\nAnd in [AddressArrayUtils.indexOf](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/lib/AddressArrayUtils.sol#L39C14-L47), the function will iterate the array to find the matched element\n```solidity\n    function indexOf(address[] memory A, address a) internal pure returns (uint256, bool) {\n        uint256 length = A.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (A[i] == a) {\n                return (i, true);\n            }\n        }\n        return (uint256(-1), false);\n    }\n```\n\n## Impact\nUnbounded loop may cause denial of service due to maximum gas limit reached.\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n","decidedSeverity":"false","decidedDuplication":"Unbounded loop may cause denial of service due to maximum gas limit reached"},{"file":"098.md","watson":{"name":"volodya","days":18,"is_team":false,"payout":346.86,"score":12.1469219611,"senior":false},"severity":"medium","title":"Some modules will not work with certain ERC20s reverting when trying to approve with allowance already >0","markdown":"volodya\n\nmedium\n\n# Some modules will not work with certain ERC20s reverting when trying to approve with allowance already >0\n\n## Summary\nSome ERC20 tokens like USDT require resetting the approval to 0 first before being able to reset it to another value.\n## Vulnerability Detail\nThere are multiple files where using invokeApprove without resetting approve to 0.\nThere was 1 module where it was [fixed before](https://github.com/ckoopmann/set-protocol-v2/issues/3)\n>Proposed Mitigation: Resetting allowance to 0 after every mint / redeem. This should also fix the issue of certain ERC20s reverting when trying to approve with allowance already >0\n \n Here are files.\n```solidity\n    function _executeComponentApprovals(ActionInfo memory _actionInfo) internal {\n        address spender = _actionInfo.ammAdapter.getSpenderAddress(_actionInfo.liquidityToken);\n\n        // Loop through and approve total notional tokens to spender\n        for (uint256 i = 0; i < _actionInfo.components.length ; i++) {\n            _actionInfo.setToken.invokeApprove(\n                _actionInfo.components[i],\n                spender,\n                _actionInfo.totalNotionalComponents[i]\n            );\n        }\n    }\n\n```\n[v1/AmmModule.sol#L422](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AmmModule.sol#L422)\n\nOther files:\ncontracts/protocol/modules/v1/WrapModuleV2.sol\ncontracts/protocol/modules/v1/StakingModule.sol\ncontracts/protocol/modules/v1/TradeModule.sol\ncontracts/protocol/modules/v1/AaveV3LeverageModule.sol\n## Impact\nSome modules will not work with certain ERC20s and there might be residual allowance left just like in this [issue](https://github.com/ckoopmann/set-protocol-v2/issues/3)\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\nReset to 0 in those modules so certain ERC20 will work without problems","decidedSeverity":"medium","decidedDuplication":"AmmModule will not work with usdt"},{"file":"099.md","watson":{"name":"sashik_eth","days":7,"is_team":false,"payout":694.43,"score":34.2886048499,"senior":false},"severity":"medium","title":"Use of deprecated Chainlink function - latestAnswer()","markdown":"sashik_eth\n\nmedium\n\n# Use of deprecated Chainlink function - latestAnswer()\n\n## Summary\n\nUse of deprecated Chainlink function - latestAnswer()\n\n## Vulnerability Detail\n\n`AaveLeverageStrategyExtension` using Chainlink priceFeeds to get the latest prices of collateral and borrow assets:\n\n```solidity\nFile: AaveLeverageStrategyExtension.sol\n892:         // Calculate prices from chainlink. Chainlink returns prices with 8 decimal places, but we need 36 - underlyingDecimals decimal places.\n893:         // This is so that when the underlying amount is multiplied by the received price, the collateral valuation is normalized to 36 decimals. \n894:         // To perform this adjustment, we multiply by 10^(36 - 8 - underlyingDecimals)\n895:         int256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\n896:         rebalanceInfo.collateralPrice = rawCollateralPrice.toUint256().mul(10 ** strategy.collateralDecimalAdjustment);\n897:         int256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer();\n898:         rebalanceInfo.borrowPrice = rawBorrowPrice.toUint256().mul(10 ** strategy.borrowDecimalAdjustment);\n```\n\nHowever, due to Chainlink documentation `latestAnwer()` function is deprecated, and the doc explicitly states that it should not be used:\nhttps://docs.chain.link/data-feeds/api-reference#latestanswer\n\nWhore mentions that the value returned from oracle was not checked and could be stale, which could happen if oracle doesn't update it for some period of time. Also comments in contract states that Chainlink feed would return 8 decimals value, which not always correct, for example, DAI/ETH priceFeed returns 18 decimals:\nhttps://etherscan.io/address/0x773616E4d11A78F511299002da57A0a94577F1f4#readContract#F8 \n\n## Impact\n\nProtocol use deprecated Chainlink `latestAnswer()` function, this could result in incorrect calculation or DOS of some functions, for example, `AaveLeverageStrategyExtension#engage`.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L895\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L897\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider using Chainlink's `latestRoundData()` function and adding a sanity check for return price, round, and timestamp.\n","decidedSeverity":"medium","decidedDuplication":"Deprecated oracle function `latestAnswer()` could bring fund loss"},{"file":"100.md","watson":{"name":"sashik_eth","days":7,"is_team":false,"payout":694.43,"score":34.2886048499,"senior":false},"severity":"medium","title":"Not checking if the L2 sequencer is down during the call to Chainlink feeds","markdown":"sashik_eth\n\nmedium\n\n# Not checking if the L2 sequencer is down during the call to Chainlink feeds\n\n## Summary\n\nNot checking if the L2 sequencer is down during the call to Chainlink feeds\n\n## Vulnerability Detail\n\nProtocol uses Chainlink priceFeeds to get the latest prices:\n\n```solidity\nFile: AaveLeverageStrategyExtension.sol\n889:     function _createActionInfo() internal view returns(ActionInfo memory) {\n890:         ActionInfo memory rebalanceInfo;\n891: \n892:         // Calculate prices from chainlink. Chainlink returns prices with 8 decimal places, but we need 36 - underlyingDecimals decimal places.\n893:         // This is so that when the underlying amount is multiplied by the received price, the collateral valuation is normalized to 36 decimals. \n894:         // To perform this adjustment, we multiply by 10^(36 - 8 - underlyingDecimals)\n895:         int256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer(); \n896:         rebalanceInfo.collateralPrice = rawCollateralPrice.toUint256().mul(10 ** strategy.collateralDecimalAdjustment);\n897:         int256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer();\n898:         rebalanceInfo.borrowPrice = rawBorrowPrice.toUint256().mul(10 ** strategy.borrowDecimalAdjustment);\n899: \n900:         rebalanceInfo.collateralBalance = strategy.targetCollateralAToken.balanceOf(address(strategy.setToken));\n901:         rebalanceInfo.borrowBalance = strategy.targetBorrowDebtToken.balanceOf(address(strategy.setToken));\n902:         rebalanceInfo.collateralValue = rebalanceInfo.collateralPrice.preciseMul(rebalanceInfo.collateralBalance);\n903:         rebalanceInfo.borrowValue = rebalanceInfo.borrowPrice.preciseMul(rebalanceInfo.borrowBalance);\n904:         rebalanceInfo.setTotalSupply = strategy.setToken.totalSupply();\n905: \n906:         return rebalanceInfo;\n907:     }\n```\n\nWhen using priceFeeds on L2 it's important to check that sequencer is not down currently, otherwise oracle could return data that would be outdated. However, provided code doesn't check the sequencer state.\n\n## Impact\n\nOuttdated prices could potentially lead to wrong calculations and DOS inside the protocol.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L889-L907\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider updating code for L2 instances that check if the sequencer is up, due to Chainlink docs:\nhttps://docs.chain.link/data-feeds/l2-sequencer-feeds\n","decidedSeverity":"medium","decidedDuplication":"Missing checks for whether Arbitrum Sequencer is active"},{"file":"101.md","watson":{"name":"Lalanda"},"severity":"medium","title":"AaveV3LeverageModule borrows from AaveV3 without checking if the asset is siloed","markdown":"Lalanda\n\nmedium\n\n# AaveV3LeverageModule borrows from AaveV3 without checking if the asset is siloed\n\n## Summary\n\nAaveV3 assets can be siloed. Borrowing siloed assets has limitations. AaveV3LeverageModule should add to its validations if the AaveV3 asset is siloed before borrowing.\n\n## Vulnerability Detail\n\nAave v3 has a new feature of siloed assets. As per Aave docs \"This feature allow assets with potentially manipulatable oracles (for example illiquid Uni V3 pairs) to be listed on Aave as single borrow asset. This means that if an asset is configured as siloed, it can't be borrowed in a position at the same time as with other assets.\" \n\nWhen `AaveV3LeverageModule` adds new borrow assets to its list it does not validate if the asset is siloed.\n\n## Impact\n\nCurrently there is no asset marked siloed in any of the V3 markets. However, Aave Risk or Pool admins have the ability to set assets as siloed. \n\nIndex protocol AaveV3LeverageModule can have a borrow positions on multiple assets. Because on adding borrow assets, siloed verifications are not made, if attempts are made to borrow a siloed asset, the process will fail unexpectedly. Two situations can occur if the borrowing of siloed assets is tried:\n\n1. If the asset is siloed and it is the first position to be borrowed, the borrow will be successful. If other borrows are tried they will fail.\n2. If there are borrowed positions of assets and the borrow of a siloed asset is tried it will fail. \n\n## Code Snippet\n\nOn AaveV3LeverageModule.sol borrow assets can be added on module `initialize`, or after by calling `addBorrowAssets`. \n\nFunction used for new borrow asset validation `_validateNewBorrowAsset`.\n[AaveV3LeverageModule.sol#L1120-L1130](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L1120-L1130)\n\nAaveV3 `validateBorrow` where the siloed check is made.\n[AaveV3LeverageModule.sol#L1120-L1130](https://github.com/aave/aave-v3-core/blob/master/contracts/protocol/libraries/logic/ValidationLogic.sol#L292)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nOn `_validateNewBorrowAsset()` there should be an additional check if the borrow asset is siloed. In case of error, it should revert with the proper error message.\n\n    @@ -1125,19 +1125,18 @@ contract AaveV3LeverageModule is ModuleBase, ReentrancyGuard, Ownable, IModuleIs\n    \n            (, , , , , , bool borrowingEnabled, , bool isActive, bool isFrozen) = protocolDataProvider.getReserveConfigurationData(address(_asset));\n        \n    +        bool borrowIsSiloed = protocolDataProvider.getSiloedBorrowing(address(_asset));\n    +\n    +        require((borrowIsSiloed && enabledAssets[_setToken].borrowAssets.length > 0) ||\n    +        (!borrowIsSiloed && enabledAssets[_setToken].borrowAssets.length == 1 && protocolDataProvider.getSiloedBorrowing(enabledAssets[_setToken].borrowAssets[0]))\n    +        , \"Siloed Borrowing Violation\");\n            require(isActive, \"IAR\");\n            require(!isFrozen, \"FAR\");\n            require(borrowingEnabled, \"BNE\");\n        }\n\n","decidedSeverity":"false","decidedDuplication":"AaveV3LeverageModule borrows from AaveV3 without checking if the asset is siloed"},{"file":"102.md","watson":{"name":"Saeedalipoor01988"},"severity":"high","title":"The protocol assumes that the price received from Oracle is with 8 decimals","markdown":"Saeedalipoor01988\n\nhigh\n\n# The protocol assumes that the price received from Oracle is with 8 decimals\n\n## Summary\n[AaveLeverageStrategyExtension.sol](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L88) assumes that the collateral Price and borrow Price received from Oracle is with 8 decimals.\n\n## Vulnerability Detail\n```solidity\n    function _createActionInfo() internal view returns(ActionInfo memory) {\n        ActionInfo memory rebalanceInfo;\n\n        // Calculate prices from chainlink. Chainlink returns prices with 8 decimal places, but we need 36 - underlyingDecimals decimal places.\n        // This is so that when the underlying amount is multiplied by the received price, the collateral valuation is normalized to 36 decimals. \n        // To perform this adjustment, we multiply by 10^(36 - 8 - underlyingDecimals)\n        int256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\n        rebalanceInfo.collateralPrice = rawCollateralPrice.toUint256().mul(10 ** strategy.collateralDecimalAdjustment);\n        int256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer();\n        rebalanceInfo.borrowPrice = rawBorrowPrice.toUint256().mul(10 ** strategy.borrowDecimalAdjustment);\n\n        rebalanceInfo.collateralBalance = strategy.targetCollateralAToken.balanceOf(address(strategy.setToken));\n        rebalanceInfo.borrowBalance = strategy.targetBorrowDebtToken.balanceOf(address(strategy.setToken));\n        rebalanceInfo.collateralValue = rebalanceInfo.collateralPrice.preciseMul(rebalanceInfo.collateralBalance);\n        rebalanceInfo.borrowValue = rebalanceInfo.borrowPrice.preciseMul(rebalanceInfo.borrowBalance);\n        rebalanceInfo.setTotalSupply = strategy.setToken.totalSupply();\n\n        return rebalanceInfo;\n    }\n```\n\nThe [above code](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L895) i used to create Action Info, in this code AaveLeverageStrategyExtension will get collateral asset and borrow asset prices from oracle. as you can see in the comment, protocol assumes that Chainlink returns prices with 8 decimal places, so calculating is based on the 10^(36 - 8 - underlyingDecimals).\n\nThe protocol expects to interact with any ERC20, different ERC20 assets means different price decimals. so in the _createActionInfo function, you should use price.decimals and do the next steps of calculations based on this.\n\n## Impact\nThe [collateralValue ](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L902)and [borrowValue ](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L903) are done incorrectly.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L895\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L897\n\n## Tool used\nManual Review\n\n## Recommendation\nUse price decimals from oracle.","decidedSeverity":"medium","decidedDuplication":"Wrongly assume chainlink oracle decimal is always 8"},{"file":"103.md","watson":{"name":"sashik_eth","days":7,"is_team":false,"payout":694.43,"score":34.2886048499,"senior":false},"severity":"medium","title":"Set could be forced to isolation mode","markdown":"sashik_eth\n\nmedium\n\n# Set could be forced to isolation mode\n\n## Summary\n\nSet could be forced to isolation mode.\n\n## Vulnerability Detail\n\nOne of the new features of Aave v3 is \"isolation mode\". It allows making some assets \"isolated\" from other resources in the pool. When borrowers supply isolated assets as collateral they automatically become unable to use other assets as collateral.\n\nSince Aave would set assets as collateral during [transferring](https://github.com/aave/aave-v3-core/blob/v1.17.2/contracts/protocol/libraries/logic/SupplyLogic.sol#L222), this opens a potential attack vector when the attacker transfers some amount of isolated asset to a newly created Set address (or upfront since all Sets are created through the factory and its addresses are predictable). After this isolated asset becomes Set's collateral and Set becomes unable to provide other assets as collateral, this basically blocks `AaveV3LeverageModule` core functionality.\n\nTo mitigate such a situation manager could call `AaveV3LeverageModule#removeCollateralAssets` providing a \"poisoned\" asset address in parameters, previously called `AaveV3LeverageModule#addCollateralAssets` to add this address to the `collateralAssetEnabled` list, otherwise would be impossible to disable asset as collateral for Set.\n\nManager functionality is handled by the `methodologist` and `operator` through the `BaseManagerV2` contract and its extensions. `AaveV3LeverageStrategyExtension` does not have appropriate functions that would allow the required calls to mitigate the problem (`addCollateralAssets` and `removeCollateralAssets` could not be called through this extension). So to execute appropriate calls `methodologist` and `operator` would need to transfer the manager role to some EOA/wallet address. \n\nIn some other edge cases, Set could be forced to isolation mode if at the moment Set has only one asset and it's isolated or Aave admins make it isolated, check reference issue (5.2.5):\nhttps://github.com/spearbit/portfolio/blob/master/pdfs/Morpho-Av3-Spearbit-Security-Review.pdf\n\n## Impact\n\nAnyone could \"poison\" a newly created Set or any not yet deployed Set upfront by sending some amount of Aave isolated asset. This would force Set to isolation mode preventing from using other assets as collateral, basically broking protocol functionality. Mitigation would require trusted actors (`methodologist` and `operator`) to break the existing trust model and transfer the core role (`manager`) to some external EOA/wallet.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L1019\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding to `AaveV3LeverageStrategyExtension` 2 functions: one to allow the operator to call `AaveV3LeverageModule#addCollateralAssets` and another to call `AaveV3LeverageModule#removeCollateralAssets`. Alternatively, consider adding a permissionless function that does these two calls only in case if \"poisoned\" asset is not in the list of enabled Set collaterals.\n","decidedSeverity":"false","decidedDuplication":"Set could be forced to isolation mode"},{"file":"104.md","watson":{"name":"Saeedalipoor01988"},"severity":"medium","title":"EOA can lose part of reward after make call to the ripcord function","markdown":"Saeedalipoor01988\n\nmedium\n\n# EOA can lose part of reward after make call to the ripcord function\n\n## Summary\nThe caller of the [ripcord() function](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1218) can lose part of the reward in Ether.\n\n## Vulnerability Detail\n```solidity\n    function _transferEtherRewardToCaller(uint256 _etherReward) internal returns(uint256) {\n        uint256 etherToTransfer = _etherReward < address(this).balance ? _etherReward : address(this).balance;\n\n        msg.sender.transfer(etherToTransfer);\n\n        return etherToTransfer;\n    }\n```\n\nAfter EOA makes the call to the ripcord function, in return for a reward, [the contract will send ETH to the EOA](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1218). but the user will get all rewards only if the user's reward is less than the contract balance. so if the user reward is 0.3 ETH and the contract balance is 0.2 ETH, the user will get only 0.2 ETH and 0.1 ETH get lose because there is not any code to track the user's pending reward.\n\n## Impact\nThe caller of the ripcord function can lose part of the reward in Ether.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1218\n\n## Tool used\nManual Review\n\n## Recommendation\nstore the unpaid part of the user's reward so the user can claim it in the future.","decidedSeverity":"false","decidedDuplication":"EOA can lose part of reward after make call to the ripcord function"},{"file":"105.md","watson":{"name":"PRAISE","days":64,"is_team":false,"payout":403.7,"score":1.9031785617,"senior":false},"severity":"high","title":"In AaveV3leverageModule.sol's lever() function there's no check to ensure that _minReceiveQuantityUnits is directly proportional to _borrowQuantityUnits","markdown":"PRAISE\n\nhigh\n\n# In AaveV3leverageModule.sol's lever() function there's no check to ensure that _minReceiveQuantityUnits is directly proportional to _borrowQuantityUnits\n\n## Summary\nthe minimum quantity of collateral asset( `_minReceiveQuantityUnits`) in position units received in lever() might not be directly proportional to the quantity of borrow asset( `_borrowQuantityUnits`) in position units when leveraging\n\n## Vulnerability Detail\nThe lever() function in AaveV3LeverageModule.sol Performs a DEX trade, exchanging the _borrowAsset for _collateralAsset. It also increases leverage for a given collateral position.\n\nsince the lever() function exchanges the _borrowAsset for _collateralAsset. The quantity of _borrowAsset exchanged for _collateralAsset should be directly proportional.\n\nThe issue is that the lever() function doesn't ensure that.\ni'll give 2 scenarios for this\n\n1. i believe this is some sort of slippage.. like for example:\nif _borrowAsset is ETH, `_borrowQuantityUnits` is the quantity of ETH used in leverage and _collateralAsset is USDT, `_minReceiveQuantityUnits` is the amount of USDT to receive from exchanging ETH for USDT.\nAs of the time of writing this report 1ETH = 1,883 USDT\n\nit is possible that when using lever() the quantity of USDT i receive is smaller than what i'm supposed to receive.(i.e 1ETH = 1,883 USDT), this is possible due to network congestion which can hold the lever() tx in the mempool for a long time and the price of ETH/USDT changes unfavorably so i don't receive the amount of USDT / ETH i'm supposed to receive.\n\n2. the manager might specify a lower quantity of collateral assets to receive for the exchange of borrow asset to collateral asset.\nfor example, lets say i'm the manager and borrow asset is ETH while collateral asset is USDT and the price is 1ETH/1,883USDT\nnow if manager wants to leverage since there's no check against this, manager can put 500 as `_minReceiveQuantityUnits` for 1 ETH(`_borrowQuantityUnits`), whilst it's supposed to be 1,883, this results in losing 1383 USDT\n\n\n## Impact\n1. slippage in quantity of borrow asset(`_borrowQuantityUnits`) per quantity of collateral asset(`_minReceiveQuantityUnits`)\n\n2.` _minReceiveQuantityUnits` in position units of collateral asset specified by manager is not equivalent to `_borrowQuantityUnits` in position units, leading to manager getting less collateral asset quantity(`_minReceiveQuantityUnits`) that's less compared to what he's supposed to get from the exchange of borrow assets to collateral assets.\n\n\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L252\n\n## Tool used\n\nManual Review\n\n## Recommendation\nthere should be a check to ensure that `_minReceiveQuantityUnits` in position units received is directly proportional to `_borrowQuantityUnits` in position units used for leverage\n\n","decidedSeverity":"false","decidedDuplication":"In AaveV3leverageModule.sol's lever() function there's no check to ensure that _minReceiveQuantityUnits is directly proportional to _borrowQuantityUnits"},{"file":"106.md","watson":{"name":"PRAISE","days":64,"is_team":false,"payout":403.7,"score":1.9031785617,"senior":false},"severity":"high","title":"In AaveV3leverageModule.sol's delever() function there's no check to ensure that `_minRepayQuantityUnits` is directly proportional to `_redeemQuantityUnits`","markdown":"PRAISE\n\nhigh\n\n# In AaveV3leverageModule.sol's delever() function there's no check to ensure that `_minRepayQuantityUnits` is directly proportional to `_redeemQuantityUnits`\n\n## Summary\nthe minimum quantity of repay asset(`_minRepayQuantityUnits`) in position units received in delever() might not be directly proportional to the quantity of collateral asset(`_redeemQuantityUnits`) in position units when deleveraging.\n\n## Vulnerability Detail\nThe delever() function in AaveV3LeverageModule.sol Performs a DEX trade, exchanging the _collateralAsset for _repayAsset. It also decrease leverage for a given collateral position.\n\nsince the delever() function exchanges the _collateralAsset for _repayAsset. The quantity of _collateralAsset exchanged for _repayAsset should be directly proportional.\n\nThe issue is that the delever() function doesn't ensure that.\nI will give 2 scenarios for this:\n\n1. i believe this is some sort of slippage.. like for example:\n\nif _collateralAsset is ETH, `_redeemQuantityUnits` is the quantity of ETH used in deleverage  and _repayAsset is USDT, `_minRepayQuantityUnits` is the amount of USDT to receive from exchanging ETH for USDT. \nAs of the time of writing this report 1ETH = 1,883 USDT\n\nit is possible that when using delever() the quantity of USDT i receive is smaller than what i'm supposed to receive.(i.e 1ETH = 1,883 USDT), this is possible due to network congestion which can hold the delever() tx in the mempool for a long time and the price of ETH/USDT changes unfavorably so i don't receive the amount of USDT / ETH i'm supposed to receive.\n\n\n2. the manager might specify a lower quantity of repay assets to receive for the exchange of collateral asset to repay asset.\nfor example, lets say i'm the manager and collateral asset is ETH while repay asset is USDT and the price is 1ETH/1,883USDT\n\nnow if manager want to delever since there's no check against this manager can put 500 as `_minRepayQuantityUnits` for 1 ETH (`_redeemQuantityUnits`), whilst it's supposed to be 1,883, this results in losing 1383 USDT\n\n## Impact\n1. slippage in quantity of Collateral asset(`_redeemQuantityUnits`) per quantity of Repay asset(`_minRepayQuantityUnits`)\n\n2. `_minRepayQuantityUnits` in position units of repay asset specified by manager is not equivalent to `_redeemQuantityUnits` in position units, leading to manager getting less repay asset quantity(`_minRepayQuantityUnits`) that's less compared to what he's supposed to get from the exchange of collateral assets to repay assets. \n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L313\n\n## Tool used\n\nManual Review\n\n## Recommendation\nthere should be a check to ensure that `_minRepayQuantityUnits` in position units received is directly proportional to _redeemQuantityUnits in position units when deleveraging","decidedSeverity":"false","decidedDuplication":"In AaveV3leverageModule.sol's delever() function there's no check to ensure that `_minRepayQuantityUnits` is directly proportional to `_redeemQuantityUnits`"},{"file":"107.md","watson":{"name":"tallo","days":34,"is_team":false,"payout":104.47,"score":0.8373650399,"senior":false},"severity":"medium","title":"If a module is removed by the controller after calling lock() it will result in a complete bricking of the SetToken contract","markdown":"tallo\n\nmedium\n\n# If a module is removed by the controller after calling lock() it will result in a complete bricking of the SetToken contract\n\n## Summary\nModules that call ```lock()``` in ```SetToken.sol``` will be unable to call ```unlock()``` if they are removed as a module by the controller. This results in all the functionality behind the ```whenLockedOnlyLocker``` modifier being permanently locked since only the locker has permission to call ```unlock()```.\n\n## Vulnerability Detail\nThe ```lock()``` function inside ```SetToken.sol``` allows modules to be designated as the ```locker``` and lock certain important functionality until they call ```unlock()```.\n```solidity\n    function lock() external onlyModule {\n        require(!isLocked, \"Must not be locked\");\n        locker = msg.sender;\n        isLocked = true;\n    }\n```\n\nIf the module were to be removed in ```Controller.sol``` by the owner after ```lock()``` was just called then the module will no longer be registered.\n```solidity\n    function removeModule(address _module) external onlyInitialized onlyOwner {\n        require(isModule[_module], \"Module does not exist\");\n\n        modules = modules.remove(_module);\n\n        //@audit here isModule is set to false\n        isModule[_module] = false;\n\n        emit ModuleRemoved(_module);\n    }\n```\nWhen the module is no longer registered, it is no longer able to call functions behind the onlyModule modifier since ```controller#isModule(msg.sender)``` will return false.\n```solidity\n    modifier onlyModule() {\n        _validateOnlyModule();\n        _;\n    }\n\n    function _validateOnlyModule() internal view {\n       //..\n        require(\n            controller.isModule(msg.sender),\n            \"Module must be enabled on controller\"\n        );\n    }\n\n```\nThis means that ```unlock()``` can't be called by anybody since it requires both ```onlyModule``` to not revert and ```locker``` to be equal to ```msg.sender```\n\n```solidity\n    function unlock() external onlyModule {\n        require(isLocked, \"Must be locked\");\n        require(locker == msg.sender, \"Must be locker\");\n        delete locker;\n        isLocked = false;\n    }\n```\n## Impact\nAll key protocol functionality such as ```invoke()```, ```mint()```, ```burn()```, etc... will be blocked and rendered useless. Furthermore, simply re-adding and re-initializing the module to ```Controller.sol``` and ```SetToken.sol```  to call ```unlock()``` is not possible since ```initializeModule()``` requires that the protocol is not locked.\n\n```solidity\n//@audit SetToken.sol\n   function initializeModule() external {\n        require(!isLocked, \"Only when unlocked\");\n```\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/SetToken.sol#L343\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/SetToken.sol#L684\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/SetToken.sol#L352\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/Controller.sol#L235\n\n## Tool used\n\nManual Review\n\n## Recommendation\nManagers should have the ability to emergency unlock the protocol","decidedSeverity":"false","decidedDuplication":"If a module is removed by the controller after calling lock() it will result in a complete bricking of the SetToken contract"},{"file":"108.md","watson":{"name":"Cryptor","days":26,"is_team":false,"payout":47.1,"score":0.864264114,"senior":false},"severity":"medium","title":"Inconsistent accounting calculation in calculateTotalFees","markdown":"Cryptor\n\nmedium\n\n# Inconsistent accounting calculation in calculateTotalFees\n\n## Summary\n\nThe function Redeem allows a user to redeem tokens for the underlying collateral. However, the calculation for the amount of fees  is incorrect due to a misplacement in the  _calculateTotalFees function which is called after settokens are burned. This is inconsistent with the the issue function, where totalFees are calculated before settokens are minted.\n\n\n\n## Vulnerability Detail\nThe function Redeem allows a user to redeem their tokens by burning their set tokens for underlying collateral. In this function, there is the function calculateTotalFees which calculates manager and protocol fees\n\n\nHowever, this function is called after set tokens are burned\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModuleV2.sol#L158-L166\n\nThis is inconsistent with the issue function where calculatetotal fees are called before the settokens are minted \n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModuleV2.sol#L94-L115\n\n\nThis can result in possible accounting issues where the manager and the protocol receive less settokens that they should receive\n\n\n\n## Impact\nManager and the Protocol will receive less settokens fees than expected due to an accounting mismatch\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCall _calculateTotalFees before calling burn to make it consistent with the issue function \n","decidedSeverity":"false","decidedDuplication":"Inconsistent accounting calculation in calculateTotalFees"},{"file":"109.md","watson":{"name":"PRAISE","days":64,"is_team":false,"payout":403.7,"score":1.9031785617,"senior":false},"severity":"medium","title":"missing deadline and deadline checker in lever() and delever() function in AaveV3LeverageModule.sol contract.","markdown":"PRAISE\n\nmedium\n\n# missing deadline and deadline checker in lever() and delever() function in AaveV3LeverageModule.sol contract.\n\n## Summary\nLever() and delever() transactions could be delayed in mempool due to Network Congestion\n\n## Vulnerability Detail\nNetwork congestion in the mempool refers to a situation where the number of pending transactions waiting to be included in a blockchain exceeds the available capacity of the network to process them promptly.  \n\nSo a deadline and deadline checker(usually a require statement that takes account of duration) is needed to revert the transactions. \n\nThis is expedient because:\n1. The transactions can be pending for a very long time due to network congestion.\n\n2. price slippage can happen as the 2 functions handle DEX trades. There could be a change in price between the collateral per borrow asset/ repay asset affecting the minimum quantities specified in lever() and delever() functions\n\nA very vivid example is ETH/USDT price.  As of the time of writing this report 1 ETH = 1,883 USDT and it's constantly changing.\n\n## Impact\ntransactions can be stuck in the mempool for a long period of time due to missing deadline and deadline checker\n\nAlso there could be price slippage between the collateral Asset and borrow Assets/repay Assets.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L252\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L313\n## Tool used\n\nManual Review\n\n## Recommendation\nimplement a deadline and deadline checker in the lever() and delever() functions like uniswap","decidedSeverity":"medium","decidedDuplication":"`AaveLeverageStrategyExtension.sol` does not allow user to specify slippage parameter during rebalance or ripcord"},{"file":"110.md","watson":{"name":"volodya","days":18,"is_team":false,"payout":346.86,"score":12.1469219611,"senior":false},"severity":"medium","title":"Rounding Issues In Certain Functions","markdown":"volodya\n\nmedium\n\n# Rounding Issues In Certain Functions\n\n## Summary\nI believe there is a rounding issue in deliver and deleverToZeroBorrowBalance\n## Vulnerability Detail\n```solidity\n    function deleverToZeroBorrowBalance(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantityUnits,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n        returns (uint256)\n    {\n        uint256 setTotalSupply = _setToken.totalSupply();\n//       @audit\n//        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMulCeil(setTotalSupply);\n        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);\n\n        require(borrowAssetEnabled[_setToken][_repayAsset], \"Borrow not enabled\");\n        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));\n        require(notionalRepayQuantity > 0, \"Borrow balance is zero\");\n\n        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            notionalRedeemQuantity,\n            notionalRepayQuantity,\n            _tradeAdapterName,\n            false,\n            setTotalSupply\n        );\n\n        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);\n\n        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\n        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);\n\n        _updateDeleverPositions(deleverInfo, _repayAsset);\n\n        emit LeverageDecreased(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            deleverInfo.exchangeAdapter,\n            deleverInfo.notionalSendQuantity,\n            notionalRepayQuantity,\n            0   // No protocol fee\n        );\n\n        return notionalRepayQuantity;\n    }\n\n```\n[v1/AaveLeverageModule.sol#L390](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveLeverageModule.sol#L390)\n\nThe same issue with `deliver`\n```solidity\n    function delever(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantityUnits,\n        uint256 _minRepayQuantityUnits,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n   ...\n     ActionInfo memory deleverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            _redeemQuantityUnits,\n            _minRepayQuantityUnits,\n            _tradeAdapterName,\n            false\n        );\n...\n    }\n\n```\n```solidity\n    function _createAndValidateActionInfo(\n        ISetToken _setToken,\n        IERC20 _sendToken,\n        IERC20 _receiveToken,\n        uint256 _sendQuantityUnits,\n        uint256 _minReceiveQuantityUnits,\n        string memory _tradeAdapterName,\n        bool _isLever\n    )\n        internal\n        view\n        returns(ActionInfo memory)\n    {\n        uint256 totalSupply = _setToken.totalSupply();\n\n        return _createAndValidateActionInfoNotional(\n            _setToken,\n            _sendToken,\n            _receiveToken,\n            _sendQuantityUnits.preciseMul(totalSupply),\n            _minReceiveQuantityUnits.preciseMul(totalSupply), // rounding down when it supposed to be rounding up\n            _tradeAdapterName,\n            _isLever,\n            totalSupply\n        );\n    }\n\n```\nRound up to calculate notional, so that we make atleast `_collateralQuantityUnits` position unit after withdraw.\nExample, let totalSupply = 1.005e18, _collateralQuantityUnits = 13159, then\ncollateralNotionalQuantity = 13159 * 1.005e18 / 1e18 = 13225 (13224.795 rounded up)\nWe delever 13225 from AaveLeverageModule and make a leve unit from it. So new tokens will be = (13225 / 1.005e18) * 1e18\n13159 (13159.2039801 rounded down)\nYou can look at this example [PerpV2LeverageModuleV2.sol here](https://github.com/SetProtocol/set-protocol-v2/commit/7780963134e8be081906ef51104965051ad1045a)\n\n\n\n## Impact\nUsers will receive a little less than they deserve\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\nReplace preciseMul with preciseMulCeil in `deleverToZeroBorrowBalance` and `delever`\n","decidedSeverity":"medium","decidedDuplication":"division before multiplication may result in truncation of result"},{"file":"111.md","watson":{"name":"jasonxiale","days":32,"is_team":false,"payout":170.12,"score":1.3684321955,"senior":false},"severity":"medium","title":"Approval Race Protections","markdown":"jasonxiale\n\nmedium\n\n# Approval Race Protections\n\n## Summary\nSome tokens (like USDT) do not work when changing the allowance from an existing non-zero allowance value.They must first be approved by zero and then the actual allowance must be approved.\n## Vulnerability Detail\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/lib/Invoke.sol#L46-L56\n```solidity\n    function invokeApprove(\n        ISetToken _setToken,\n        address _token,\n        address _spender,\n        uint256 _quantity\n    )\n        internal\n    {\n        bytes memory callData = abi.encodeWithSignature(\"approve(address,uint256)\", _spender, _quantity);\n        _setToken.invoke(_token, 0, callData);\n    }\n```\n\n## Impact\nThis vulnerability could result in an inability to transfer tokens due to the requirement of first setting the allowance to zero, then re-approving the allowance to the desired value.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/lib/Invoke.sol#L46-L56\n\n## Tool used\n\nManual Review\n\n## Recommendation\n","decidedSeverity":"medium","decidedDuplication":"AmmModule will not work with usdt"},{"file":"112.md","watson":{"name":"Saeedalipoor01988"},"severity":"medium","title":"onlyEOA modifier that ensures call is from EOA might not hold true in the future","markdown":"Saeedalipoor01988\n\nmedium\n\n# onlyEOA modifier that ensures call is from EOA might not hold true in the future\n\n## Summary\nmodifier onlyEOA is used to ensure calls are only made from EOA. However, EIP 3074 suggests that using onlyEOA modifier to ensure calls are only from EOA might not hold true.\n\n## Vulnerability Detail\nFor [onlyEOA](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/lib/BaseExtension.sol#L59) , tx.origin is used to ensure that the caller is from an EOA and not a smart contract.\n\n```solidity\n    /**\n     * Throws if caller is a contract, can be used to stop flash loan and sandwich attacks\n     */\n    modifier onlyEOA() {\n        require(msg.sender == tx.origin, \"Caller must be EOA Address\");\n        _;\n    }\n```\n\nHowever, according to [EIP 3074](https://eips.ethereum.org/EIPS/eip-3074#abstract),\n\nThis EIP introduces two EVM instructions AUTH and AUTHCALL. The first sets a context variable authorized based on an ECDSA signature. The second sends a call as the authorized account. This essentially delegates control of the externally owned account (EOA) to a smart contract.\n\nTherefore, using tx.origin to ensure msg.sender is an EOA will not hold true in the event EIP 3074 goes through.\n\n## Impact\nUsing modifier onlyEOA to ensure calls are made only from EOA will not hold true in the event EIP 3074 goes through.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/lib/BaseExtension.sol#L59\n\n## Tool used\nManual Review\n\n## Recommendation\nRecommend using OpenZepellin's isContract function (https://docs.openzeppelin.com/contracts/2.x/api/utils#Address-isContract-address-). \n","decidedSeverity":"medium","decidedDuplication":"onlyEOA modifier that ensures call is from EOA might not hold true with the eip 3074"},{"file":"113.md","watson":{"name":"XDZIBEC"},"severity":"medium","title":"XDZIBEC-The Blunder in _setEModeCategory Function","markdown":"XDZIBEC\n\nmedium\n\n# XDZIBEC-The Blunder in _setEModeCategory Function\n\n## Summary\n\nbug  In the function _`setEModeCategory`, the calldata to the `setEModeCategory` function on the `strategy.leverageModule` contract is incorrect.\n\n## Vulnerability Detail\n\n```solidity\n    function setEModeCategory(uint8 _categoryId) external onlyOperator {\n        _setEModeCategory(_categoryId);\n    }\n\n    function _setEModeCategory(uint8 _categoryId) internal {\n        bytes memory setEmodeCallData =\n            abi.encodeWithSignature(\"setEModeCategory(address,uint8)\", address(strategy.setToken), _categoryId);\n        invokeManager(address(strategy.leverageModule), setEmodeCallData);\n    }\n}\n```\n\nThe calldata being passed to the `setEModeCategory` function is completely off. It's like sending a love letter to the wrong person and expecting a positive response. it's not going to end well.\n\n## Impact\n\nIt could be exploited by an attacker to prevent the `setEModeCategory` function from being called on the` strategy.leverageModule` contract. This could prevent the operator from changing the `eMode categoryId`.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveV3LeverageStrategyExtension.sol#L60\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n The calldata should be:\n\n`bytes memory setEmodeCallData = abi.encodeWithSignatured(\"setEModeCategory(uint8)\", _categoryId);\n`\nThe current calldata includes the address of the `strategy.setToken` contract, which is not necessary. This will cause the `setEModeCategory` function on the \n `strategy.leverageModule` contract to fail.\n\n```solidity\nfunction _setEModeCategory(uint8 _categoryId) internal {\n    bytes memory setEmodeCallData = abi.encodeWithSignature(\"setEModeCategory(uint8)\", _categoryId);\n```\n  \nHere the correct code:\n\n ```solidity\ninvokeManager(address(strategy.leverageModule), setEmodeCallData);\n}\n```\n\n\n","decidedSeverity":"false","decidedDuplication":"XDZIBEC-The Blunder in _setEModeCategory Function"},{"file":"114.md","watson":{"name":"Cryptor","days":26,"is_team":false,"payout":47.1,"score":0.864264114,"senior":false},"severity":"medium","title":"Instant ripcords possible due to no validation check on incentive leverage ratio being higher than the current leverage ratio","markdown":"Cryptor\n\nmedium\n\n# Instant ripcords possible due to no validation check on incentive leverage ratio being higher than the current leverage ratio\n\n## Summary\nNo validation check on currentleverageratio being lower than the incentive leverage ratio could result in an edge case scenario where an AaveV3 position can be instantly ripcorded \n\n## Vulnerability Detail\n\nIn the function engage, the value of current leverage ratio is 10^18 by default shown here:\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/lib/PreciseUnitMath.sol#L46\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L263-L269\n\n\nHowever, there is no validation to check to make sure that the incentived leverage ratio is more than 10^18\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L912-L956\n\nThis can result in scenarios where a position can be instantly ripcorded. This is because the function ripcord requires that the Current Leverage Ratio is lower than the incentived leverage ratio\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L984\n\n## Impact\nAn AaveV3 position can be instantly ripcorded \n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L263-L269\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIn the constructor, add a check to make sure that the incentive leverage ratio is bigger than 10^18\n","decidedSeverity":"false","decidedDuplication":"Instant ripcords possible due to no validation check on incentive leverage ratio being higher than the current leverage ratio"},{"file":"115.md","watson":{"name":"XDZIBEC"},"severity":"medium","title":"XDZIBEC-absorb Function in AirdropExtension Does Not Check Caller's Authority","markdown":"XDZIBEC\n\nmedium\n\n# XDZIBEC-absorb Function in AirdropExtension Does Not Check Caller's Authority\n\n## Summary\n\nThere is a bug in the `absorb` function:\nIt’s allows anyone to call the `absorb` function and steal any `airdropped tokens`, even if they are not the intended recipient. It’s could lead to financial losses for users of the contract.\nThis vulnerability could be exploited by malicious actors from an attacker.\n\n## Vulnerability Detail\n\n`absorb`\n```solidity \n     */\n    function absorb(address _token) external onlyAllowedCaller(msg.sender) {\n        invokeManager(\n            address(airdropModule),\n            abi.encodeWithSignature(\"absorb(address,address)\", setToken, _token)\n        );\n    }\n\n    /**\n     * OPERATOR ONLY: batch absorbs airdropped tokens\n     *\n     * @param _tokens   List of airdropped tokens to absorb\n     */\n```\n\nthe `absorb` function does not check whether the `caller` is the `owner` of the contract. This means that anyone can call this `function` and `absorb` any `airdropped` `tokens`, even if they are not the intended recipient.\nThe vulnerability  is caused by a lack of authorization checking in the absorb function.\nIf an attacker can exploit this vulnerability by malicious actors is leading to steal airdropped tokens from users of the contract.\n\n\n## Impact\n\nThe bug is a serious security issue, an attacker can exploit this vulnerability by malicious actors  that could lead to financial losses for users of the contract and  it’s leading to steal airdropped tokens from users of the contract.\n\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AirdropExtension.sol#L75\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n-the `absorb` function should be `updated` to check the owner of the contract before allowing anyone to call it and ensure that only the owner of the contract can call the `absorb` function and `absorb` any `airdropped tokens`.\n","decidedSeverity":"false","decidedDuplication":"XDZIBEC-absorb Function in AirdropExtension Does Not Check Caller's Authority"},{"file":"116.md","watson":{"name":"Auditwolf","days":14,"is_team":false,"payout":248.39,"score":4.731352302,"senior":false},"severity":"high","title":"Missing function resolve fees in debtissuancemodulev2.","markdown":"Auditwolf\n\nhigh\n\n# Missing function resolve fees in debtissuancemodulev2.\n\n## Summary\n\nResolve fees function is intended to check if there are any manager fees in the process of issuance or redemption on _debtissuancemodulev2_  . If so it mints sets to the fee recipient with the amount of manager fee . however this function is missing.\n\n## Vulnerability Detail\n\nissue\n\n            _resolveEquityPositions(_setToken, quantityWithFees, _to, true, components, equityUnits, initialSetSupply, finalSetSupply);\n            _resolveDebtPositions(_setToken, quantityWithFees, true, components, debtUnits, initialSetSupply, finalSetSupply);\n            _resolveFees(_setToken, managerFee, protocolFee);\n        }\n\n\nredeem\n\n            _resolveDebtPositions(_setToken, quantityNetFees, false, components, debtUnits, initialSetSupply, finalSetSupply);\n            _resolveEquityPositions(_setToken, quantityNetFees, _to, false, components, equityUnits, initialSetSupply, finalSetSupply);\n            _resolveFees(_setToken, managerFee, protocolFee);\n        }\nBoth the functions issue and redeem in _debtissuancemodulev2_ are intended to call resolve  fees function to check whether there are any manager fees and if so , mint sets to the fee recipient together with the protocol fees as in the case with _debtissuancemodule.sol_ .\n\n## Impact\n\nIf there are manager fees and protocol fees sets will not be minted to the fee recipient.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModuleV2.sol#L142C2-L191C1\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModuleV2.sol#L75C2-L127C1\n## Tool used\n\nManual Review\n\n## Recommendation\n","decidedSeverity":"false","decidedDuplication":"Missing function resolve fees in debtissuancemodulev2."},{"file":"117.md","watson":{"name":"Auditwolf","days":14,"is_team":false,"payout":248.39,"score":4.731352302,"senior":false},"severity":"false","title":"Functions invoke deposit ,  invoke borrow and invoke repay use address (_set token) instead of (_OnBehalfOf).","markdown":"Auditwolf\n\nfalse\n\n# Functions invoke deposit ,  invoke borrow and invoke repay use address (_set token) instead of (_OnBehalfOf).\n\n## Summary\n\nThe address (es) calling the functions invoke deposit , invoke borrow and invoke repay are always subject to each of the actions of these function even if  other address (es)  are specified (_onbehalfof_) .\n\n## Vulnerability Detail\n1. Function invoke deposit.\nTo get relevant deposit data this function calls _getdepositcalldata_ function . Onbehalfof parameter in the function getdepositcalldata is defined as the address that will receive the aTokens, same as msg.sender if the user  wants to receive them on his own wallet, or a different address if the beneficiary of aTokens is a different wallet. However, the address parameter in function invoke deposit is set always to be msg.sender (address of set token)  and not ( _Onbehalfof ) meaning the receiver of atokens will always be the set token even if the user specified another address.\n\n ( , , bytes memory depositCalldata) = getDepositCalldata(\n            _lendingPool,\n            _asset,\n            _amountNotional, \n            address(_setToken), \n            0\n2. Function invoke borrow.\nto get relevant borrow data this function calls _getborrowcalldata_ function which defines _Onbehalfof_ parameter as the Address of the user who will receive the debt. Should be the address of the borrower itself calling the function if he wants to borrow against his own collateral, or the address of the credit delegator if he has been given credit delegation allowance. The address parameter in the function invoke borrow however  is  set always to the address of the borrower itself ( address of the set token ) and not ( on behalf ) address meaning the address of the set token will always receive debt even if the user specified another address.\n\n bytes memory borrowCalldata) = getBorrowCalldata(\n            _lendingPool,\n            _asset,\n            _amountNotional,\n            _interestRateMode,\n            0, \n            address(_setToken)\n        );\n3. Function invoke repay \nTo get repay data this function calls _getrepaycalldata_ function which defines _Onbehalfof_ parameter as the  Address of the user who will get his debt reduced/removed. Should be the address of the user calling the function if he wants to reduce/remove his own debt, or the address of any other borrower whose debt should be removed. In contrast , the address specified in the function invoke repay is to be always the msg.sender and not (_onbehalfof ) meaning the debt of the address (set token ) will always be reduced even though debt of another address was supposed to be reduced.\n\n        ( , , bytes memory repayCalldata) = getRepayCalldata(\n            _lendingPool,\n            _asset,\n            _amountNotional,\n            _interestRateMode,\n            address(_setToken)\n        );\n# Impact\n\nthe addresses of the set token calling functions invoke deposit , invoke borrow and invoke repay will always be on the receiving end of each of their actions even if other address (es)  (_onbehalfof ) is specified.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/integration/lib/AaveV3.sol#L84C1-L99C9\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/integration/lib/AaveV3.sol#L230C2-L247C9\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/integration/lib/AaveV3.sol#L305C1-L322C9\n## Tool used\n\nManual Review\n\n## Recommendation\nIn each of the functions invoke deposit , invoke borrow and invoke repay replace the address parameter (_set token ) with (_Onbehalfof ).","decidedSeverity":"false","decidedDuplication":"Functions invoke deposit ,  invoke borrow and invoke repay use address (_set token) instead of (_OnBehalfOf)."},{"file":"118.md","watson":{"name":"Auditwolf","days":14,"is_team":false,"payout":248.39,"score":4.731352302,"senior":false},"severity":"high","title":"Functions invoke deposit sends atokens to address (_set token) instead of (_OnBehalfOf).","markdown":"Auditwolf\n\nhigh\n\n# Functions invoke deposit sends atokens to address (_set token) instead of (_OnBehalfOf).\n\n## Summary\n\n## Vulnerability Detail\n\nTo get relevant deposit data this function calls getdepositcalldata function . Onbehalfof parameter in the function getdepositcalldata is defined as the address that will receive the aTokens, same as msg.sender if the user wants to receive them on his own wallet, or a different address if the beneficiary of aTokens is a different wallet. However, the address parameter in function invoke deposit is set always to be msg.sender (address of set token) and not ( _Onbehalfof ) meaning the receiver of atokens will always be the set token even if the user specified another address.\n\n        ( , , bytes memory depositCalldata) = getDepositCalldata(\n            _lendingPool,\n            _asset,\n            _amountNotional, \n            address(_setToken), \n            0\n        );\n        \n\n## Impact\n\natokens are sent to an unintended address.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/integration/lib/AaveV3.sol#L84C1-L99C9\n\n## Tool used\n\nManual Review\n\n## Recommendation\nReplace address(_setToken) with address (_onbehalfOf )","decidedSeverity":"false","decidedDuplication":"Functions invoke deposit sends atokens to address (_set token) instead of (_OnBehalfOf)."},{"file":"119.md","watson":{"name":"jasonxiale","days":32,"is_team":false,"payout":170.12,"score":1.3684321955,"senior":false},"severity":"medium","title":"AaveV3LeverageModule.lever might failed to update default position when using SWAP_TOKENS_FOR_EXACT_TOKENS trade","markdown":"jasonxiale\n\nmedium\n\n# AaveV3LeverageModule.lever might failed to update default position when using SWAP_TOKENS_FOR_EXACT_TOKENS trade\n\n## Summary\nWhile calling `AaveV3LeverageModule.delever` and `AaveV3LeverageModule.deleverToZeroBorrowBalance` the functions call  [AaveV3LeverageModule._updateDeleverPositions](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#LL878C76-L878C87) to update the positions, within `AaveV3LeverageModule._updateDeleverPositions` [AaveV3LeverageModule.sol#L880-L887](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L880-L887) is used to handle over-pay assets.\n\nSimilar issue might happen in `AaveV3LeverageModule.lever` if  `exact output swaps` is used, in such case, the remaining asset is not accounted as default position\n\n## Vulnerability Detail\n[AaveV3LeverageModule._executeTrade](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L794) is used to swap tokens.\n\n[Line 816](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L816) calls `exchangeAdapter.getTradeCalldata` to pack trade data, `UniswapV2ExchangeAdapterV2.getTradeCalldata` is one of the exhange adaptor.\n\nAccording to [UniswapV2ExchangeAdapterV2.getTradeCalldata](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/integration/exchange/UniswapV2ExchangeAdapterV2.sol#L74-L100), the last byte of **_data** is used to determine `SWAP_EXACT_TOKENS_FOR_TOKENS` or `SWAP_TOKENS_FOR_EXACT_TOKENS`\n```solidity\n    function getTradeCalldata(\n        address /* _sourceToken */,\n        address /* _destinationToken */,\n        address _destinationAddress,\n        uint256 _sourceQuantity,\n        uint256 _destinationQuantity,\n        bytes memory _data\n    )\n        external\n        view\n        returns (address, uint256, bytes memory)\n    {\n        (\n            address[] memory path,\n            bool shouldSwapExactTokensForTokens\n        ) = abi.decode(_data, (address[],bool));\n\n        bytes memory callData = abi.encodeWithSignature(\n            shouldSwapExactTokensForTokens ? SWAP_EXACT_TOKENS_FOR_TOKENS : SWAP_TOKENS_FOR_EXACT_TOKENS,\n            shouldSwapExactTokensForTokens ? _sourceQuantity : _destinationQuantity,\n            shouldSwapExactTokensForTokens ? _destinationQuantity : _sourceQuantity,\n            path,\n            _destinationAddress,\n            block.timestamp\n        );\n        return (router, 0, callData);\n    }\n```\n\nIf `SWAP_TOKENS_FOR_EXACT_TOKENS` is used, after calling `_executeTrade` in [lever](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L279), there might some assets left which should accounted for updating the default position \n\n## Impact\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\nUsing similar function as `_updateDeleverPositions._updateDeleverPositions`","decidedSeverity":"false","decidedDuplication":"AaveV3LeverageModule.lever might failed to update default position when using SWAP_TOKENS_FOR_EXACT_TOKENS trade"},{"file":"120.md","watson":{"name":"Saeedalipoor01988"},"severity":"medium","title":"USE OF DEPRECATED CHAINLINK FUNCTION: LATESTANSWER","markdown":"Saeedalipoor01988\n\nmedium\n\n# USE OF DEPRECATED CHAINLINK FUNCTION: LATESTANSWER\n\n## Summary\nPlease check Vulnerability Detail.\n\n## Vulnerability Detail\nAccording to Chainlink’s documentation (API Reference), the latestAnswer function is deprecated. This function does not throw an error if no answer has been reached, but instead returns 0, possibly causing an incorrect price to be fed to the different price feeds or even a Denial of Service by a division by zero.\n\n## Impact\nPlease check Vulnerability Detail.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L895\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L897\n\n## Tool used\nManual Review\n\n## Recommendation\nit is recommended to use Chainlink’s latestRoundData() function to get the price instead. ","decidedSeverity":"medium","decidedDuplication":"Deprecated oracle function `latestAnswer()` could bring fund loss"},{"file":"121.md","watson":{"name":"Saeedalipoor01988"},"severity":"medium","title":"Chainlink's latestRoundData return stale or incorrect result","markdown":"Saeedalipoor01988\n\nmedium\n\n# Chainlink's latestRoundData return stale or incorrect result\n\n## Summary\n\n## Vulnerability Detail\nin [_createActionInfo function](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L889), you are Calculate prices from chainlink, but there is no check if the return value indicates stale data.\n\n## Impact\nThis could lead to stale prices according to the Chainlink documentation.\n https://docs.chain.link/data-feeds/price-feeds/historical-data\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L895\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L897\n\n## Tool used\nManual Review\n\n## Recommendation\nConsider adding the missing checks for stale data.\n\n```solidity\n  uint256 decimals = registry.decimals(token, USD);\n        (uint80 roundID, int256 answer, uint256 timestamp, uint256 updatedAt, ) = registry.latestRoundData(\n            token,\n            USD\n        );\n        //Solution\n        require(updatedAt >= roundID, \"Stale price\");\n        require(timestamp != 0,\"Round not complete\");\n        require(answer > 0,\"Chainlink answer reporting 0\");\n\n        if (updatedAt < block.timestamp - maxDelayTime)\n            revert PRICE_OUTDATED(_token);\n```","decidedSeverity":"medium","decidedDuplication":"Chainlink's latestRoundData return stale or incorrect result"},{"file":"122.md","watson":{"name":"Saeedalipoor01988"},"severity":"medium","title":"No check if Arbitrum L2 sequencer is down in Chainlink feeds","markdown":"Saeedalipoor01988\n\nmedium\n\n# No check if Arbitrum L2 sequencer is down in Chainlink feeds\n\n## Summary\nChainlink recommends that users using price oracles, check whether the Arbitrum Sequencer is\n[active](https://docs.chain.link/data-feeds/l2-sequencer-feeds#arbitrum).\n\nUsing Chainlink in L2 chains such as Arbitrum requires to check if the sequencer is down to avoid prices from looking like they are fresh although they are not.\n\n## Vulnerability Detail\n```solidity\n    function _createActionInfo() internal view returns(ActionInfo memory) {\n        ActionInfo memory rebalanceInfo;\n\n        // Calculate prices from chainlink. Chainlink returns prices with 8 decimal places, but we need 36 - underlyingDecimals decimal places.\n        // This is so that when the underlying amount is multiplied by the received price, the collateral valuation is normalized to 36 decimals. \n        // To perform this adjustment, we multiply by 10^(36 - 8 - underlyingDecimals)\n        int256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\n        rebalanceInfo.collateralPrice = rawCollateralPrice.toUint256().mul(10 ** strategy.collateralDecimalAdjustment);\n        int256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer();\n        rebalanceInfo.borrowPrice = rawBorrowPrice.toUint256().mul(10 ** strategy.borrowDecimalAdjustment);\n\n        rebalanceInfo.collateralBalance = strategy.targetCollateralAToken.balanceOf(address(strategy.setToken));\n        rebalanceInfo.borrowBalance = strategy.targetBorrowDebtToken.balanceOf(address(strategy.setToken));\n        rebalanceInfo.collateralValue = rebalanceInfo.collateralPrice.preciseMul(rebalanceInfo.collateralBalance);\n        rebalanceInfo.borrowValue = rebalanceInfo.borrowPrice.preciseMul(rebalanceInfo.borrowBalance);\n        rebalanceInfo.setTotalSupply = strategy.setToken.totalSupply();\n\n        return rebalanceInfo;\n    }\n```\n\nThe [AaveLeverageStrategyExtension.sol._createActionInfo() function](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L888) is using chainlink to get the rawCollateralPrice  and rawBorrowPrice . \n\nThere is no check that the sequencer is down.\n\n## Impact\nplease check Vulnerability Detail.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L895\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L897\n\n## Tool used\nManual Review\n\n## Recommendation\nIt is recommended to follow the code example of Chainlink:\nhttps://docs.chain.link/data-feeds/l2-sequencer-feeds#example-code\n\nUse a [chainlink oracle](https://blog.chain.link/how-to-use-chainlink-price-feeds-on-arbitrum/#almost_done!_meet_the_l2_sequencer_health_flag) to determine whether the sequencer is offline or not.","decidedSeverity":"medium","decidedDuplication":"Missing checks for whether Arbitrum Sequencer is active"},{"file":"123.md","watson":{"name":"Cryptor","days":26,"is_team":false,"payout":47.1,"score":0.864264114,"senior":false},"severity":"medium","title":"No status check for Aave assets after it has been validated once","markdown":"Cryptor\n\nmedium\n\n# No status check for Aave assets after it has been validated once\n\n## Summary\n\nThere is no validation check for Aave assets after it has been added to the borrowassets mapping. This can result in unexpected reverts due to the changing status of Aave assets \n\n## Vulnerability Detail\n\nThe function _validateNewBorrowAsset, which is called by the function _addBorrowAssets, validates an Aave asset to be used as collateral shown here:\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L1120-L1130\n\nIt checks whether the Aave asset is frozen and active\n\nHowever, there is no such check whenever the function calls _lever or _validatecommon shown here\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L277-L287\n\n\n\nFurthermore, the mappings for the status of these Aave assets are not updated in the borrowAssetsEnabled and enabledAssets mappings when the function sync is called shown here:\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L437-L454\n\n\n\nThis can be problematic and lead to unexpected reverts if an Aave admin disables critical functions for that particular Aave asset such as borrowing and depositing.\n\n## Impact\n\nUnexpected reverts if an Aave asset is frozen or not active \n\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L1120-L1130\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L1091-L1096\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd a check when borrowing and depositing asset in the validatecommon function, whether an Aave asset is frozen or not.\n","decidedSeverity":"false","decidedDuplication":"No status check for Aave assets after it has been validated once"},{"file":"124.md","watson":{"name":"MohammedRizwan"},"severity":"medium","title":"Missing check for active Arbitrum Sequencer","markdown":"MohammedRizwan\n\nmedium\n\n# Missing check for active Arbitrum Sequencer\n\n## Summary\nChainlink recommends that all Optimistic L2 oracles consult the Sequencer Uptime Feed to ensure that the sequencer is live before trusting the data returned by the oracle. This check is missing in _createActionInfo() of AaveLeverageStrategyExtension.sol contract.\n\n## Vulnerability Detail\nSince the smart contracts will also be deployed on Arbitrum. If the Arbitrum Sequencer goes down, oracle data will not be kept up to date, and thus could become stale. However, users are able to continue to interact with the protocol directly through the L1 optimistic rollup contract. You can review Chainlink docs on [L2 Sequencer Uptime Feeds](https://docs.chain.link/data-feeds/l2-sequencer-feeds) for more details on this.\n\nAs a result, users may be able to use the protocol while oracle feeds are stale. This could cause many problems, but as a simple example:\n\n- A user has an account with 100 tokens, valued at 1 ETH each, and no borrows\n\n- The Arbitrum sequencer goes down temporarily\n\n- While it’s down, the price of the token falls to 0.5 ETH each\n\n- The current value of the user’s account is 50 ETH, so they should be able to borrow a maximum of 200 ETH to keep account healthy ((200 + 50) / 200 = 1.2)\n\n- Because of the stale price, the protocol lets them borrow 400 ETH ((400 + 100) / 400 = 1.2) # Impact If the Arbitrum sequencer goes down, the protocol will allow users to continue to operate at the previous (stale) rates.\n\n## Impact\nIf the Arbitrum sequencer goes down, the protocol will allow users to continue to operate at the previous (stale) rates.\n\n## Code Snippet\nLink to affected code-\nhttps://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/adapters/AaveLeverageStrategyExtension.sol#L895-L898\n\nNote- \nThe contract has used latestAnswer() from chainlink IChainlinkAggregatorV3 which is deprecated now. It is already recommended to use  latestRoundData() in another issue.\n\n## Tool used\nManual Review\n\n## Recommendation\nUse sequencer oracle to determine whether the sequencer is offline or not, and don't allow orders to be executed while the sequencer is offline.\n\nCheck the Chainlink Documentation for a full example: [https://docs.chain.link/data-feeds/l2-sequencer-feeds#example-code](https://docs.chain.link/data-feeds/l2-sequencer-feeds)\n\nAlso check the queue system here: [https://docs.chain.link/data-feeds/l2-sequencer-feeds/](https://docs.chain.link/data-feeds/l2-sequencer-feeds)\n","decidedSeverity":"medium","decidedDuplication":"Missing checks for whether Arbitrum Sequencer is active"},{"file":"125.md","watson":{"name":"Cryptor","days":26,"is_team":false,"payout":47.1,"score":0.864264114,"senior":false},"severity":"medium","title":"Airdrop Module is incompatible with Aave V3 with certain ERC20 tokens","markdown":"Cryptor\n\nmedium\n\n# Airdrop Module is incompatible with Aave V3 with certain ERC20 tokens\n\n## Summary\nAirdropped tokens could be incompatible with AaveV3 with certain ERC20 tokens \n\n\n## Vulnerability Detail\n\nThe airdrop module allows a manger and any approved to absorb airdropped tokens into a token's position. However if that position is an AaveV3 position, then it will not be compatible with certain ERC20 tokens in mainnet and other L2 chains. For example, A product could have an airdrop token of EURS which is available on Aave L2 markets, but not on the mainnet market \n\nhttps://app.aave.com/markets/?marketName=proto_mainnet_v3\n\n## Impact\n\nIf a ERC20 token in an airdropped module is incompatible with AaveV3, then the tokens cannot be absorbed into the position\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AirdropModule.sol#L127-L134\n\n## Tool used\n\nManual Review\n\n## Recommendation\nIf a set token's position is an external Aave V3 position, check if the airdropped token is compatible with AaveV3 before adding it to the mapping.","decidedSeverity":"false","decidedDuplication":"Airdrop Module is incompatible with Aave V3 with certain ERC20 tokens"},{"file":"126.md","watson":{"name":"kutugu"},"severity":"medium","title":"latestAnswer interface is deprecated","markdown":"kutugu\n\nmedium\n\n# latestAnswer interface is deprecated\n\n## Summary\n\n`latestAnswer` interface is deprecated.   \n\n## Vulnerability Detail\n\n1. According to chainlink [docs](https://docs.chain.link/data-feeds/api-reference#latestanswer), the `latestAnswer` interface is deprecated\n2. latestAnswer may return 0, no checking\n3. latestAnswer may return stale price, no checking\n\n## Impact\n\nMedium. Collateral and borrow values may be miscalculated, affecting user funds.    \n\n## Code Snippet\n\n- https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L895\n- https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L897\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nuse `latestRoundData` and check data freshness\n","decidedSeverity":"medium","decidedDuplication":"Deprecated oracle function `latestAnswer()` could bring fund loss"},{"file":"127.md","watson":{"name":"kutugu"},"severity":"medium","title":"Chainlink may return stale price when L2 sequencer is down","markdown":"kutugu\n\nmedium\n\n# Chainlink may return stale price when L2 sequencer is down\n\n## Summary\n\nChainlink may return stale price when L2 sequencer is down\n\n## Vulnerability Detail\n\nAccording to the audit description, index will be deployed on L2 Optimism and Arbitrum.     \nFrom [Chainlink documentation](https://docs.chain.link/data-feeds/l2-sequencer-feeds), If a sequencer becomes unavailable, ChainlinkAggregator may return stale price.         \n\nNote that It is a different issue from checking oracle price freshness.        \nBecause in the case of sharp price fluctuations, the price may be updated several times, although the final price is in freshness, but it may not be the latest price.     \n\n## Impact\n\nMedium. Collateral and borrow values may be miscalculated, affecting user funds. Malicious users can use price differentials to arbitrage.\n\n## Code Snippet\n\n- https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L895\n- https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L897\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRefer to the [official document](https://docs.chain.link/data-feeds/l2-sequencer-feeds#example-code)\n","decidedSeverity":"medium","decidedDuplication":"Missing checks for whether Arbitrum Sequencer is active"},{"file":"128.md","watson":{"name":"Auditwolf","days":14,"is_team":false,"payout":248.39,"score":4.731352302,"senior":false},"severity":"high","title":"The function \"validateminimumunderlyingreceived\" will consistently revert  when attempting to verify the minimum underlying received during the process of removing liquidity for a single assets.","markdown":"Auditwolf\n\nhigh\n\n# The function \"validateminimumunderlyingreceived\" will consistently revert  when attempting to verify the minimum underlying received during the process of removing liquidity for a single assets.\n\n## Summary\n\nTo check that minimum underlying is received , the function _removeliquiditysingleassset_ calls the function _validateminimumunderlyingreceived_  which ensures that the underlying balance is greater than or equal to (action info ) total notional components  +  ( action info ) _preactionactioncomponentbalances_ . However this check only works when removing liquidity for various components and not single assets.\n\n## Vulnerability Detail\n\n            require(\n                underlyingBalance >= _actionInfo.totalNotionalComponents[i].add(_actionInfo.preActionComponentBalances[i]),\n                \"Underlying tokens received must be greater than minimum specified\"\n            );\n        }\n    }\n\nThis check will always fail when called by the function _removeliquiditysingleasset_  since the total notional components will be  zero for single assets and further the _preactioncomponentbalance_ is never checked in _getactioninfosingleasset_ function which is also called  by _removeliquiditysingleasset_. \n\n## Impact\n\nIt will be impossible to remove liquidity for single assets since function  _validateminimumunderlyingreceived_  will always revert.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AmmModule.sol#L258C1-L288C1\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AmmModule.sol#L511C1-L521C1\n\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider adding an if statement in the function _validateminimumunderlyingreceived_ to check the function calling it whether it is remove liquidity or remove liquidity single asset . then add a call in the function _getactioninfosingleasset_  to get the _preactioncomponentbalance_ by calling the function _getTokenbalances_.","decidedSeverity":"false","decidedDuplication":"The function \"validateminimumunderlyingreceived\" will consistently revert  when attempting to verify the minimum underlying received during the process of removing liquidity for a single assets."},{"file":"129.md","watson":{"name":"kutugu"},"severity":"medium","title":"If AmmModule approve more token may result DOS","markdown":"kutugu\n\nmedium\n\n# If AmmModule approve more token may result DOS\n\n## Summary\n\nFor tokens such as USDT, require allowance is 0 when approve.      \nWhen operating liquidity for the uniswap pool, an unbalanced number of tokens may be passed in, resulting in the approved tokens not being spent. When operate liquidity again, the transaction revert.    \nNOTE that setToken is a contract cannot revoke approve, so this setToken is permanently DOS in AmmModule.    \n\n## Vulnerability Detail\n\nThe entire invocation process is as follows:  \n\n```solidity\n    // @audit 1. calculate `totalNotionalComponents` by `_maxComponentUnits` input param\n    function _executeAddLiquidity(ActionInfo memory _actionInfo) internal {\n        (\n            address targetAmm, uint256 callValue, bytes memory methodData\n        ) = _actionInfo.ammAdapter.getProvideLiquidityCalldata(\n            address(_actionInfo.setToken),\n            _actionInfo.liquidityToken,\n            _actionInfo.components,\n            _actionInfo.totalNotionalComponents,\n            _actionInfo.liquidityQuantity\n        );\n\n        // @audit 2. approve pool `totalNotionalComponents` amount\n        _executeComponentApprovals(_actionInfo);\n\n        // @audit 3. use part of the funds\n        _actionInfo.setToken.invoke(targetAmm, callValue, methodData);\n    }\n\n\n        // @audit part input\n        uint256 liquidityExpectedFromSuppliedTokens = Math.min(\n            maxTokensIn[0].mul(totalSupply).div(reserveA),\n            maxTokensIn[1].mul(totalSupply).div(reserveB)\n        );\n\n        require(\n            minLiquidity <= liquidityExpectedFromSuppliedTokens,\n            \"_minLiquidity is too high for input token limit\"\n        );\n\n        // Now that we know the minimum expected liquidity to receive for the amount of tokens\n        // that are being supplied, we can reverse the above equations in the min function to\n        // determine how much actual tokens are supplied to the pool, therefore setting our\n        // amountAMin and amountBMin of the addLiquidity call to the expected amounts.\n\n        amountAMin = liquidityExpectedFromSuppliedTokens.mul(reserveA).div(totalSupply);\n        amountBMin = liquidityExpectedFromSuppliedTokens.mul(reserveB).div(totalSupply);\n        }\n```  \n\n## Impact\n\nMedium. If the number of tokens input does not match when addLiquidity, the token approved is not all spent, when  addLiquidity again tx may revert and SetToken can't use AmmModule anymore.\n\n## Code Snippet\n\n- https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AmmModule.sol#L417-L428C6\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nuse openzeppelin `forceApprove` function, reset allowance before approve.\n","decidedSeverity":"medium","decidedDuplication":"AmmModule will not work with usdt"},{"file":"130.md","watson":{"name":"ast3ros","days":63,"is_team":false,"payout":8659.62,"score":77.1423447599,"senior":true},"severity":"high","title":"Risk of liquidation when issuing new SetToken","markdown":"ast3ros\n\nhigh\n\n# Risk of liquidation when issuing new SetToken\n\n## Summary\n\nIf the SetToken has a leveraged debt position using Aave V3, issuing a large amount of new tokens can increase the debt and lower the health factor. This can expose the SetToken to the risk of liquidation.\n\n## Vulnerability Detail\n\nWhen the SetToken has a leveraged debt position using Aave V3, a user can issue new tokens by calling `DebtIssuanceModuleV2#issue` (SetToken uses DebtIssuaneModuleV2 and AaveV3LeverageModule).\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModuleV2.sol#L75-L126\n\nThe function will resolve the debt position by calling `_executeExternalPositionHooks`, which will invoke the `componentIssueHook` in the AaveV3LeverageModule.\n\n        if (_isIssue) {\n            _executeExternalPositionHooks(_setToken, _quantity, IERC20(component), true, false);\n\n            // Call Invoke#invokeTransfer instead of Invoke#strictInvokeTransfer\n            _setToken.invokeTransfer(component, msg.sender, componentQuantity);\n\n            IssuanceValidationUtils.validateCollateralizationPostTransferOut(_setToken, component, _finalSetSupply);\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModuleV2.sol#L310-L317\n\n        if (_isIssue) {\n            for (uint256 i = 0; i < modulesLength; i++) {\n                IModuleIssuanceHook(externalPositionModules[i]).componentIssueHook(_setToken, _setTokenQuantity, _component, _isEquity);\n            }\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModule.sol#L688-L691\n\nThe `componentIssueHook` will call the `_borrowForHook` function, which will borrow the `notionalDebt` amount calculated based on the SetToken quantity and the component debt.\n\n        function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {\n            // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position\n            // exists the loan would be taken out twice potentially leading to liquidation\n            if (!_isEquity) {\n                int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n\n                require(componentDebt < 0, \"CMBN\");\n\n                uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);\n                _borrowForHook(_setToken, _component, notionalDebt);\n            }\n        }\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L695-L706\n\nThe issue can happen because there is no check to ensure that the `notionalDebt` amount does not decrease the health factor in Aave to near 1. If it is slightly above 1, a small change in price could trigger the liquidation of the leveraged position of the SetToken. This would result in a loss for the SetToken.\n\n## Impact\n\nThe leveraged position in Aave could be liquidated if the borrowed amount from new token issuance is too large.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L695-L706\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModuleV2.sol#L310-L317\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCalculate the maximum allowed borrow amount and revert if the SetToken issuance leads to a higher amount of debt borrow.","decidedSeverity":"false","decidedDuplication":"Risk of liquidation when issuing new SetToken"},{"file":"131.md","watson":{"name":"ast3ros","days":63,"is_team":false,"payout":8659.62,"score":77.1423447599,"senior":true},"severity":"medium","title":"BaseManagerV2 lacks function to remove pending module","markdown":"ast3ros\n\nmedium\n\n# BaseManagerV2 lacks function to remove pending module\n\n## Summary\n\nThe SetToken contract has a function called `removePendingModule` that can only be invoked by its manager. However, if the manager is set to be the BaseManagerV2 contract, this function becomes inaccessible because BaseManagerV2 does not have a corresponding function to call it.\n\n## Vulnerability Detail\n\nThe `removePendingModule` function in the SetToken contract allows the manager to remove a module that is in the pending state.\n\n        function removePendingModule(address _module) external onlyManager {}\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/SetToken.sol#L392\n\nHowever, if the manager is set to be the `BaseManagerV2` contract, this function cannot be invoked. This is because BaseManagerV2 does not have a function that can interact with the `removePendingModule` function of the SetToken contract.\n\n## Impact\n\nThe inability to remove a pending module may affect the functionality and security of the SetToken contract.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/SetToken.sol#L392\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nImplement a function in BaseManagerV2 that can call the `removePendingModule` function of the SetToken contract. For example:\n\n```javascript\n    function removePendingModule(address _module) external onlyOperator {\n        setToken.removePendingModule(_module);\n    }\n```","decidedSeverity":"false","decidedDuplication":"BaseManagerV2 lacks function to remove pending module"},{"file":"132.md","watson":{"name":"ast3ros","days":63,"is_team":false,"payout":8659.62,"score":77.1423447599,"senior":true},"severity":"medium","title":"AaveV3 library uses deprecated deposit function","markdown":"ast3ros\n\nmedium\n\n# AaveV3 library uses deprecated deposit function\n\n## Summary\n\nThe AaveV3 library creates the callData for the SetToken to interact with the Aave v3 pool using the `deposit` function. However, this function is deprecated in Aave v3 and replaced by the `supply` function.\n\n## Vulnerability Detail\n\nThe `getDepositCalldata` function in the AaveV3 library encodes the callData with the signature `\"deposit(address,uint256,address,uint16)\"`. This means that the SetToken will call the `deposit` function of the Aave v3 pool with the given parameters.\n\n    function getDepositCalldata(\n        IPool _lendingPool,\n        address _asset, \n        uint256 _amountNotional,\n        address _onBehalfOf,\n        uint16 _referralCode\n    )\n        public\n        pure\n        returns (address, uint256, bytes memory)\n    {\n        bytes memory callData = abi.encodeWithSignature(\n            \"deposit(address,uint256,address,uint16)\",\n            _asset, \n            _amountNotional, \n            _onBehalfOf,\n            _referralCode\n        );\n        \n        return (address(_lendingPool), 0, callData);\n    }\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/integration/lib/AaveV3.sol#L52-L72\n\nHowever, in Aave v3, the `deposit` function is deprecated and replaced by the `supply` function: https://docs.aave.com/developers/core-contracts/pool#supply\n\n## Impact\n\nThe deprecated function may not be supported by Aave v3 in the future pool pairs and cause errors when interacting with the Aave v3 pool.\nThe Aave v3 pool contract is upgradeable and the deposit function can be removed in the future. It is neccesary to change the call to supply now.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/integration/lib/AaveV3.sol#L52-L72\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse the `supply` function instead of the `deposit` function when encoding the callData.\n\n```diff\n        bytes memory callData = abi.encodeWithSignature(\n-           \"deposit(address,uint256,address,uint16)\",\n+           \"supply(address,uint256,address,uint16)\",\n            _asset, \n            _amountNotional, \n            _onBehalfOf,\n            _referralCode\n        );\n```","decidedSeverity":"medium","decidedDuplication":"AaveV3 library uses deprecated deposit function"},{"file":"133.md","watson":{"name":"ast3ros","days":63,"is_team":false,"payout":8659.62,"score":77.1423447599,"senior":true},"severity":"medium","title":"L2 optimization functions are not used for L2 pool","markdown":"ast3ros\n\nmedium\n\n# L2 optimization functions are not used for L2 pool\n\n## Summary\n\nThe AaveV3 library does not use the L2 optimization functions that are recommended by Aave for interacting with the L2 pool contracts.\n\n## Vulnerability Detail\n\nIn Aave V3, the pool contracts on L2 (Arbitrum and Optimism) introduce optimization functions that compress the information passed to the pool methods.\n\n        The main transaction cost on L2 comes from calldata. To minimize this cost, Aave V3 uses slightly different L2 Contracts, on Arbitrum and Optimism, that compress the info passed to Pool methods.\n\nhttps://docs.aave.com/developers/getting-started/l2-optimization\n\nHowever, the AaveV3 library does not use these optimization functions when deploying on L2. Instead, it uses the default functions in the pool contracts that take uncompressed arguments.\n\n## Impact\n\nUsing the default functions may result in higher transaction cost on L2 and deviate from the best practice of Aave V3 recommendation.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/integration/lib/AaveV3.sol#L131\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/integration/lib/AaveV3.sol#L207\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/integration/lib/AaveV3.sol#L281\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/integration/lib/AaveV3.sol#L404\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse the L2 optimization functions when interacting with the L2 pool contracts.\nhttps://docs.aave.com/developers/getting-started/l2-optimization/l2pool","decidedSeverity":"medium","decidedDuplication":"Optimism and Arbitrum use an L2 optimized version of Pool.sol making AaveV3.sol completely incompatible"},{"file":"134.md","watson":{"name":"ast3ros","days":63,"is_team":false,"payout":8659.62,"score":77.1423447599,"senior":true},"severity":"medium","title":"AaveV3 Reward cannot be claimed by SetToken","markdown":"ast3ros\n\nmedium\n\n# AaveV3 Reward cannot be claimed by SetToken\n\n## Summary\n\nThe SetToken may receive reward tokens when interacting with the Aave V3 pool (e.g., depositing). However, the SetToken cannot claim these rewards because the AaveV3 library does not have a function to do so.\n\n## Vulnerability Detail\n\nAave Protocol V3 offers option to have multiple rewards per token. It is possible for an asset listing to enable additional incentive rewards denominated in their protocol tokens. \nFor details please see: https://github.com/aave/docs-v3/blob/main/whats-new/multiple-rewards-and-claim.md\n\nThe SetToken contract interacts frequently with the Aave V3 pool (deposit/borrow/repay/withdraw) by using the AaveV3LeverageModuleV3. In case the SetToken receives rewards, it cannot claim them because the AaveV3 library does not have a function to call the `rewardsController.claimRewardsToSelf` function.\n\n## Impact\n\nThe rewards are stuck in the rewardsController of Aave V3.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/integration/lib/AaveV3.sol#L31\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nImplement a function in the AaveV3 library that can call the `rewardsController.claimRewardsToSelf` function so that the SetToken can claim the rewards.","decidedSeverity":"false","decidedDuplication":"AaveV3 Reward cannot be claimed by SetToken"},{"file":"135.md","watson":{"name":"ast3ros","days":63,"is_team":false,"payout":8659.62,"score":77.1423447599,"senior":true},"severity":"medium","title":"BaseManagerV2 lacks interface to interact with module functions","markdown":"ast3ros\n\nmedium\n\n# BaseManagerV2 lacks interface to interact with module functions\n\n## Summary\n\nModules have functions that can only be invoked by the manager of the SetToken. However, if the manager is set to be the BaseManagerV2 contract, these functions become inaccessible because BaseManagerV2 does not have a corresponding interface to call them.\n\n## Vulnerability Detail\n\nThe AaveV3LeverageModule has functions such as `initialize`, `registerToModule`, `addCollateralAssets`, `removeCollateralAssets`, `addBorrowAssets`, and `removeBorrowAssets` that are restricted to the manager of the SetToken.\n\nHowever, if the manager is set to be the BaseManagerV2 contract, these functions cannot be invoked. This is because BaseManagerV2 does not have an interface to interact with these functions of the AaveV3LeverageModule.\n\nThe functionality of the module will be halted until the manager is changed to another address such as an EOA or a contract with sufficient functions to call those.\n\n## Impact\n\nThe lack of interface may affect the functionality and security of the modules such as AaveV3LeverageModule and the SetToken.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L485\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L552\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L598\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L607\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L627\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L637\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nImplement interfaces in BaseManagerV2 or an extension contract that can call these functions of the AaveV3LeverageModule. The same approach is already applied to the `setEModeCategory` function when it is implemented in the AaveV3LeverageStrategyExtension extension.","decidedSeverity":"false","decidedDuplication":"BaseManagerV2 lacks interface to interact with module functions"},{"file":"136.md","watson":{"name":"ast3ros","days":63,"is_team":false,"payout":8659.62,"score":77.1423447599,"senior":true},"severity":"medium","title":"Unbounded loops in AaveV3LeverageModule may cause DOS","markdown":"ast3ros\n\nmedium\n\n# Unbounded loops in AaveV3LeverageModule may cause DOS\n\n## Summary\n\nThe AaveV3LeverageModule allows the SetToken manager to add and have positions in any number of collateral and borrow tokens. However, this may cause some functions in the module to revert or fail due to unbounded loops that consume a lot of gas.\n\n## Vulnerability Detail\n\nThe AaveV3LeverageModule has functions such as `addCollateralAssets` and `addBorrowAssets` that enable the SetToken manager to add any number of collateral and borrow tokens.\n\n        function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) { \n            _addCollateralAssets(_setToken, _newCollateralAssets);\n        }\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L598-L600\n\n        function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {\n            _addBorrowAssets(_setToken, _newBorrowAssets);\n        }\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L627-L629\n\nHowever, there are some functions in the module that loop through the list of collateral and borrow tokens to perform certain actions. For example:\n\n- Sync: updates the state of all collateral and borrow positions\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L444\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L457\n\n- removeModule: unwinds all collateral and borrow positions before removing the module\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L521\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L530\n\nThese functions may revert or fail if the number of collateral and borrow tokens is too large. This is because they may use a lot of gas when there are a lot of users (especially on mainnet) or exceed the block gas limit. This may lead to a denial-of-service (DOS).\n\n## Impact\n\nThe unbounded loops may affect the functionality and security of the AaveV3LeverageModule and the SetToken. For example, if the `sync` function fails, it may disrupt the `issue` and `redeem` process of the SetToken since the `moduleIssueHook` and `moduleRedeemHook` call `sync` to update all position states.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L505-L506\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L598-L600\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L627-L629\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L444\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L457\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L521\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L530\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nLimit the number of collateral and borrow tokens that a SetToken can have positions on. The admin can set an upper bound for this number and enforce it in the `addCollateralAssets` and `addBorrowAssets` functions. Alternatively, refactor the functions that use loops to use batches or pagination instead.","decidedSeverity":"false","decidedDuplication":"Unbounded loops in AaveV3LeverageModule may cause DOS"},{"file":"137.md","watson":{"name":"ast3ros","days":63,"is_team":false,"payout":8659.62,"score":77.1423447599,"senior":true},"severity":"medium","title":"Disengage function does not prevent iterateRebalance from being called","markdown":"ast3ros\n\nmedium\n\n# Disengage function does not prevent iterateRebalance from being called\n\n## Summary\n\nThe operator can call the `disengage` function in the AaveLeverageStrategyExtension to unwind the leveraged position. However, this function does not clear the `twapLeverageRatio` state variable, which allows the `iterateRebalance` function to be called. If the extension is set up for anyone to call, anyone can call the iterateRebalance function to increase the leverage ratio and prevent the strategy from being shut down by the operator.\n\n## Vulnerability Detail\n\nThe `disengage` function in the `AaveLeverageStrategyExtension` allows the operator to unwind the leveraged position by repaying the debt and withdrawing the collateral.\n\n        function disengage(string memory _exchangeName) external onlyOperator {...}\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L412-L438\n\nThe design is described in the Natspec:\n        \n        If chunk rebalance size is above max borrow or max trade size, then operator must continue to call this function to complete repayment of loan. The function iterateRebalance will not work.\n\nHowever, if the strategy is in TWAP, the `disengage` function does not clear the `twapLeverageRatio` state variable. This means that the `iterateRebalance` function can still be called if certain conditions are met.\n\nIn the scenario, after calling the `disengage` function, if the current leverage ratio is between 1 and `minLeverageRatio`, the `iterateRebalance` function can be called multiple times to bring the leverage ratio back to `minLeverageRatio`.\n\n        function _validateNormalRebalance(LeverageInfo memory _leverageInfo, uint256 _coolDown, uint256 _lastTradeTimestamp) internal view {\n            require(_leverageInfo.currentLeverageRatio < incentive.incentivizedLeverageRatio, \"Must be below incentivized leverage ratio\");\n            require(\n                block.timestamp.sub(_lastTradeTimestamp) > _coolDown\n                || _leverageInfo.currentLeverageRatio > methodology.maxLeverageRatio\n                || _leverageInfo.currentLeverageRatio < methodology.minLeverageRatio, // @audit if current leverage ratio < min leverage ratio, then the iterateRebalance can be call without cooldown.\n                \"Cooldown not elapsed or not valid leverage ratio\"\n            );\n        }\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L970-L978\n\nIf the extension is set up for anyone to call (when anyoneCallable = true), anyone can call the `iterateRebalance` function to increase the leverage ratio and stop the strategy from being shut down by the operator.\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L338\n\n## Impact\n\nThe iterateRebalance function can still be called when disengaging, which violates the design. In case the extension is set up for anyone to call, it may prevent disengaging.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L412-L438\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L970-L978\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L338\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nSet a state variable `disengaging = true` when operator disengages, and check if `disengaging = true` then do not allow to call `rebalance` or `iterateRebalance`.","decidedSeverity":"false","decidedDuplication":"Disengage function does not prevent iterateRebalance from being called"},{"file":"138.md","watson":{"name":"ast3ros","days":63,"is_team":false,"payout":8659.62,"score":77.1423447599,"senior":true},"severity":"medium","title":"Methodology settings can be changed by operator instead of methodologist","markdown":"ast3ros\n\nmedium\n\n# Methodology settings can be changed by operator instead of methodologist\n\n## Summary\n\nThe AaveV3LeverageModule contract allows the operator to change the methodology settings that define the token strategy. However, according to the role description, this should be done by the methodologist.\n\n## Vulnerability Detail\n\nIn the role description in audit channel, operator and methodologist roles are defined as:\n\n        - Operator:\n        The party that is responsible for \"day to day management\" of the set token. Often this means ensuring that the set token is regularily rebalanced to adhere to a certain strategy.\n\n        - Methodologist:\n        Sets and controls the parameter that define a set tokens strategy and put guardrails on the actions of the Operator.\n        While those two roles could be held by the same party, for some of our products we will have an external partner act as Methodologist.\n\nHowever, in the AaveV3LeverageModule contract, the function to set methodology `setMethodologySettings` can only be called by the operator instead of the methodologist.\n\n        function setMethodologySettings(MethodologySettings memory _newMethodologySettings) external onlyOperator noRebalanceInProgress {\n            methodology = _newMethodologySettings;\n\n            _validateNonExchangeSettings(methodology, execution, incentive);\n\n            emit MethodologySettingsUpdated(\n                methodology.targetLeverageRatio,\n                methodology.minLeverageRatio,\n                methodology.maxLeverageRatio,\n                methodology.recenteringSpeed,\n                methodology.rebalanceInterval\n            );\n        }\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L446-L458\n\nThis means that the operator can change the parameters that define the token strategy without any input or restriction from the methodologist.\n\n## Impact\n\nThe operator has more authority than defined in the role and does not have any guardrails from the methodologist.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L446-L458\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange the modifier from `onlyOperator` to `onlyMethodologist` in the `setMethodologySettings` function.\n\n```diff\n-        function setMethodologySettings(MethodologySettings memory _newMethodologySettings) external onlyOperator noRebalanceInProgress {\n+        function setMethodologySettings(MethodologySettings memory _newMethodologySettings) external onlyMethodologist noRebalanceInProgress {\n```","decidedSeverity":"false","decidedDuplication":"Methodology settings can be changed by operator instead of methodologist"},{"file":"139.md","watson":{"name":"ast3ros","days":63,"is_team":false,"payout":8659.62,"score":77.1423447599,"senior":true},"severity":"medium","title":"Using transfer may cause function revert","markdown":"ast3ros\n\nmedium\n\n# Using transfer may cause function revert\n\n## Summary\n\nThe _transferEtherRewardToCaller function uses msg.sender.transfer to transfer ETH to the caller. However, this may cause the function to revert in the future due to gas cost changes.\n\n## Vulnerability Detail\n\nThe `_transferEtherRewardToCaller` function in the AaveLeverageStrategyExtension contract transfers ETH to the caller as a reward for rebalancing.\n\n        function _transferEtherRewardToCaller(uint256 _etherReward) internal returns(uint256) {\n            uint256 etherToTransfer = _etherReward < address(this).balance ? _etherReward : address(this).balance;\n\n            msg.sender.transfer(etherToTransfer); \n\n            return etherToTransfer;\n        }\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1218-L1224\n\nHowever, the transfer function should be avoided because it only forwards 2300 gas and gas costs can and will change in the future. If gas costs are subject to change, then smart contracts can’t depend on any fixed gas costs.\n\nFor more details please see this link: https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/\n\n## Impact\n\nThe `transfer` function may revert and prevent the reward from being transferred.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1218-L1224\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nStop using transfer and switch to using call instead. For example:\n\n```diff\n- msg.sender.transfer(etherToTransfer);\n+ (bool success, ) = msg.sender.call{value: etherToTransfer}(\"\");\n+ require(success, \"Transfer failed\");\n```","decidedSeverity":"false","decidedDuplication":"Using transfer may cause function revert"},{"file":"140.md","watson":{"name":"ast3ros","days":63,"is_team":false,"payout":8659.62,"score":77.1423447599,"senior":true},"severity":"medium","title":"The mutualUpgrade hash does not expire or allow cancellation by signer","markdown":"ast3ros\n\nmedium\n\n# The mutualUpgrade hash does not expire or allow cancellation by signer\n\n## Summary\n\nThe mutualUpgrade modifier allows two signers to approve a transaction by setting the mutualUpgrades hash to true. However, if one signer approves and the other does not, the old approval is not deleted and could be used in the future without the consent of the first signer.\n\n## Vulnerability Detail\n\nWhen a signer wants to approve a transaction, it calls a function with the `mutualUpgrade` modifier. This modifier checks if the other signer has already approved the same transaction by hashing the msg.data and the non-caller address. If not, it sets the mutualUpgrades hash to true for the msg.data and the caller address.\n\n        modifier mutualUpgrade(address _signerOne, address _signerTwo) {\n            require(\n                msg.sender == _signerOne || msg.sender == _signerTwo,\n                \"Must be authorized address\"\n            );\n\n            address nonCaller = _getNonCaller(_signerOne, _signerTwo);\n\n            // The upgrade hash is defined by the hash of the transaction call data and sender of msg,\n            // which uniquely identifies the function, arguments, and sender.\n            bytes32 expectedHash = keccak256(abi.encodePacked(msg.data, nonCaller));\n\n            if (!mutualUpgrades[expectedHash]) {\n                bytes32 newHash = keccak256(abi.encodePacked(msg.data, msg.sender));\n\n                mutualUpgrades[newHash] = true;\n\n                emit MutualUpgradeRegistered(newHash);\n\n                return;\n            }\n\n            delete mutualUpgrades[expectedHash];\n\n            // Run the rest of the upgrades\n            _;\n        }\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/lib/MutualUpgrade.sol#L41-L67\n\nHowever, in case there is a disagreement and only one party approves, for example signerOne approves but signerTwo does not. After that both agree to a different transaction and approve it again, the previous approval from signerOne is still valid and cannot be cancelled or invalidated. That approval can be used later by signerTwo without signerOne’s awareness.\n\n## Impact\n\nAn unused approval can be used by another signer to execute a transaction without the knowledge or consent of the original approver. This breaks the mutual signing requirement of the mutualUpgrade modifier.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/lib/MutualUpgrade.sol#L41-L67\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd an expiry date for each approval or let the signer cancel their approval.","decidedSeverity":"false","decidedDuplication":"The mutualUpgrade hash does not expire or allow cancellation by signer"},{"file":"141.md","watson":{"name":"ast3ros","days":63,"is_team":false,"payout":8659.62,"score":77.1423447599,"senior":true},"severity":"medium","title":"Protected module can be called by any existing extension before being protected","markdown":"ast3ros\n\nmedium\n\n# Protected module can be called by any existing extension before being protected\n\n## Summary\n\nA protected module is supposed to only allow an authorized extension to call it. However, there is a gap between adding a module and protecting it, which can be exploited by any existing extension.\n\n## Vulnerability Detail\n\nWhen the operator wants to add a protected module, he first calls `BaseManagerV2.addModule` then calls `BaseManagerV2.protectModule`.\n\n        function addModule(address _module) external upgradesPermitted onlyOperator {\n            setToken.addModule(_module);\n        }\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/manager/BaseManagerV2.sol#L327-L329\n\n\n        function protectModule(address _module, address[] memory _extensions)\n            external\n            upgradesPermitted\n            onlyOperator\n        {\n            require(setToken.getModules().contains(_module), \"Module not added yet\");\n            _protectModule(_module, _extensions);\n\n            emit ModuleProtected(_module, _extensions);\n        }\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/manager/BaseManagerV2.sol#L378-L387\n\nHowever, these are two separate transactions. Therefore, before the `protectModule` transaction is executed, any existing extension can call the newly added module and act as the BaseManager.\n\n        function interactManager(address _module, bytes memory _data) external onlyExtension {         \n            require(initialized, \"Manager not initialized\");\n            require(_module != address(setToken), \"Extensions cannot call SetToken\");\n            require(_senderAuthorizedForModule(_module, msg.sender), \"Extension not authorized for module\");\n\n            // Invoke call to module, assume value will always be 0\n            _module.functionCallWithValue(_data, 0);\n        }\n\n\n        function _senderAuthorizedForModule(address _module, address _sender) internal view returns (bool) {\n            if (protectedModules[_module].isProtected) { // @audit An extension can front-run and call a modules before it is protected.\n                return protectedModules[_module].authorizedExtensions[_sender];\n            }\n\n            return true;\n        }\n\nThe extension contracts expose external functions that can be called by anyone. Therefore, a user could front-run the protectModule function and call an extension to invoke the module. The protection is bypassed.\n\n## Impact\n\nThe protection in the module can be bypassed by front-running and expose it to unauthorized extensions.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/manager/BaseManagerV2.sol#L327-L329\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/manager/BaseManagerV2.sol#L378-L387\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nSeparate the addModule function into two cases: add protected module and add unprotected module. In the add protected module case, add the module and protect it in the same function, so it is an atomic transaction. For example:\n\n```javascript\n    function addAndProtectModule(address _module, address[] memory _extensions) external upgradesPermitted onlyOperator {\n        setToken.addModule(_module);\n        _protectModule(_module, _extensions);\n\n        emit ModuleAddedAndProtected(_module, _extensions);\n    }\n```","decidedSeverity":"false","decidedDuplication":"Protected module can be called by any existing extension before being protected"},{"file":"142.md","watson":{"name":"Saeedalipoor01988"},"severity":"medium","title":"Calculating Protocol Fee is susceptible to precision loss due to division before multiplication","markdown":"Saeedalipoor01988\n\nmedium\n\n# Calculating Protocol Fee is susceptible to precision loss due to division before multiplication\n\n## Summary\nProtocol Fee may be lost (0) due to division before multiplication precision issues.\n\n## Vulnerability Detail\nThe [StreamingFeeModule.sol.accrueFee function](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/StreamingFeeModule.sol#L94) calculates the Protocol Fee by first [dividing ( fee * totalSupply ) by ScaleFactor : (10e18) - fee](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/StreamingFeeModule.sol#L240) to earn _feeQuantity and then [multiplying _feeQuantity by protocolFee](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/StreamingFeeModule.sol#L256). If fee * totalSupply is small enough and ScaleFactor (10e18) - fee is large enough, the division may result in a value of 0, resulting in the Protocol Fee becoming 0.\n\n## Impact\nprotocol Fee Recipient may not receive fee due to precision loss.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/StreamingFeeModule.sol#L94\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/StreamingFeeModule.sol#L224\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/StreamingFeeModule.sol#L256\n\n## Tool used\nManual Review\n\n## Recommendation\nrecommend avoid division before multiplication and always perform division operation at last.","decidedSeverity":"medium","decidedDuplication":"division before multiplication may result in truncation of result"},{"file":"143.md","watson":{"name":"Saeedalipoor01988"},"severity":"medium","title":"Lack of check the data returned from getReserveConfigurationData function in AAVE3","markdown":"Saeedalipoor01988\n\nmedium\n\n# Lack of check the data returned from getReserveConfigurationData function in AAVE3\n\n## Summary\nLack of check of the data returned from [AaveProtocolDataProvider.getReserveConfigurationData function](https://github.com/aave/aave-v3-core/blob/master/contracts/misc/AaveProtocolDataProvider.sol#L83) in the [strategy.aaveProtocolDataProvider.getReserveConfigurationData function](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1098).\n\n## Vulnerability Detail\n```solidity\n  function getReserveConfigurationData(\n    address asset\n  )\n    external\n    view\n    override\n    returns (\n      uint256 decimals,\n      uint256 ltv,\n      uint256 liquidationThreshold,\n      uint256 liquidationBonus,\n      uint256 reserveFactor,\n      bool usageAsCollateralEnabled,\n      bool borrowingEnabled,\n      bool stableBorrowRateEnabled,\n      bool isActive,\n      bool isFrozen\n    )\n```\n\nThe above code is the getReserveConfigurationData function that returns data related to asset reserve configuration. the AaveLeverageStrategyExtension.sol._calculateMaxBorrowCollateral() function is using the above function to calculate the max borrow / repay the amount allowed in base units for lever / delever.\n\n```solidity\n// Retrieve collateral factor and liquidation threshold for the collateral asset in precise units (1e16 = 1%)\n        ( , uint256 maxLtvRaw, uint256 liquidationThresholdRaw, , , , , , ,) = strategy.aaveProtocolDataProvider.getReserveConfigurationData(address(strategy.collateralAsset));\n```\n\nAfter getting the maxLtvRaw value and liquidationThresholdRaw value from AaveProtocolDataProvider.getReserveConfigurationData function, there is no check whether these values are zero or not. these values for USDT are 0 and for AAVE token are not.\n\n```solidity\nUSDT data :\n  decimals   uint256 :  6\n  ltv   uint256 :  0\n  liquidationThreshold   uint256 :  0\n  liquidationBonus   uint256 :  0\n  reserveFactor   uint256 :  1000\n  usageAsCollateralEnabled   bool :  false\n  borrowingEnabled   bool :  true\n  stableBorrowRateEnabled   bool :  false\n  **isActive   bool :  true\n  isFrozen   bool :  false**\n```\n\n```solidity\nAAVE data:\n  decimals   uint256 :  18\n  ltv   uint256 :  6600\n  liquidationThreshold   uint256 :  7300\n  liquidationBonus   uint256 :  10750\n  reserveFactor   uint256 :  0\n  usageAsCollateralEnabled   bool :  true\n  borrowingEnabled   bool :  false\n  stableBorrowRateEnabled   bool :  false\n  **isActive   bool :  true\n  isFrozen   bool :  false**\n```\n\nThis issue is important when the [setManager function](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/SetToken.sol#L420) change manager to a null address and there is no control over the functions of adding or removing collateral / Borrow assets.\n\n\n\n```solidity\n    /**\n     * MANAGER ONLY. Changes manager; **We allow null addresses** in case the manager wishes to wind down the SetToken.\n     * Modules may rely on the manager state, so only changable when unlocked\n     */\n    function setManager(address _manager) external onlyManager {\n        require(!isLocked, \"Only when unlocked\");\n        address oldManager = manager;\n        manager = _manager;\n\n        emit ManagerEdited(_manager, oldManager);\n    }\n```\n\n## Impact\nUnderflow revert in AaveLeverageStrategyExtension.sol._calculateMaxBorrowCollateral() function could disable the functionality of the protocol.\n\n## Code Snippet\nhttps://github.com/aave/aave-v3-core/blob/master/contracts/misc/AaveProtocolDataProvider.sol#L83\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1098\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/SetToken.sol#L417\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L597\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L607\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L627\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L637\n\n## Tool used\nManual Review\n\n## Recommendation\ncheck the data returned from AaveProtocolDataProvider.getReserveConfigurationData function.","decidedSeverity":"false","decidedDuplication":"Lack of check the data returned from getReserveConfigurationData function in AAVE3"},{"file":"144.md","watson":{"name":"Auditwolf","days":14,"is_team":false,"payout":248.39,"score":4.731352302,"senior":false},"severity":"high","title":"Components delta updates with a higher value  than the actual received components in functions addliquiditysingleasset and removeliquiditysingleasset.","markdown":"Auditwolf\n\nhigh\n\n# Components delta updates with a higher value  than the actual received components in functions addliquiditysingleasset and removeliquiditysingleasset.\n\n## Summary\n\n  When performing liquidity adjustments for single assets ( adding or removing liquidity ), the last step is updating  the components delta with the value of components received. This value is determined by calling  _updatecomponentsposition_  function, which sets  the components received  to the value obtained by subtracting the _preactioncomponentsbalance_ from the current component balances. However, an issue arises when utilizing the _getactioninfosingleasset_  function during the addition or removal of liquidity for a single asset, as it does not provide the necessary pre-action component  balance. Therefore, the components received will equate to the current components balance (i.e., the total balance after adding or removing liquidity for the single asset). As a result, the components delta ends up being updated with more components than which were actually received.\n\n## Vulnerability Detail\n\n function _updateComponentPositions(ActionInfo memory _actionInfo) internal returns(int256[] memory) {\n        int256[] memory componentsReceived = new int256[](_actionInfo.components.length);\n\n        for (uint256 i = 0; i < _actionInfo.components.length; i++) {\n\n            (uint256 currentComponentBalance,,) = _actionInfo.setToken.calculateAndEditDefaultPosition(\n                _actionInfo.components[i],\n                _actionInfo.totalSupply,\n                _actionInfo.preActionComponentBalances[i]\n            );\n\n            componentsReceived[i] = currentComponentBalance.toInt256()\n                                        .sub(_actionInfo.preActionComponentBalances[i].toInt256());\n        }\n\n        return componentsReceived;\n    }\nAs shown this function returns the components received which is obtained by subtracting the _preactioncomponentbalance_ from the current component balance. however the _getactioninfosingleasset_  function does not determine the _preactioncomponentsbalance_  hence this function will return the current component balance and not the components received ( when adding or removing liquidity for a single asset ).\n\nNote : this function works correctly with functions _addliquidity_ and _removeliquidity_  but not with _addliquiditysingleasset_ and _removeliquiditysingleasset_.\n\n## Impact\n\nComponents delta will be updated with a higher value than the actual received components in  functions _addliquiditysingleasset_  and  _removeliquiditysingleasset_ .\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AmmModule.sol#L155C4-L194C1\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AmmModule.sol#L258C4-L297C1\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AmmModule.sol#L522C3-L539C1\n\n## Tool used\n\nManual Review\n\n## Recommendation\n","decidedSeverity":"false","decidedDuplication":"Components delta updates with a higher value  than the actual received components in functions addliquiditysingleasset and removeliquiditysingleasset."},{"file":"145.md","watson":{"name":"Auditwolf","days":14,"is_team":false,"payout":248.39,"score":4.731352302,"senior":false},"severity":"high","title":"Liquidity delta is not correctly updated in functions addliquiditysingleasset  and  removeliquiditysingleasset.","markdown":"Auditwolf\n\nhigh\n\n# Liquidity delta is not correctly updated in functions addliquiditysingleasset  and  removeliquiditysingleasset.\n\n## Summary\nTo set the liquidity delta in both functions _addliquiditysingleasset_ and _removeliquiditysingleasset_  , function _updateliquiditytokenpositions_ is called. This function returns a value obtained by subtracting pre-action liquidity balance from the current liquidity token balance. However , since function _getctioninfosingleasset_ which is utilized during the addition or  removal of liquidity does not provide the pre-action liquidity balance  ,  liquidity delta will be set to the current liquidity token balance ( i.e balance after _addliquiditysingleasset_  or _removeliquiditysingleasset_ ) .\n\n## Vulnerability Detail\n\n    function _updateLiquidityTokenPositions(ActionInfo memory _actionInfo) internal returns(int256) {\n\n        (uint256 currentLiquidityTokenBalance,,) = _actionInfo.setToken.coalculateAndEditDefaultPositin(\n            _actionInfo.liquidityToken,\n            _actionInfo.totalSupply,\n            _actionInfo.preActionLiquidityTokenBalance\n        );\n\n        return currentLiquidityTokenBalance.toInt256().sub(_actionInfo.preActionLiquidityTokenBalance.toInt256());\n    }\nAs shown above this function returns a value obtained after subtracting pre-action liquidity token balance from the current liquidity token balance . pre action liquidity balance is supposed to be set in function _getactioninfosingleasset_  which is not the case meaning the liquidity delta in functions _addliquiditysingleasset_ and _removeliquiditysingleasset_  will be set to a higher value than the correct one.\n\n## Impact\nIt will  lead to incorrect accounting in the system.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AmmModule.sol#L155C4-L194C1\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AmmModule.sol#L258C4-L296C6\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AmmModule.sol#L540C1-L550C1\n\n## Tool used\n\nManual Review\n\n## Recommendation\n","decidedSeverity":"false","decidedDuplication":"Liquidity delta is not correctly updated in functions addliquiditysingleasset  and  removeliquiditysingleasset."},{"file":"146.md","watson":{"name":"Cryptor","days":26,"is_team":false,"payout":47.1,"score":0.864264114,"senior":false},"severity":"medium","title":"Cannot rebalance leverage ratio during grace period","markdown":"Cryptor\n\nmedium\n\n# Cannot rebalance leverage ratio during grace period\n\n## Summary\nRebalancing leverage ratio may not work if an L2 sequencer goes down \n\n## Vulnerability Detail\nIn Aave, if an L2 sequencer goes down and then goes back up, there is a grace period where borrowing and liquidations are disabled. This is to allow users to pay back bad debt. \n\n<img width=\"590\" alt=\"image\" src=\"https://github.com/sherlock-audit/2023-05-Index-JJtheAndroid/assets/29849840/f5a79f1a-5daf-4f3a-9333-cbde2c86efe4\">\n\n\nThis can cause functions such as balance, iteraterebalance to revert if the methodology calls for the module to lever up and borrow funds from Aave. \n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L832-L852\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L317-L320\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L352-L354\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L848\n\n\n\n## Impact\nThe manager may not be able to rebalance the leverage ratio to his target leverage ratio during a grace period after the sequencer goes down \n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L317-L320\n\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCheck if the grace period has passed before calling the function engage or disengage from Aave. This will allow the manager to better control the target leverage ratio in the event of a sequencer going down. The following function would be useful here\n https://github.com/aave/aave-v3-core/blob/29ff9b9f89af7cd8255231bc5faf26c3ce0fb7ce/contracts/protocol/configuration/PriceOracleSentinel.sol#L67-L74\n","decidedSeverity":"false","decidedDuplication":"Cannot rebalance leverage ratio during grace period"},{"file":"147.md","watson":{"name":"tallo","days":34,"is_team":false,"payout":104.47,"score":0.8373650399,"senior":false},"severity":"medium","title":"```StreamingFeeModule#accrueFee``` can be DOS'd under certain conditions","markdown":"tallo\n\nmedium\n\n# ```StreamingFeeModule#accrueFee``` can be DOS'd under certain conditions\n\n## Summary\nThe ```StreamingFeeModule#accrueFee``` function can permanently revert and all fee important StreamingFeeModule.sol functionality to be locked.  This happens when enough time passes without ```accrueFee``` being called.\n## Vulnerability Detail\nThe issue happens when ```accrueFee``` calls ```_calculateStreamingFee```\n\n```solidity\n    function accrueFee(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {\n        uint256 managerFee;\n        uint256 protocolFee;\n\n        if (_streamingFeePercentage(_setToken) > 0) {\n            uint256 inflationFeePercentage = _calculateStreamingFee(_setToken);\n\n            uint256 feeQuantity = _calculateStreamingFeeInflation(_setToken, inflationFeePercentage);\n```\n```_calculateStreamingFee``` first calculates the time elapsed since the fee was last updated; which initially happens when the contract is first initialized and also when ```accrueFee``` is called. This value is then multiplied by the ```streamingFeePercentage``` and divided by the amount of seconds in a year in order to get the proportion of the fee that is to be paid. For instance, if only half a year passed then only half the ```_streamingFeePercentage``` value will be calculated. It is possible for this proportion to be greater then 1 if more than a year has passed since the last time ```_lastStreamingFeeTimstamp``` was updated, and that is where the issue lies.\n\n```solidity\n    function _calculateStreamingFee(ISetToken _setToken) internal view returns(uint256) {\n        uint256 timeSinceLastFee = block.timestamp.sub(_lastStreamingFeeTimestamp(_setToken));\n\n        // Streaming fee is streaming fee times years since last fee\n        return timeSinceLastFee.mul(_streamingFeePercentage(_setToken)).div(ONE_YEAR_IN_SECONDS);\n    }\n```\nWhen ```_calculateStreamingFeeInflation``` is called with the previously calculated value from ```_calculateStreamingFee``` its possible for it to permanently revert when calculating the divisor ```b``` due to a subtraction underflow. This can happen if the ```_feePercentage``` or ```timeSinceLastFee*_streamingFeePercentage/ONE_YEAR_IN_SECONDS``` is greater than ```PreciseUnitMath.preciseUnit``` which is ```10e18```.  At a ```_streamingFeePercentage``` of 100% (10e18) this would take 1 year and at 33% (```3.33e18```) this would take 3 years without being updated.\n\n```solidity\nlibrary PreciseUnitMath {\n    uint256 constant internal PRECISE_UNIT = 10 ** 18;\n\n    function preciseUnit() internal pure returns (uint256) {\n        return PRECISE_UNIT;\n    }\n}\n\n    function _calculateStreamingFeeInflation(\n        ISetToken _setToken,\n        uint256 _feePercentage\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 totalSupply = _setToken.totalSupply();\n\n        uint256 a = _feePercentage.mul(totalSupply);\n\n        //@audit here it will revert if _feePercentage > preciseUnit which equals 10e18\n        uint256 b = PreciseUnitMath.preciseUnit().sub(_feePercentage);\n\n        return a.div(b);\n    }\n```\n```solidity\n    function initialize(\n        ISetToken _setToken,\n        FeeState memory _settings\n    )\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        require(_settings.feeRecipient != address(0), \"Fee Recipient must be non-zero address.\");\n        require(_settings.maxStreamingFeePercentage < PreciseUnitMath.preciseUnit(), \"Max fee must be < 100%.\");\n        require(_settings.streamingFeePercentage <= _settings.maxStreamingFeePercentage, \"Fee must be <= max.\");\n\n        _settings.lastStreamingFeeTimestamp = block.timestamp;\n\n        feeStates[_setToken] = _settings;\n        _setToken.initializeModule();\n    }\n```\n\n\n## Impact\nAll main fee accrual functionality in ```StreamingFeeModule``` will be frozen. Any attempt to call ```accrueFee``` and ```updateStreamingFee``` will result in a revert.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/StreamingFeeModule.sol#L86\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/StreamingFeeModule.sol#L203\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/StreamingFeeModule.sol#L224\n## Tool used\n\nManual Review\n\n## Recommendation\nInside ```_calculateStreamingFeeInflation```, consider setting a cap on the _feePercentage variable so it doesnt cause a revert due to underflow ","decidedSeverity":"false","decidedDuplication":"```StreamingFeeModule#accrueFee``` can be DOS'd under certain conditions"},{"file":"148.md","watson":{"name":"Cryptor","days":26,"is_team":false,"payout":47.1,"score":0.864264114,"senior":false},"severity":"medium","title":"No validation check if Slippage Tolerance is set to 0","markdown":"Cryptor\n\nmedium\n\n# No validation check if Slippage Tolerance is set to 0\n\n## Summary\n\nThe function _validateNonExchangeSettings has no validation check if slippage tolerance is set to 0. This can results in MEV attacks like sandwich and front running attacks\n\n## Vulnerability Detail\n\nThe function _validateNonExchangeSettings has a requirement that slippage tolerance must be lower than 10^18 shown here\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L936-L939\n\nHowever, there is no check if slippage tolerance is set to 0. This would be very dangerous as it would leave the set token contract vulnerable to MEV attacks\n\n\n\n## Impact\nNo validation check means that a set token contract can be vulnerable to slippage, causing a loss of funds\n\n\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L936-L939\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd a check to make sure that Slippage tolerance is > 0 in the function _validateNonExchangeSettings","decidedSeverity":"medium","decidedDuplication":"`AaveLeverageStrategyExtension.sol` does not allow user to specify slippage parameter during rebalance or ripcord"},{"file":"149.md","watson":{"name":"Saeedalipoor01988"},"severity":"medium","title":"ONE_YEAR_IN_SECONDS is hardcoded to wrong number","markdown":"Saeedalipoor01988\n\nmedium\n\n# ONE_YEAR_IN_SECONDS is hardcoded to wrong number\n\n## Summary\nIn the [StreamingFeeModule.sol](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/StreamingFeeModule.sol#L67), ONE_YEAR_IN_SECONDS is hardcoded to 365.25 days.\n\n## Vulnerability Detail\n`    uint256 private constant ONE_YEAR_IN_SECONDS = 365.25 days;`\n\nIn the [StreamingFeeModule.sol](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/StreamingFeeModule.sol#L67), ONE_YEAR_IN_SECONDS is hardcoded to 365.25 days.\n\n\nBased on the [usage of Time in Blockchains](https://github.com/sambacha/blockchain-time), If this value is 1 year in seconds, then it should be 365 days or 365.24 days, and for the leap year is 366 days.\n\n## Impact\nCalculating the streaming fee will return the wrong number.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/StreamingFeeModule.sol#L67\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/StreamingFeeModule.sol#L203\n\n## Tool used\nManual Review\n\n## Recommendation\nUse 365 days or 365.24 days.","decidedSeverity":"false","decidedDuplication":"ONE_YEAR_IN_SECONDS is hardcoded to wrong number"},{"file":"150.md","watson":{"name":"Bauchibred","days":8,"is_team":false,"payout":24.18,"score":0.4085706709,"senior":false},"severity":"medium","title":"AaveLeverageStrategyExtension: Risk of Overflow in `_createActionInfo()` due to High underlyingDecimals","markdown":"Bauchibred\n\nmedium\n\n# AaveLeverageStrategyExtension: Risk of Overflow in `_createActionInfo()` due to High underlyingDecimals\n\n\n## Summary\n\nThe AaveLeverageStrategyExtension contract has a potential overflow risk due to an assumption that `underlyingDecimals` will not exceed 24. However, if `underlyingDecimals` are above 24, the `_createActionInfo()` function will cause an overflow.\n\n## Vulnerability Detail\n\nThe contract makes some hardcoded assumptions about the number of feed decimals (as 8) and also `underlyingDecimals` while performing normalization calculations in the `_createActionInfo()` function.\nThis assumption should be safe for certain cases, for example WETH is 18 decimals and the ETH/USD chainlink is 8 decimals, but may cause an overflow (and a revert) for the general case when the `underlyingDecimals > 24`, rendering the query from the orracle useless in these cases\n\nTake a look at [createActionInfo()](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L884-L907)\n\n```solidity\n    /**\n     * Create the action info struct to be used in internal functions\n     *\n     * return ActionInfo                Struct containing data used by internal lever and delever functions\n     */\n    function _createActionInfo() internal view returns(ActionInfo memory) {\n        ActionInfo memory rebalanceInfo;\n\n// @audit would cause an overflow when underlyingDecimals is above 24\n        // Calculate prices from chainlink. Chainlink returns prices with 8 decimal places, but we need 36 - underlyingDecimals decimal places.\n        // This is so that when the underlying amount is multiplied by the received price, the collateral valuation is normalized to 36 decimals.\n        // To perform this adjustment, we multiply by 10^(36 - 8 - underlyingDecimals)\n        int256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\n        rebalanceInfo.collateralPrice = rawCollateralPrice.toUint256().mul(10 ** strategy.collateralDecimalAdjustment);\n        int256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer();\n        rebalanceInfo.borrowPrice = rawBorrowPrice.toUint256().mul(10 ** strategy.borrowDecimalAdjustment);\n\n        rebalanceInfo.collateralBalance = strategy.targetCollateralAToken.balanceOf(address(strategy.setToken));\n        rebalanceInfo.borrowBalance = strategy.targetBorrowDebtToken.balanceOf(address(strategy.setToken));\n        rebalanceInfo.collateralValue = rebalanceInfo.collateralPrice.preciseMul(rebalanceInfo.collateralBalance);\n        rebalanceInfo.borrowValue = rebalanceInfo.borrowPrice.preciseMul(rebalanceInfo.borrowBalance);\n        rebalanceInfo.setTotalSupply = strategy.setToken.totalSupply();\n\n        return rebalanceInfo;\n    }\n\n```\n\nIn this function, an overflow would occur when `underlyingDecimals` is above 24 due to the multiplication by `10^(36 - 8 - underlyingDecimals)`. This calculation works on the presumption that `underlyingDecimals` will not be above 24, an assumption that doesn't hold true in all cases.\n\nProof of Concept\n\nIf `underlyingDecimals > 24`, then the expression `36 - 8 - underlyingDecimals` will be negative, and due to Solidity's checked math, it will cause an overflow and a subsequent revert.\n\n## Impact\n\nAn overflow could disrupt operations of the functions that rely on the `_createActionInfo()` function.\n\n## Code Snippet\n\n[createActionInfo()](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L884-L907)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIt is recommended to include a check for `underlyingDecimals` being above 24 and adjust the calculations accordingly to avoid any potential overflow.\n","decidedSeverity":"false","decidedDuplication":"AaveLeverageStrategyExtension: Risk of Overflow in `_createActionInfo()` due to High underlyingDecimals"},{"file":"151.md","watson":{"name":"Bauchibred","days":8,"is_team":false,"payout":24.18,"score":0.4085706709,"senior":false},"severity":"medium","title":"AaveLeverageStrategyExtension: Break of contract's logic while updating non-exchange settings","markdown":"Bauchibred\n\nmedium\n\n# AaveLeverageStrategyExtension: Break of contract's logic while updating non-exchange settings\n\n## Summary\n\nIn the [AaveLeverageStrategyExtension.sol](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol) contract, there is a critical function named `_validateNonExchangeSettings()`, used for validating various methodology, execution, and incentive settings. This report entails the potential issues related to the handling of edge case scenarios due to the usage of non-strict inequalities in several requirements.\n\nNB: The function `_validateNonExchangeSettings()` is heavily utilized in different parts of the AaveLeverageStrategyExtension.sol contract such as `setMethodologySettings()`, `setExecutionSettings()`, `setIncentiveSettings()`, and even in the `constructor()`, exarcebating the issue\n\n## Vulnerability Detail\n\nTake a look at [\\_validateNonExchangeSettings()](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L909-L956)\n\n```solidity\n    /**\n     * Validate non-exchange settings in constructor and setters when updating.\n     */\n    function _validateNonExchangeSettings(\n        MethodologySettings memory _methodology,\n        ExecutionSettings memory _execution,\n        IncentiveSettings memory _incentive\n    )\n        internal\n        pure\n    {\n        require (\n            _methodology.minLeverageRatio <= _methodology.targetLeverageRatio && _methodology.minLeverageRatio > 0,\n            \"Must be valid min leverage\"\n        );\n        require (\n            _methodology.maxLeverageRatio >= _methodology.targetLeverageRatio,\n            \"Must be valid max leverage\"\n        );\n        require (\n            _methodology.recenteringSpeed <= PreciseUnitMath.preciseUnit() && _methodology.recenteringSpeed > 0,\n            \"Must be valid recentering speed\"\n        );\n        require (\n            _execution.unutilizedLeveragePercentage <= PreciseUnitMath.preciseUnit(),\n            \"Unutilized leverage must be <100%\"\n        );\n        require (\n            _execution.slippageTolerance <= PreciseUnitMath.preciseUnit(),\n            \"Slippage tolerance must be <100%\"\n        );\n        require (\n            _incentive.incentivizedSlippageTolerance <= PreciseUnitMath.preciseUnit(),\n            \"Incentivized slippage tolerance must be <100%\"\n        );\n        require (\n            _incentive.incentivizedLeverageRatio >= _methodology.maxLeverageRatio,\n            \"Incentivized leverage ratio must be > max leverage ratio\"\n        );\n        require (\n            _methodology.rebalanceInterval >= _execution.twapCooldownPeriod,\n            \"Rebalance interval must be greater than TWAP cooldown period\"\n        );\n        require (\n            _execution.twapCooldownPeriod >= _incentive.incentivizedTwapCooldownPeriod,\n            \"TWAP cooldown must be greater than incentivized TWAP cooldown\"\n        );\n    }\n```\n\nThis function checks certain conditions which are required to hold for the system to work properly. However, in the last six `require` statements of the function, the conditions are defined with a `<=` or `>=` operator, which might lead to unintended behavior in edge case scenarios.\n\nAs an example, consider the condition ` _execution.unutilizedLeveragePercentage <= PreciseUnitMath.preciseUnit()`. Here, the `unutilizedLeveragePercentage` could potentially be exactly equal to `PreciseUnitMath.preciseUnit()`. In the context of the contract, this would mean that 100% of the leverage is unutilized. This is not the intended behavior, as it would mean no leverage is being utilized at all, making the leveraging mechanism meaningless.\n\nSimilar logic applies to the other conditions. In each case, the system could potentially be pushed into an extreme state if the parameters are allowed to take their maximum or minimum values.\n\n## Impact\n\nIn edge cases, these conditions could lead to undesired system states, causing disruption in the normal operation of the contract. For instance, a 100% unutilized leverage or 100% slippage tolerance might not be the intended behavior. Also, an equal incentivized leverage ratio and maximum leverage ratio could also lead to unintended system states.\n\n## Code Snippet\n\n[\\_validateNonExchangeSettings()](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L909-L956)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIt would be advisable to adjust these conditions so that the inequality checks are strict (i.e., change `<=`/`>=` to `<`/`>`). This would prevent the system from reaching those edge states, which might cause undesired behavior. Change the [\\_validateNonExchangeSettings()](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L909-L956) to:\n\n```diff\n    /**\n     * Validate non-exchange settings in constructor and setters when updating.\n     */\n    function _validateNonExchangeSettings(\n        MethodologySettings memory _methodology,\n        ExecutionSettings memory _execution,\n        IncentiveSettings memory _incentive\n    )\n        internal\n        pure\n    {\n        require (\n            _methodology.minLeverageRatio <= _methodology.targetLeverageRatio && _methodology.minLeverageRatio > 0,\n            \"Must be valid min leverage\"\n        );\n        require (\n            _methodology.maxLeverageRatio >= _methodology.targetLeverageRatio,\n            \"Must be valid max leverage\"\n        );\n        require (\n            _methodology.recenteringSpeed <= PreciseUnitMath.preciseUnit() && _methodology.recenteringSpeed > 0,\n            \"Must be valid recentering speed\"\n        );\n        require (\n-            _execution.unutilizedLeveragePercentage <= PreciseUnitMath.preciseUnit(),\n+            _execution.unutilizedLeveragePercentage < PreciseUnitMath.preciseUnit(),\n            \"Unutilized leverage must be <100%\"\n        );\n        require (\n-            _execution.slippageTolerance <= PreciseUnitMath.preciseUnit(),\n+            _execution.slippageTolerance < PreciseUnitMath.preciseUnit(),\n            \"Slippage tolerance must be <100%\"\n        );\n        require (\n-            _incentive.incentivizedSlippageTolerance <= PreciseUnitMath.preciseUnit(),\n+            _incentive.incentivizedSlippageTolerance < PreciseUnitMath.preciseUnit(),\n            \"Incentivized slippage tolerance must be <100%\"\n        );\n        require (\n-            _incentive.incentivizedLeverageRatio >= _methodology.maxLeverageRatio,\n+            _incentive.incentivizedLeverageRatio > _methodology.maxLeverageRatio,\n            \"Incentivized leverage ratio must be > max leverage ratio\"\n        );\n        require (\n-         _methodology.rebalanceInterval >= _execution.twapCooldownPeriod,\n+         _methodology.rebalanceInterval > _execution.twapCooldownPeriod,\n            \"Rebalance interval must be greater than TWAP cooldown period\"\n        );\n        require (\n-           _execution.twapCooldownPeriod >= _incentive.incentivizedTwapCooldownPeriod,\n+          _execution.twapCooldownPeriod > _incentive.incentivizedTwapCooldownPeriod,\n            \"TWAP cooldown must be greater than incentivized TWAP cooldown\"\n        );\n    }\n```\n","decidedSeverity":"false","decidedDuplication":"AaveLeverageStrategyExtension: Break of contract's logic while updating non-exchange settings"},{"file":"152.md","watson":{"name":"Bauchibred","days":8,"is_team":false,"payout":24.18,"score":0.4085706709,"senior":false},"severity":"medium","title":"Elements could be located very far in the array resulting in DOS due to insufficient gas in `indexOf()`","markdown":"Bauchibred\n\nmedium\n\n# Elements could be located very far in the array resulting in DOS due to insufficient gas in `indexOf()`\n\n\n## Summary\n\nThe index protocol contains a function `indexOf()` which is utilized in numerous instances to search for the index of an address or a string within an array. A key concern regarding this is that a there is a potential for high gas costs due to inefficient looping structures, particularly when working with very large arrays, there by causing the attempted loop to find an element/address to fail due to the out of gas error\n\nNB: Protocol still loops over an array that's not limited in size in other functions like [AddressArrayUtils.hasDuplicate()](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/lib/AddressArrayUtils.sol#L64-L76), but this report would only focus on the issue regarding `indexOf()` since the underlying cause of the issue is the same\n\n## Vulnerability Detail\n\nIn the implemented `indexOf()` functions of protocol, there's a loop that goes through each element (string/address) of the array until it finds a match. This could lead to high gas costs if the array is large. Here's the relevant code:\n\nTake a look at this instance of the implementation from [StringArrayUtils.sol:](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/lib/StringArrayUtils.sol#L29-L43)\n\n```solidity\nfunction indexOf(string[] memory A, string memory a) internal pure returns (uint256, bool) {\n    uint256 length = A.length;\n    for (uint256 i = 0; i < length; i++) {\n        if (keccak256(bytes(A[i])) == keccak256(bytes(a))) {\n            return (i, true);\n        }\n    }\n    return (uint256(-1), false);\n}\n```\n\nNow take a look at the [indexOf](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/lib/AddressArrayUtils.sol#L32-L46) function from AddressArrayUtils.sol\n\n```solidity\n    function indexOf(address[] memory A, address a) internal pure returns (uint256, bool) {\n        uint256 length = A.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (A[i] == a) {\n                return (i, true);\n            }\n        }\n        return (uint256(-1), false);\n    }\n```\n\nThe issue lies in the fact that the functions do not limit the maximum length of the array that can be provided. Consequently, in a scenario where an array of large size is inputted, the iteration could run out of gas, causing the transaction to fail. This is particularly worrying in high load situations, as the size of the arrays may grow beyond control, potentially leading to denial-of-service-like situations due to the transactions running out of gas.\n\n### POC\n\nNB: The following contract demonstrates the potential issue, though being based on only the instance from [StringArrayUtils.sol](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/lib/StringArrayUtils.sol#L29-L43) the idea is the same for all `indexOf()/hasDuplicates()` implementations\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity >=0.6.10;\n\ncontract TestContract {\n    string[] public A;\n\n    constructor() public {\n        // Fill the array with a large number of elements\n        for (uint i = 0; i < 1111; i++) {\n            A.push(\"Test\");\n        }//@audit 1111 is just a special large number picked at random, the array length could be any large number and the test would still pass\n    }\n\n    function findElement(string memory a) public view returns (bool) {\n        uint256 length = A.length;\n        for (uint256 i = 0; i < length; i++) {\n            // Use keccak256 to compare strings\n            if (keccak256(bytes(A[i])) == keccak256(bytes(a))) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\n```\n\nIn the above contract, during the construction, the `A` Array is filled with a large number of elements (1111 in this case). The findElement function is designed to find an element in this array. When you call findElement with any argument, it will loop through the entire largeArray, comparing the keccak256 hash of each string in the array with the keccak256 hash of the input.\n\nFor an array of this size, the findElement function would fail due to exceeding the block gas limit. If the array was even larger, it could become practically impossible to call findElement successfully.\n\nNote that the usage of `keccak256()` exarcebates this issue for the case of [StringArrayUtils.sol](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/lib/StringArrayUtils.sol#L29-L43) and would mean that that of `AddressArrayUtils`would be able to take a larger array, but case is still present in both instances.\n\n## Impact\n\nGiven the lack of restrictions on the size of the input arrays, there's a high risk for any utilization of this code. If the size of the array is large enough to make a function call exceed the block gas limit, it could render the function unusable, leading to potential concerns about the functionality and reliability of the smart contract system.\n\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAs a best practice, consider introducing a limit to the size of the arrays that can be processed by the functions. Additionally, if possible, utilize data structures that have constant-time (O(1)) search complexity, such as mappings. If these recommendations are not feasible, consider providing mechanisms that can help deal with large arrays in a more efficient manner to avoid potential out-of-gas errors.\n","decidedSeverity":"false","decidedDuplication":"Elements could be located very far in the array resulting in DOS due to insufficient gas in `indexOf()`"},{"file":"153.md","watson":{"name":"Bauchibred","days":8,"is_team":false,"payout":24.18,"score":0.4085706709,"senior":false},"severity":"medium","title":"AaveLeverageStrategyExtension: Unnecessary Precision loss while delevering","markdown":"Bauchibred\n\nmedium\n\n# AaveLeverageStrategyExtension: Unnecessary Precision loss while delevering\n\n\n## Summary\n\nThe `_calculateMinRepayUnits()` function, used in the AaveLeverageStrategyExtension contract's `_delever()` function, leads to unnecessary precision loss due to the order of operations. Performing division amidst a sequence of multiplications could cause precision loss due to possible rounding errors.\n\n## Vulnerability Detail\n\nDuring the execution of the `_delever()` function, an operation in `_calculateMinRepayUnits()` multiplies `_collateralRebalanceUnits` with `_actionInfo.collateralPrice`, divides the result by `_actionInfo.borrowPrice`, and multiplies again by the difference between `PreciseUnitMath.preciseUnit()` and `_slippageTolerance`. This sequence causes an unnecessary precision loss since a division operation is performed before completing all multiplication operations.\n\nTake a look at both functions below to have a visual representation of the vulnerability\n\n[\\_delever()](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L772-L797)\n\n```solidity\n\n    /**\n     * Calculate delever units Invoke delever on AaveLeverageModule.\n     */\n    function _delever(\n        LeverageInfo memory _leverageInfo,\n        uint256 _chunkRebalanceNotional\n    )\n        internal\n    {\n        uint256 collateralRebalanceUnits = _chunkRebalanceNotional.preciseDiv(_leverageInfo.action.setTotalSupply);\n\n        uint256 minRepayUnits = _calculateMinRepayUnits(collateralRebalanceUnits, _leverageInfo.slippageTolerance, _leverageInfo.action);\n\n        bytes memory deleverCallData = abi.encodeWithSignature(\n            \"delever(address,address,address,uint256,uint256,string,bytes)\",\n            address(strategy.setToken),\n            strategy.collateralAsset,\n            strategy.borrowAsset,\n            collateralRebalanceUnits,\n            minRepayUnits,\n            _leverageInfo.exchangeName,\n            exchangeSettings[_leverageInfo.exchangeName].deleverExchangeData\n        );\n\n        invokeManager(address(strategy.leverageModule), deleverCallData);\n    }\n\n```\n\n[\\_calculateMinRepayUnits()](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1141-L1152)\n\n```solidity\n    /**\n     * Derive the min repay units from collateral units for delever. Units are calculated as target collateral rebalance units multiplied by slippage tolerance\n     * and pair price (collateral oracle price / borrow oracle price). Output is measured in borrow unit decimals.\n     *\n     * return uint256           Min position units to repay in borrow asset\n     */\n    function _calculateMinRepayUnits(uint256 _collateralRebalanceUnits, uint256 _slippageTolerance, ActionInfo memory _actionInfo) internal pure returns (uint256) {\n\n    //@audit the division should be done as the last execution\n        return _collateralRebalanceUnits\n            .preciseMul(_actionInfo.collateralPrice)\n            .preciseDiv(_actionInfo.borrowPrice)\n            .preciseMul(PreciseUnitMath.preciseUnit().sub(_slippageTolerance));\n    }\n```\n\n## Impact\n\nThis unnecessary precision loss might cause inaccuracies in the calculation of `minRepayUnits`, which could potentially affect the deleveraging process and the overall strategy operation.\n\n## Code Snippet\n\n[\\_delever()](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L772-L797)\n\n[\\_calculateMinRepayUnits()](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1141-L1152)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nTo address this issue, consider modifying the `_calculateMinRepayUnits()` function to perform all multiplication operations before division, like this:\n\n```solidity\n    return _collateralRebalanceUnits\n        .preciseMul(_actionInfo.collateralPrice)\n        .preciseMul(PreciseUnitMath.preciseUnit().sub(_slippageTolerance))\n        .preciseDiv(_actionInfo.borrowPrice);\n```\n\nThis adjustment minimizes precision loss by reducing the impact of rounding errors caused by division operations.\n","decidedSeverity":"false","decidedDuplication":"AaveLeverageStrategyExtension: Unnecessary Precision loss while delevering"},{"file":"154.md","watson":{"name":"Bauchibred","days":8,"is_team":false,"payout":24.18,"score":0.4085706709,"senior":false},"severity":"medium","title":"DebtIssuanceModuleV2.sol: Current Implementenation of `_resolveEquityPositions()` and `_resolveDebtPositions()` causes Potential issues when Dealing with Some Tokens","markdown":"Bauchibred\n\nmedium\n\n# DebtIssuanceModuleV2.sol: Current Implementenation of `_resolveEquityPositions()` and `_resolveDebtPositions()` causes Potential issues when Dealing with Some Tokens\n\n## Summary\n\nTwo functions, `_resolveEquityPositions()` and `_resolveDebtPositions()` in the updated [DebtIssuanceModuleV2.sol](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModule.sol#L4), usage of `invokeTransfer()` instead of the `strictInvokeTransfer()` method to transfer tokens is implemented. With this update unlike the old version of [DebtIssuanceModule.sol](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModule.sol#L137) where `strictInvokeTransfer()` was being used, now there is no protection against fee on transfer tokens and if these tokens are to be allowed inprotocol they could easily break the accounting logic.\n\n## Vulnerability Detail\n\nIn both functions, i.e\n[Take a look at DebtIssuanceModuleV2.sol#L251-L333](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModuleV2.sol#L251-L333)\n\n```solidity\n    function _resolveEquityPositions(\n        ISetToken _setToken,\n        uint256 _quantity,\n        address _to,\n        bool _isIssue,\n        address[] memory _components,\n        uint256[] memory _componentEquityQuantities,\n        uint256 _initialSetSupply,\n        uint256 _finalSetSupply\n    )\n        internal\n    {\n//ommited for brevity\n                } else {\n                    _executeExternalPositionHooks(_setToken, _quantity, IERC20(component), false, true);\n\n                    // Call Invoke#invokeTransfer instead of Invoke#strictInvokeTransfer\n                    _setToken.invokeTransfer(component, _to, componentQuantity);\n\n//ommited for brevity\n                }\n            }\n        }\n    }\n\n\n\n    function _resolveDebtPositions(\n        ISetToken _setToken,\n        uint256 _quantity,\n        bool _isIssue,\n        address[] memory _components,\n        uint256[] memory _componentDebtQuantities,\n        uint256 _initialSetSupply,\n        uint256 _finalSetSupply\n    )\n        internal\n    {\n//ommited for brevity\n\n                    // Call Invoke#invokeTransfer instead of Invoke#strictInvokeTransfer\n                    _setToken.invokeTransfer(component, msg.sender, componentQuantity);\n\n                    IssuanceValidationUtils.validateCollateralizationPostTransferOut(_setToken, component, _finalSetSupply);\n//ommited for brevity\n                }\n            }\n        }\n    }\n```\n\nAs seen both functions now use Invoke#invokeTransfer instead of Invoke#strictInvokeTransfer\nThe method `strictInvokeTransfer()` has a mechanism that ensures the final balance of the token is equivalent to the initial balance minus the quantity transferred. This would help in this case as it ensures that if the token being transferred has a transfer fee or is a deflationary token, the transfer wouldn't go through and the balance check would fail.\n\nNow take a look at [Invoke.sol#L66-L112](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/lib/Invoke.sol#L58-L112)\n\n```solidity\n    /**\n     * Instructs the SetToken to transfer the ERC20 token to a recipient.\n     *\n     * @param _setToken        SetToken instance to invoke\n     * @param _token           ERC20 token to transfer\n     * @param _to              The recipient account\n     * @param _quantity        The quantity to transfer\n     */\n    function invokeTransfer(\n        ISetToken _setToken,\n        address _token,\n        address _to,\n        uint256 _quantity\n    )\n        internal\n    {\n        if (_quantity > 0) {\n            bytes memory callData = abi.encodeWithSignature(\"transfer(address,uint256)\", _to, _quantity);\n            _setToken.invoke(_token, 0, callData);\n        }\n    }\n\n    /**\n     * Instructs the SetToken to transfer the ERC20 token to a recipient.\n     * The new SetToken balance must equal the existing balance less the quantity transferred\n     *\n     * @param _setToken        SetToken instance to invoke\n     * @param _token           ERC20 token to transfer\n     * @param _to              The recipient account\n     * @param _quantity        The quantity to transfer\n     */\n    function strictInvokeTransfer(\n        ISetToken _setToken,\n        address _token,\n        address _to,\n        uint256 _quantity\n    )\n        internal\n    {\n        if (_quantity > 0) {\n            // Retrieve current balance of token for the SetToken\n            uint256 existingBalance = IERC20(_token).balanceOf(address(_setToken));\n\n            Invoke.invokeTransfer(_setToken, _token, _to, _quantity);\n\n            // Get new balance of transferred token for SetToken\n            uint256 newBalance = IERC20(_token).balanceOf(address(_setToken));\n\n            // Verify only the transfer quantity is subtracted\n            require(\n                newBalance == existingBalance.sub(_quantity),\n                \"Invalid post transfer balance\"\n            );\n        }\n    }\n\n```\n\nHowever, it is noted that there are no FEE-ON-TRANSFER tokens interacting with the smart contracts currently. But if there are plans to introduce such tokens in the future, the current implementation of `strictInvokeTransfer()` would cause issues.\nThe above paragraph is coined from one of the Q/A by sponsors which validates issule\n[Discussion](https://github.com/sherlock-audit/2023-05-Index/tree/3190057afd3085143a31746d65045a0d1bacc78c#q-are-there-any-fee-on-transfer-tokens-interacting-with-the-smart-contracts)\n\n```diff\nQ: Are there any FEE-ON-TRANSFER tokens interacting with the smart contracts?\nA: Not at the moment, but it would be good to know if they can interact with our smart contracts\n```\n\n## Impact\n\nInability to integrate Fee-on-transfer tokens in the future\n\n## Code Snippet\n\n[DebtIssuanceModuleV2.sol#L251-L333](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModuleV2.sol#L251-L333)\n\n## Tool used\n\nManual review\n\n## Recommendation\n\nIf there are plans of integrating fee-on transfer tokens in the future then integrate correct acccounting mesure to know the exact amount of tokens thst are being accounted for\n","decidedSeverity":"false","decidedDuplication":"DebtIssuanceModuleV2.sol: Current Implementenation of `_resolveEquityPositions()` and `_resolveDebtPositions()` causes Potential issues when Dealing with Some Tokens"},{"file":"155.md","watson":{"name":"Bauchibred","days":8,"is_team":false,"payout":24.18,"score":0.4085706709,"senior":false},"severity":"medium","title":"Invoke Library: Lack of Return Value Checks in ERC20 operations","markdown":"Bauchibred\n\nmedium\n\n# Invoke Library: Lack of Return Value Checks in ERC20 operations\n\n\n\n## Summary\n\nThe `Invoke` library in the project lacks return value checks in ERC20 transfers/approvals. This could lead to silent failures and incorrect internal accounting.\n\n## Vulnerability Detail\n\nThe vulnerability arises from the following code snippets in the [Invoke.sol](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/lib/Invoke.sol#L1-L136) library:\n\n```solidity\nfunction invokeApprove(ISetToken _setToken, address _token, address _spender, uint256 _quantity)\n    internal\n{\n    // @audit the return value of the execution is not checked\n\n    bytes memory callData = abi.encodeWithSignature(\"approve(address,uint256)\", _spender, _quantity);\n    _setToken.invoke(_token, 0, callData);\n}\n\nfunction invokeTransfer(ISetToken _setToken, address _token, address _to, uint256 _quantity)\n    internal\n{\n    // @audit the return value of the execution is not checked\n\n    if (_quantity > 0) {\n        bytes memory callData = abi.encodeWithSignature(\"transfer(address,uint256)\", _to, _quantity);\n        _setToken.invoke(_token, 0, callData);\n    }\n}\n\nfunction strictInvokeTransfer(ISetToken _setToken, address _token, address _to, uint256 _quantity)\n    internal\n{\n    // @audit same thing\n    if (_quantity > 0) {\n        uint256 existingBalance = IERC20(_token).balanceOf(address(_setToken));\n        Invoke.invokeTransfer(_setToken, _token, _to, _quantity);\n        uint256 newBalance = IERC20(_token).balanceOf(address(_setToken));\n        require(newBalance == existingBalance.sub(_quantity), \"Invalid post transfer balance\");\n    }\n}\n```\n\nThe code snippets show that the return values of ERC20 operations are not checked. This can result in silent failures and incorrect internal accounting.\n\n## Impact\n\nThe lack of return value checks in ERC20 operations can lead to silent failures. For example if a transfer fails, it will not be detected, resulting in incorrect internal accounting.\n\n## Code Snippet\n\n[Invoke.sol](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/lib/Invoke.sol#L1-L136) library:\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nTo address this vulnerability, it is recommended to implement return value checks for all ERC20 transfers/approvals in the `Invoke` library. By checking the return values, the library can detect transfer failures and handle them appropriately, ensuring accurate internal accounting.\n\nOne recommended approach is to use the SafeERC20 library provided by OpenZeppelin. The library includes safe versions of ERC20 transfer functions that handle return value checks and revert the transaction if the transfer fails. Integrating the SafeERC20 library will enhance the robustness of the token transfer operations in the `Invoke` library.\n","decidedSeverity":"medium","decidedDuplication":"AmmModule will not work with usdt"},{"file":"156.md","watson":{"name":"Bauchibred","days":8,"is_team":false,"payout":24.18,"score":0.4085706709,"senior":false},"severity":"medium","title":"BaseExtension.sol: `onlyEOA` modifier that ensures call is from EOA might not hold completely true in the future","markdown":"Bauchibred\n\nmedium\n\n# BaseExtension.sol: `onlyEOA` modifier that ensures call is from EOA might not hold completely true in the future\n\n\n## Summary\n\nThe `BaseExtension` contract implements the `onlyEOA` modifier to ensure that the caller is an externally owned account (EOA) and not a smart contract. However, it is important to note that the introduction of [EIP 3074](https://eips.ethereum.org/EIPS/eip-3074) would affect the behavior of this check since it initroduces two new EVM opcodes. While the `onlyEOA` modifier would still hold true for traditional EOAs, users who have signed AUTHCALLs or other EIP 3074 instructions might not be able to execute transactions in the contract since the `require(msg.sender == tx.origin)` condition would prevent them from interacting with the protocol.\n\nNB: The core extension, [AaveLeverageStrategyExtension.sol](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol) contract heavliy uses the `onlyEOA` modifier which it inherits from [BaseExtension.sol]()\n\n## Vulnerability Detail\n\nThe `BaseExtension` contract includes the `onlyEOA` modifier to ensure that the caller is an EOA:\n\n[onlyEOA()](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/lib/BaseExtension.sol#L56-L62C1)\n\n```solidity\nmodifier onlyEOA() {\n    require(msg.sender == tx.origin, \"Caller must be EOA Address\");\n    _;\n}\n```\n\nHowever, with the introduction of EIP 3074, which allows smart contracts to act on behalf of EOAs using the `AUTH` and `AUTHCALL` instructions, users who have signed such instructions might encounter difficulties executing transactions in the contract. This is because the `require(msg.sender == tx.origin)` condition in the `onlyEOA` modifier would prevent these users from interacting with the protocol.\n\n## Impact\n\nIf EIP 3074 is implemented and users have signed AUTHCALLs or other similar instructions, they might not be able to execute transactions in the `BaseExtension` contract and all contracts that inherit from it due to the `onlyEOA` modifier's verification check. This could restrict their access to the protocol's functionalities and potentially result in user experience issues.\n\n## Code Snippet\n\n[onlyEOA()](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/lib/BaseExtension.sol#L56-L62C1)\n\n[AaveLeverageStrategyExtension.sol](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nTo address the potential impact of EIP 3074 and ensure a more inclusive user experience, it is recommended to reconsider the usage of the `onlyEOA` modifier in the `BaseExtension` contract. Instead of relying solely on the `require(msg.sender == tx.origin)` condition, alternative approaches can be explored.\n\nOne option is to update the modifier to allow users who have signed AUTHCALLs or other EIP 3074 instructions to interact with the protocol. This can be achieved by removing the `require(msg.sender == tx.origin)` condition and implementing additional checks to validate the caller's authorization, such as maintaining a whitelist of authorized contracts or implementing a role-based access control mechanism.\n\nAlternatively, if it is desired to strictly restrict interactions to traditional EOAs, the modifier can be kept as is. However, it is important to communicate this limitation to users and provide clear instructions on how to interact with the protocol if they have signed AUTHCALLs or similar instructions.\n","decidedSeverity":"medium","decidedDuplication":"onlyEOA modifier that ensures call is from EOA might not hold true with the eip 3074"},{"file":"157.md","watson":{"name":"Bauchibred","days":8,"is_team":false,"payout":24.18,"score":0.4085706709,"senior":false},"severity":"medium","title":"AaveLeverageStrategyExtension.sol: User's Unfair Loss of Ether in `ripcord()`","markdown":"Bauchibred\n\nmedium\n\n# AaveLeverageStrategyExtension.sol: User's Unfair Loss of Ether in `ripcord()`\n\n\n## Summary\n\nThe `ripcord()` function in the contract is designed to be called during periods of high downside volatility and can be invoked by any user. It offers an incentive in the form of Ether rewards for users who trigger the function. However, there is a vulnerability in the implementation that can result in an unfair loss of Ether rewards. If the contract's Ether balance is insufficient to cover the full reward amount, the user's reward is truncated to the available balance, causing the remaining rewards to be lost.\n\n## Vulnerability Detail\n\nWhen a user triggers the `ripcord()` function, the internal function `_transferEtherRewardToCaller` is called to transfer the Ether reward to the caller. However, this function truncates the reward amount to the available Ether balance in the contract. As a result, if a user's rewards at the time of execution exceed the available Ether balance, the excess rewards are lost.\n\nTake a look at the functions below\n\n[ripcord()](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L368-L400)\n\n```solidity\nfunction ripcord(string memory _exchangeName) external onlyEOA {\n    // ... code omitted for brevity ...\n\n    uint256 etherTransferred = _transferEtherRewardToCaller(incentive.etherReward);\n\n    // ... code omitted for brevity ...\n}\n```\n\n[\\_transferEtherRewardToCaller()](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1212-L1224)\n\n```solidity\nfunction _transferEtherRewardToCaller(uint256 _etherReward) internal returns (uint256) {\n    uint256 etherToTransfer = _etherReward < address(this).balance ? _etherReward : address(this).balance;\n\n    msg.sender.transfer(etherToTransfer);\n\n    return etherToTransfer;\n}\n```\n\n## Impact\n\nThe impact of this vulnerability is that users who trigger the `ripcord()` function may experience an unfair loss of Ether rewards. If their rewards exceed the available Ether balance in the contract, the excess rewards are effectively forfeited. This can lead to dissatisfaction among users and undermine the intended incentive mechanism.\n\n## Code Snippet\n\n[ripcord()](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L368-L400)\n\n[\\_transferEtherRewardToCaller()](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1212-L1224)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nTo address the risk of users losing their Ether rewards unfairly in the `ripcord()` function, it is recommended to implement a solution that ensures users can receive their rewards in a fair manner while also considering the possibility of the call to `ripcord()` not failing. One possible solution is to implement a mechanism where users can receive their Ether rewards in parts or increments.\n\nBy implementing this incremental reward distribution mechanism, users will be able to receive a portion of their rewards even if the contract's Ether balance is insufficient to cover the full reward amount. The remaining balance can be stored in a separate variable or data structure associated with each user, allowing them to claim the outstanding rewards at a later time.\n\nThe implementation can involve the following steps:\n\n1. Modify the contract to track the total rewards earned by each user and the rewards already distributed to them.\n\n2. When a user triggers the `ripcord()` function and becomes eligible for rewards, calculate the incremental reward amount they are entitled to based on the available Ether balance in the contract.\n\n3. Transfer the calculated incremental reward amount to the user's account.\n\n4. Update the user's reward balance and the distributed rewards amount.\n\n5. Repeat this process whenever the `ripcord()` function is called, allowing users to accumulate their rewards over multiple invocations until they claim the full amount.\n\nBy implementing this incremental reward distribution mechanism, users will no longer experience an unfair loss of Ether rewards. They will have the opportunity to receive their rewards gradually and claim the remaining balance when the contract's Ether balance increases. This approach ensures fairness while maintaining the ability to execute the `ripcord()` function without causing failures due to insufficient Ether balance.\n\nImplementing this mechanism will enhance the user experience and incentivize users to participate in the ripcord functionality, as they can be confident that their rewards will not be unfairly lost.\n","decidedSeverity":"false","decidedDuplication":"AaveLeverageStrategyExtension.sol: User's Unfair Loss of Ether in `ripcord()`"},{"file":"158.md","watson":{"name":"Bauchibred","days":8,"is_team":false,"payout":24.18,"score":0.4085706709,"senior":false},"severity":"medium","title":"AaveLeverageStrategyExtension: Usage of Deprecated Chainlink API puts Protocol at Risk","markdown":"Bauchibred\n\nmedium\n\n# AaveLeverageStrategyExtension: Usage of Deprecated Chainlink API puts Protocol at Risk\n\n## Summary\n\nThe AaveLeverageStrategyExtension contract uses Chainlink's deprecated `latestAnswer()` API in its `_createActionInfo()` function. This function is extensively used within the contract, including in the `engage()`, `getCurrentLeverageRatio()`, `getChunkRebalanceNotional()`, and internal `_getAndValidateLeveragedInfo()` functions. The continued use of this deprecated API could potentially lead to stale data and pose a significant risk to the overall functioning of the AaveLeverageStrategyExtension contract.\n\n## Vulnerability Detail\n\nThe `_createActionInfo()` function retrieves asset prices using the deprecated `latestAnswer()` method from Chainlink oracles. As indicated by Chainlink, this method is deprecated and may stop working if Chainlink discontinues support. Furthermore, `latestAnswer()` does not have the capability to validate the freshness of the data it retrieves.\n\nThis means the function could potentially return stale or outdated price data, which could lead to incorrect calculations of collateral and borrow values in the AaveLeverageStrategyExtension contract. Since the `_createActionInfo()` function is extensively used within the contract, this vulnerability could impact a broad range of operations.\n\nTake a look at [AaveLeverageStrategyExtension.sol#L884-L907](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L884-L907)\n\n```solidity\n    /**\n     * Create the action info struct to be used in internal functions\n     *\n     * return ActionInfo                Struct containing data used by internal lever and delever functions\n     */\n    function _createActionInfo() internal view returns(ActionInfo memory) {\n        ActionInfo memory rebalanceInfo;\n\n        // Calculate prices from chainlink. Chainlink returns prices with 8 decimal places, but we need 36 - underlyingDecimals decimal places.\n        // This is so that when the underlying amount is multiplied by the received price, the collateral valuation is normalized to 36 decimals.\n        // To perform this adjustment, we multiply by 10^(36 - 8 - underlyingDecimals)\n        int256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\n        rebalanceInfo.collateralPrice = rawCollateralPrice.toUint256().mul(10 ** strategy.collateralDecimalAdjustment);\n        int256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer();\n        rebalanceInfo.borrowPrice = rawBorrowPrice.toUint256().mul(10 ** strategy.borrowDecimalAdjustment);\n\n        rebalanceInfo.collateralBalance = strategy.targetCollateralAToken.balanceOf(address(strategy.setToken));\n        rebalanceInfo.borrowBalance = strategy.targetBorrowDebtToken.balanceOf(address(strategy.setToken));\n        rebalanceInfo.collateralValue = rebalanceInfo.collateralPrice.preciseMul(rebalanceInfo.collateralBalance);\n        rebalanceInfo.borrowValue = rebalanceInfo.borrowPrice.preciseMul(rebalanceInfo.borrowBalance);\n        rebalanceInfo.setTotalSupply = strategy.setToken.totalSupply();\n\n        return rebalanceInfo;\n    }\n\n```\n\nAt L895 and 897 we cam see the double use of the deprecated `latestAnswer()` method.\n\n## Impact\n\nContinued use of deprecated APIs poses a risk of inoperability if the API is discontinued or its functionality is altered. In this case, the failure of `latestAnswer()` would affect the `_createActionInfo()` function, which is instrumental in several core functionalities of the AaveLeverageStrategyExtension contract.\n\nMoreover, the lack of data freshness validation with `latestAnswer()` can lead to the retrieval of stale or outdated prices. As a result, inaccurate calculations of collateral and borrow values could occur, potentially leading to significant financial and operational issues for the contract.\n\n## Code Snippet\n\n[AaveLeverageStrategyExtension.sol#L884-L907](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L884-L907)\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWe recommend switching from the deprecated `latestAnswer()` to the `latestRoundData()` method provided by the Chainlink V3 API. The `latestRoundData()` method provides fresh data and allows for extra validations, enhancing data reliability and accuracy.\n","decidedSeverity":"medium","decidedDuplication":"Deprecated oracle function `latestAnswer()` could bring fund loss"},{"file":"159.md","watson":{"name":"Bauchibred","days":8,"is_team":false,"payout":24.18,"score":0.4085706709,"senior":false},"severity":"high","title":"Protocol doesn't completely protect itself from `LTV = 0` tokens","markdown":"Bauchibred\n\nhigh\n\n# Protocol doesn't completely protect itself from `LTV = 0` tokens\n\n\n## Summary\n\nThe AaveLeverageStrategyExtension does not completely protect against tokens with a Loan-to-Value (LTV) of 0. Tokens with an LTV of 0 in Aave V3 pose significant risks, as they cannot be used as collateral to borrow upon a breaking withdraw. Moreover, LTVs of assets could be set to 0, even though they currently aren't, it could create substantial problems with potential disruption of multiple functionalities. This bug could cause a Denial-of-Service (DoS) situation in some cases, and has a potential to impact the borrowing logic in the protocol, leading to an unintentionally large perceived borrowing limit.\n\n## Vulnerability Detail\n\nWhen an AToken has LTV = 0, Aave restricts the usage of certain operations. Specifically, if a user owns at least one AToken as collateral with an LTV = 0, certain operations could revert:\n\n1. **Withdraw**: If the asset being withdrawn is collateral and the user is borrowing something, the operation will revert if the withdrawn collateral is an AToken with LTV > 0.\n2. **Transfer**: If the asset being transferred is an AToken with LTV > 0 and the sender is using the asset as collateral and is borrowing something, the operation will revert.\n3. **Set the reserve of an AToken as non-collateral**: If the AToken being set as non-collateral is an AToken with LTV > 0, the operation will revert.\n\nTake a look at [AaveLeverageStrategyExtension.sol#L1050-L1119](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1050-L1119)\n\n```solidity\n    /**\n     * Calculate total notional rebalance quantity and chunked rebalance quantity in collateral units.\n     *\n     * return uint256          Chunked rebalance notional in collateral units\n     * return uint256          Total rebalance notional in collateral units\n     */\n    function _calculateChunkRebalanceNotional(\n        LeverageInfo memory _leverageInfo,\n        uint256 _newLeverageRatio,\n        bool _isLever\n    )\n        internal\n        view\n        returns (uint256, uint256)\n    {\n        // Calculate absolute value of difference between new and current leverage ratio\n        uint256 leverageRatioDifference = _isLever ? _newLeverageRatio.sub(_leverageInfo.currentLeverageRatio) : _leverageInfo.currentLeverageRatio.sub(_newLeverageRatio);\n\n        uint256 totalRebalanceNotional = leverageRatioDifference.preciseDiv(_leverageInfo.currentLeverageRatio).preciseMul(_leverageInfo.action.collateralBalance);\n\n        uint256 maxBorrow = _calculateMaxBorrowCollateral(_leverageInfo.action, _isLever);\n\n        uint256 chunkRebalanceNotional = Math.min(Math.min(maxBorrow, totalRebalanceNotional), _leverageInfo.twapMaxTradeSize);\n\n        return (chunkRebalanceNotional, totalRebalanceNotional);\n    }\n\n    /**\n     * Calculate the max borrow / repay amount allowed in base units for lever / delever. This is due to overcollateralization requirements on\n     * assets deposited in lending protocols for borrowing.\n     *\n     * For lever, max borrow is calculated as:\n     * (Net borrow limit in USD - existing borrow value in USD) / collateral asset price adjusted for decimals\n     *\n     * For delever, max repay is calculated as:\n     * Collateral balance in base units * (net borrow limit in USD - existing borrow value in USD) / net borrow limit in USD\n     *\n     * Net borrow limit for levering is calculated as:\n     * The collateral value in USD * Aave collateral factor * (1 - unutilized leverage %)\n     *\n     * Net repay limit for delevering is calculated as:\n     * The collateral value in USD * Aave liquiditon threshold * (1 - unutilized leverage %)\n     *\n     * return uint256          Max borrow notional denominated in collateral asset\n     */\n    function _calculateMaxBorrowCollateral(ActionInfo memory _actionInfo, bool _isLever) internal view returns(uint256) {\n\n        // Retrieve collateral factor and liquidation threshold for the collateral asset in precise units (1e16 = 1%)\n        ( , uint256 maxLtvRaw, uint256 liquidationThresholdRaw, , , , , , ,) = strategy.aaveProtocolDataProvider.getReserveConfigurationData(address(strategy.collateralAsset));\n\n        // Normalize LTV and liquidation threshold to precise units. LTV is measured in 4 decimals in Aave which is why we must multiply by 1e14\n        // for example ETH has an LTV value of 8000 which represents 80%\n        if (_isLever) {\n            uint256 netBorrowLimit = _actionInfo.collateralValue\n                .preciseMul(maxLtvRaw.mul(10 ** 14))\n                .preciseMul(PreciseUnitMath.preciseUnit().sub(execution.unutilizedLeveragePercentage));\n\n            return netBorrowLimit\n                .sub(_actionInfo.borrowValue)\n                .preciseDiv(_actionInfo.collateralPrice);\n        } else {\n            uint256 netRepayLimit = _actionInfo.collateralValue\n                .preciseMul(liquidationThresholdRaw.mul(10 ** 14))\n                .preciseMul(PreciseUnitMath.preciseUnit().sub(execution.unutilizedLeveragePercentage));\n\n            return _actionInfo.collateralBalance\n                .preciseMul(netRepayLimit.sub(_actionInfo.borrowValue))\n                .preciseDiv(netRepayLimit);\n        }\n    }\n```\n\nApart from the aforementioned issue with `LTV = 0` tokens, there's another issue with the `_calculateMaxBorrowCollateral()` function. When LTV = 0, `maxLtvRaw` also equals 0, leading to a `netBorrowLimit` of 0. When the borrowing value is subtracted from this, it results in an underflow, causing the borrowing limit to appear incredibly large. This essentially breaks the borrowing logic of the protocol.\n\n## Impact\n\nThis bug could potentially disrupt the entire borrowing logic within the protocol by inflating the perceived borrowing limit. This could lead to users borrowing an unlimited amount of assets due to the underflow error. In extreme cases, this could lead to a potential loss of user funds or even a complete protocol shutdown, thus impacting user trust and the overall functionality of the protocol.\n\n## Code Snippet\n\n[AaveLeverageStrategyExtension.sol#L1050-L1119](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1050-L1119)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe protocol should consider implementing additional protections against tokens with an LTV of 0.\n","decidedSeverity":"medium","decidedDuplication":"Side effects of LTV = 0 assets: Index's users will not be able to withdraw (collateral), borrow"},{"file":"160.md","watson":{"name":"Bauchibred","days":8,"is_team":false,"payout":24.18,"score":0.4085706709,"senior":false},"severity":"medium","title":"HardCoded Chainlink Feed Decimals Risk in AaveLeverageStrategyExtension Contract","markdown":"Bauchibred\n\nmedium\n\n# HardCoded Chainlink Feed Decimals Risk in AaveLeverageStrategyExtension Contract\n\n## Summary\n\nThe AaveLeverageStrategyExtension contract is found to be hardcoded with the assumption that Chainlink oracles return feed decimals as 8. This is risky as Chainlink feed decimals vary and can be as high as 18.\n\n## Vulnerability Detail\n\nIn the `_createActionInfo()` function, prices are normalized to account for potential discrepancies between feed and token decimals and the expected return value. However, the assumption made here that Chainlink returns prices with 8 decimal places is not universally accurate. This hardcoded assumption could potentially lead to inaccurate price valuation.\n\nTake a look at [createActionInfo()](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L884-L907)\n\n```solidity\n    /**\n     * Create the action info struct to be used in internal functions\n     *\n     * return ActionInfo                Struct containing data used by internal lever and delever functions\n     */\n    function _createActionInfo() internal view returns(ActionInfo memory) {\n        ActionInfo memory rebalanceInfo;\n\n// @audit not all feed decimals are 8\n        // Calculate prices from chainlink. Chainlink returns prices with 8 decimal places, but we need 36 - underlyingDecimals decimal places.\n        // This is so that when the underlying amount is multiplied by the received price, the collateral valuation is normalized to 36 decimals.\n        // To perform this adjustment, we multiply by 10^(36 - 8 - underlyingDecimals)\n        int256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\n        rebalanceInfo.collateralPrice = rawCollateralPrice.toUint256().mul(10 ** strategy.collateralDecimalAdjustment);\n        int256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer();\n        rebalanceInfo.borrowPrice = rawBorrowPrice.toUint256().mul(10 ** strategy.borrowDecimalAdjustment);\n\n        rebalanceInfo.collateralBalance = strategy.targetCollateralAToken.balanceOf(address(strategy.setToken));\n        rebalanceInfo.borrowBalance = strategy.targetBorrowDebtToken.balanceOf(address(strategy.setToken));\n        rebalanceInfo.collateralValue = rebalanceInfo.collateralPrice.preciseMul(rebalanceInfo.collateralBalance);\n        rebalanceInfo.borrowValue = rebalanceInfo.borrowPrice.preciseMul(rebalanceInfo.borrowBalance);\n        rebalanceInfo.setTotalSupply = strategy.setToken.totalSupply();\n\n        return rebalanceInfo;\n    }\n\n```\n\nThe code snippet above demonstrates the problematic assumption, as the comment suggest the feed decimals are assumed to be 8, This assumption should be safe for certain cases, for example WETH is 18 decimals and the ETH/USD chainlink is 8 decimals, but say the feed decimals are actually 18, the calculation of `(36 - 8 - underlyingDecimals)` would be off by 10, which would result in significantly inaccurate price valuations.\n\n## Impact\n\nThe hardcoded assumption of 8 feed decimals can result in significant miscalculations within the `_createActionInfo()` function, leading to potential under or over-valuation of collateral and borrow prices. As this function is instrumental in many critical contract operations, such as leverage and deleverage functions, this risk could have serious implications on the overall functioning and accuracy of the AaveLeverageStrategyExtension contract.\n\n## Code Snippet\n\n[AaveLeverageStrategyExtension.sol#L884-L907](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L884-L907)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nInstead of hardcoding the feed decimals to 8, it is recommended to dynamically fetch the actual decimals from the Chainlink feed. The multiplication operation should then use `10^(36 - feedDecimals - underlyingDecimals)` to ensure accurate calculations.\n","decidedSeverity":"medium","decidedDuplication":"Wrongly assume chainlink oracle decimal is always 8"},{"file":"161.md","watson":{"name":"Bauchibred","days":8,"is_team":false,"payout":24.18,"score":0.4085706709,"senior":false},"severity":"high","title":"AaveV3LeverageStrategyExtension is at Risk of DOS if Chainlink Access is Blocked","markdown":"Bauchibred\n\nhigh\n\n# AaveV3LeverageStrategyExtension is at Risk of DOS if Chainlink Access is Blocked\n\n## Summary\n\nThe AaveV3LeverageStrategyExtension's functionality could become severely limited if access to the Chainlink oracle data feed is blocked. A denial of service (DOS) could occur, impacting the creation of the ActionInfo struct utilized in internal functions.\n\nNB: This function is extensively used within the AaveLeverageStrategyExtension contract, in functions like `engage()`, `getCurrentLeverageRatio()`, `getChunkRebalanceNotional()`, and internal `_getAndValidateLeveragedInfo()` functions.\n\n## Vulnerability Detail\n\nThe AaveV3LeverageStrategyExtension uses the Chainlink oracle data feed to get prices in the `_createActionInfo` function. This function is used to create an ActionInfo struct that stores vital data used by internal lever/delever and other functions.\n\nThe vulnerability lies in these lines:\n\n```solidity\nint256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\nrebalanceInfo.collateralPrice = rawCollateralPrice.toUint256().mul(10 ** strategy.collateralDecimalAdjustment);\n\nint256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer();\nrebalanceInfo.borrowPrice = rawBorrowPrice.toUint256().mul(10 ** strategy.borrowDecimalAdjustment);\n```\n\nAs https://blog.openzeppelin.com/secure-smart-contract-guidelines-the-dangers-of-price-oracles/ mentions, it is possible that Chainlink’s “multisigs can immediately block access to price feeds at will”. When this occurs, the execution of either `strategy.collateralPriceOracle.latestAnswer()` or `strategy.borrowPriceOracle.latestAnswer()` will revert.\n\nAs a result, the creation of the ActionInfo struct fails, leading to a cascade of issues in other functions that depend on the ActionInfo struct, and ultimately, causing a DOS.\n\n### Proof of Concept\n\nConsider a scenario:\n\n1. Chainlink oracle data feed is used for getting prices.\n2. Any of the function that calls `_createActionInfo` is executed to get an ActionInfo struct.\n3. Suddenly, Chainlink's multisigs block access to price feeds. Executing `strategy.collateralPriceOracle.latestAnswer()` or `strategy.borrowPriceOracle.latestAnswer()` now reverts.\n4. The creation of the ActionInfo struct fails, which eventually causes the parent function to fail.\n5. If other functions that depend on `_createActionInfo` are called, they will also fail, leading to a potential DOS.\n\n## Impact\n\nShould Chainlink's multisigs block access to price feeds, the AaveV3LeverageStrategyExtension's functionality becomes very limited due to the failed creation of the ActionInfo struct. This effectively results in a denial of service (DOS) attack.\n\n## Code Snippet\n\n[AaveLeverageStrategyExtension.sol#L884-L907](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L884-L907)\n\n## Tool used\n\nManual Audit\n\n## Recommendation\n\nRefactor `_createActionInfo` to include a try-catch block for the price feed calls. Consider providing a fallback logic when the access to the Chainlink oracle data feed is denied.\n\nHere is a base to build a refactored version on using try-catch:\n\n```solidity\ntry {\n    int256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\n    rebalanceInfo.collateralPrice = rawCollateralPrice.toUint256().mul(10 ** strategy.collateralDecimalAdjustment);\n} catch Error(string memory) {\n    // Implement fallback logic here\n}\n\ntry {\n    int256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer();\n    rebalanceInfo.borrowPrice = rawBorrowPrice.toUint256().mul(10 ** strategy.borrowDecimalAdjustment);\n} catch Error(string memory) {\n    // Implement fallback logic here\n}\n```\n\nThe fallback logic could be obtaining the token's price from another reliable oracle or any other predetermined strategy that ensures continuity in the absence of Chainlink price feeds.\n","decidedSeverity":"medium","decidedDuplication":"Unhandled chainlink revert would lock price oracle access"},{"file":"162.md","watson":{"name":"ravikiran.web3","days":21,"is_team":false,"payout":0,"score":0.0001640924,"senior":false},"severity":"medium","title":"StreamingFeeModule is notifying offchain even when there was no fee applicable.","markdown":"ravikiran.web3\n\nmedium\n\n# StreamingFeeModule is notifying offchain even when there was no fee applicable.\n\n## Summary\nStreamingFeeModule accrues streaming fees for Set managers and tracks fees applicable to protocol and manager.\nThe fee is accrues based on the lastStreamingFeeTimestamp. So, tracking the lastStreamingFeeTimestamp is valid, but\nwhen there is no accural of fee, then emiting an event is invalid.\n\nThe streamingFeeModule's accrueFee function emits FeeActualized event even when there was no fee appliable.\nThis offchain notification can be misleading and redundant.\n\n## Vulnerability Detail\nStreamingFeeModule accrues streaming fees for Set managers and tracks the break up of fee between manager and protocol.\nthe applicable fees are notified to offchain via FeeActualized event.  In the cases where there is no applicable fee also, the event is being emitted.\n\n## Impact\nThe impact is minimal as the fee notified are 0 for both Manager and protocol. But, it is better to not fire event where there is no effective change in state on the change.\n \n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/StreamingFeeModule.sol#L86-L108\n\n```solidity\n  if (_streamingFeePercentage(_setToken) > 0) {\n            uint256 inflationFeePercentage = _calculateStreamingFee(_setToken);\n\n            // Calculate incentiveFee inflation\n            uint256 feeQuantity = _calculateStreamingFeeInflation(_setToken, inflationFeePercentage);\n\n            // Mint new Sets to manager and protocol\n            (\n                managerFee,\n                protocolFee\n            ) = _mintManagerAndProtocolFee(_setToken, feeQuantity);\n\n            _editPositionMultiplier(_setToken, inflationFeePercentage);\n        }\n\n        feeStates[_setToken].lastStreamingFeeTimestamp = block.timestamp;\n        emit FeeActualized(address(_setToken), managerFee, protocolFee);\n```\n\nThe below emit event should be inside the if condition where streamFeePercentage is greater than 0.\n\n**emit FeeActualized(address(_setToken), managerFee, protocolFee);**\n\n## Tool used\n\nManual Review\n\n## Recommendation\nMove the below emit inside the if condition.\nemit FeeActualized(address(_setToken), managerFee, protocolFee)\n","decidedSeverity":"false","decidedDuplication":"StreamingFeeModule is notifying offchain even when there was no fee applicable."},{"file":"163.md","watson":{"name":"ravikiran.web3","days":21,"is_team":false,"payout":0,"score":0.0001640924,"senior":false},"severity":"medium","title":"SetToken name and symbol are not checked for uniqueness - leads to vulnerability for investors.","markdown":"ravikiran.web3\n\nmedium\n\n# SetToken name and symbol are not checked for uniqueness - leads to vulnerability for investors.\n\n## Summary\nIndex Protocol is a market platform where managers will create competitive products using different modules/components and extensions. The individual investors who dont have time and knowledge would be investing in these products in anticipation of good performance.\n\nMost of these Individual investors comes from traditional experience of investing in mutual funds etc as example. They relate to the fund using the name of the fund. In the Web3, the name take a back seat as address of the deployed contracts plays the key role.\n\nAs the setToken's name and symbol are not checked for uniqueness across index protocol, it is possible that two different managers with different strategies might have a same name and symbol for settokens. It could also be a strategy of a malicious player to spin an new settoken with same name as a succcessfully operating settoken and entice the user to invest into his malicious product.\n\nConsider name as identifier, many novice investors might fell prey.\n\nExample, if there were 5  google listing on NYSE, it will be hard for investor to identify and invest in the correct listing.\n\n## Vulnerability Detail\nSetTokens created in the IndexCoop platform are not checked for uniqueness and could result in misleading the investors to invest in wrong products(instead of intended products).\n\nThis opens up vulnerability that misleads the end users.  This is because the name and symbol are not being validated for uniqueness while a new settoken is created.\n\n## Impact\nInvestors could endup investing in malicious contracts as they failed to uniquely identify the Settoken on the indexcoop.\nKeeping the name and symbol unique but not creating Settoken could minimize the issue.\n\n## Code Snippet\nSetTokenCreator -> create function\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/SetTokenCreator.sol#L66-L110\n\nIn the below create function, the logic does not check for name and symbol to be unique and hence resulting in many SetTokens with same name.\n\n```Solidity\n function create(\n        address[] memory _components,\n        int256[] memory _units,\n        address[] memory _modules,\n        address _manager,\n        string memory _name,\n        string memory _symbol\n    )\n        external\n        returns (address)\n    {\n        require(_components.length > 0, \"Must have at least 1 component\");\n        require(_components.length == _units.length, \"Component and unit lengths must be the same\");\n        require(!_components.hasDuplicate(), \"Components must not have a duplicate\");\n        require(_modules.length > 0, \"Must have at least 1 module\");\n        require(_manager != address(0), \"Manager must not be empty\");\n```\n\n\nConstructor of setToken\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/SetToken.sol#L158-L184\n\nName and Symbol are not being checked for uniqueness.\n```solidity\nconstructor(\n        address[] memory _components,\n        int256[] memory _units,\n        address[] memory _modules,\n        IController _controller,\n        address _manager,\n        string memory _name,\n        string memory _symbol\n    )\n        public\n        ERC20(_name, _symbol)\n    {\n        controller = _controller;\n        manager = _manager;\n        positionMultiplier = PreciseUnitMath.preciseUnitInt();\n        components = _components;\n\n        // Modules are put in PENDING state, as they need to be individually initialized by the Module\n        for (uint256 i = 0; i < _modules.length; i++) {\n            moduleStates[_modules[i]] = ISetToken.ModuleState.PENDING;\n        }\n\n        // Positions are put in default state initially\n        for (uint256 j = 0; j < _components.length; j++) {\n            componentPositions[_components[j]].virtualUnit = _units[j];\n        }\n    }\n```\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\nIn the SetTokenCreator's create function, check for the symbol and name to be unqiue using the hash to ensure each settoken name and symbol are unique on the platform.\n\nthis is something similar to having only one listing of Microsoft NYSE. It will be confusing to investors if there were two or more Microsoft listing on NYSE.\n \n","decidedSeverity":"false","decidedDuplication":"SetToken name and symbol are not checked for uniqueness - leads to vulnerability for investors."},{"file":"164.md","watson":{"name":"shogoki","days":3,"is_team":false,"payout":409.37,"score":41.5791826772,"senior":false},"severity":"medium","title":"DoS - No Issuance / Borrowing possible because of AAVEv3 Isolation mode.","markdown":"shogoki\n\nmedium\n\n# DoS - No Issuance / Borrowing possible because of AAVEv3 Isolation mode.\n\n## Summary\n\nAn attacker or malicous user can force the AAVE position of the setToken to AAVEv3 Isolation mode. This will prevent the contract from enabling other Assets as Collateral, and borrowing of some tokens and therefore finally issuance of new Tokens.\n\n## Vulnerability Detail\n\nAAVEv3 introduced Isolation mode, which `allows to list new assets as Isolated which has a specific debt ceiling and can be only used to borrow stablecoins that have been permitted, by Aave Governance, to be borrowable in isolation mode.`\nTherefore when the position is in Isolation mode and the in AAVEv3LeverageModule defined Collateral/Borrow Assets do not match the criteria they cannot be used as Collateral/borrowed. \n\nAn Attacker can force the position into Isolation Mode by supplying an (small) amount of an isolated Asset on behalf of the target `SetToken`, when it is holding no other aTokens (yet). (AAVev3´s supply funcion allows supplying for other recpients). This will result in the `SetToken` contract to receive the corresponding aToken. If this is the first aToken for the Address (SetToken Contract) AAVe will automatically enable it as collateral, and in case it is an isolated asset enable Isolation mode. (see [AAve DOcs](https://docs.aave.com/developers/whats-new/isolation-mode))\n\nAs the DebtIssuanceModulev2 is used to issue Tokens and the registered component Hooks inside the `ÀAveV3LeverageModule`invoke a borrow call on AAve (which probably fails) it is not anymore possible to issue any Tokens.\n\n## Impact\n\n- No new SetTokens can be issued\n- SetToken cannot borrow more Tokens on AAVE\n  \n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L695-L706\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L786-L788\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L778-L780\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCheck if there are other aTokens, than the enabled Collateral Tokens in the Contract, and if yes, mark them as not to be used as collateral\n","decidedSeverity":"false","decidedDuplication":"DoS - No Issuance / Borrowing possible because of AAVEv3 Isolation mode."},{"file":"165.md","watson":{"name":"Ruhum","days":149,"is_team":false,"payout":7233.28,"score":26.6892089228,"senior":false},"severity":"medium","title":"usage of deprecated `deposit()` function in AAVE v3 integration","markdown":"Ruhum\n\nmedium\n\n# usage of deprecated `deposit()` function in AAVE v3 integration\n\n## Summary\nThe `deposit()` function was deprecated in favor of the `supply()` function. A deprecated function should not be used if possible since it's subject to be removed. At that point, the AAVE v3 integration will fail to function since you won't be able to deposit new funds.\n\n## Vulnerability Detail\nIn AAVE v3, `deposit()` was deprecated: https://github.com/aave/aave-v3-core/blob/master/contracts/protocol/pool/Pool.sol#L720\n\nWhile the function still exists in the contract it could be removed in the future since AAVE v3 contracts are upgradable.\n\n## Impact\nAAVE v3 integration can break because depositing funds won't be possible anymore.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/integration/lib/AaveV3.sol#L64\n\n## Tool used\n\nManual Review\n\n## Recommendation\nUse `supply()` instead: https://github.com/aave/aave-v3-core/blob/master/contracts/protocol/pool/Pool.sol#L145","decidedSeverity":"medium","decidedDuplication":"AaveV3 library uses deprecated deposit function"},{"file":"166.md","watson":{"name":"Ruhum","days":149,"is_team":false,"payout":7233.28,"score":26.6892089228,"senior":false},"severity":"high","title":"AAVE v3 rewards are not integrated in ClaimModule","markdown":"Ruhum\n\nhigh\n\n# AAVE v3 rewards are not integrated in ClaimModule\n\n## Summary\nAAVE v3 has an active reward program where you earn tokens for supplying and borrowing funds: https://docs.aave.com/developers/whats-new/multiple-rewards-and-claim\n\nIt's not integrated, meaning a loss of funds for the protocol and its users.\n\n## Vulnerability Detail\nEach token & network has its own rewards. On Optimism, you earn OP tokens for example. Because the protocol has a significant amount of TVL, the rewards it earns could grow pretty quickly.\n\nIt already implements the necessary structure to collect rewards in the ClaimModule.\n\nWhat's missing is an integration for AAVE v3. Here's the one for COMP for example: https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/integration/claim/CompClaimAdapter.sol\n\n## Impact\nLoss of rewards.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/ClaimModule.sol#L386\n\n## Tool used\n\nManual Review\n\n## Recommendation\nIntegrate the AAVE v3 rewards program.","decidedSeverity":"false","decidedDuplication":"AAVE v3 rewards are not integrated in ClaimModule"},{"file":"167.md","watson":{"name":"Ruhum","days":149,"is_team":false,"payout":7233.28,"score":26.6892089228,"senior":false},"severity":"high","title":"Attacker can brick AAVE v3 module for assets with approval race condition protection","markdown":"Ruhum\n\nhigh\n\n# Attacker can brick AAVE v3 module for assets with approval race condition protection\n\n## Summary\nSome ERC20 tokens, most notably USDT, have a protection against the approval race condition that forces you to set the allowance to 0 before approving any amount greater than that. Because the AaveV3LeverageModule doesn't do that, it's possible to cause the deposit & repayment functionality to be permanently DOSed.\n\n## Vulnerability Detail\nIn `_repayBorrow()` it first approves a given amount X and then calls the AAVE pool's `repay()` function:\n```sol\n    function _repayBorrow(ISetToken _setToken, IPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);\n        _setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);\n    }\n\n    function invokeApprove(\n        ISetToken _setToken,\n        address _token,\n        address _spender,\n        uint256 _quantity\n    )\n        internal\n    {\n        bytes memory callData = abi.encodeWithSignature(\"approve(address,uint256)\", _spender, _quantity);\n        _setToken.invoke(_token, 0, callData);\n    }\n```\n\nThe AAVE pool doesn't necessarily use all the funds it is approved to use when repaying a user's debt:\n\n```sol\n  function executeRepay(\n    mapping(address => DataTypes.ReserveData) storage reservesData,\n    mapping(uint256 => address) storage reservesList,\n    DataTypes.UserConfigurationMap storage userConfig,\n    DataTypes.ExecuteRepayParams memory params\n  ) external returns (uint256) {\n    DataTypes.ReserveData storage reserve = reservesData[params.asset];\n    DataTypes.ReserveCache memory reserveCache = reserve.cache();\n    reserve.updateState(reserveCache);\n\n    (uint256 stableDebt, uint256 variableDebt) = Helpers.getUserCurrentDebt(\n      params.onBehalfOf,\n      reserveCache\n    );\n    \n    uint256 paybackAmount = params.interestRateMode == DataTypes.InterestRateMode.STABLE\n      ? stableDebt\n      : variableDebt;\n\n    if (params.amount < paybackAmount) {\n      paybackAmount = params.amount;\n    }\n```\n\nIf the `delever()` function tries to repay more than the contract's debt, the AAVE pool won't use all of its allowance. An attack could trigger this by repaying some of the debt themselves by frontrunning the `delever()` function.\n\nThe next time someone wants to repay their debt or deposit assets to the pool, the module will approve the amount to the pool again which will revert because of the race condition protection.\n\n## Impact\nAn attacker is able to brick the AAVE v3 module so that no one is able to deposit or borrow any funds.\n\n## Code Snippet\n- https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L762-L765\n- https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/lib/Invoke.sol#L46\n- https://github.com/aave/aave-v3-core/blob/master/contracts/protocol/libraries/logic/BorrowLogic.sol#L214\n## Tool used\n\nManual Review\n\n## Recommendation\nAlways approve 0 tokens first.\n","decidedSeverity":"medium","decidedDuplication":"AmmModule will not work with usdt"},{"file":"168.md","watson":{"name":"Ruhum","days":149,"is_team":false,"payout":7233.28,"score":26.6892089228,"senior":false},"severity":"medium","title":"`withdrawEtherBalance()` will fail for MultiSig operator","markdown":"Ruhum\n\nmedium\n\n# `withdrawEtherBalance()` will fail for MultiSig operator\n\n## Summary\nThe operator is expected to be a MultiSig. The integration sends ETH to that address with a gas stipend of 2300 which won't be enough for the call to succeed.\n\n## Vulnerability Detail\nIn `AaveLeverageStrategyExtension.withdrawEtherBalance()` the contract's ETH is sent to the operator address using the `transfer()` function:\n\n```sol\n    /**\n     * OPERATOR ONLY: Withdraw entire balance of ETH in this contract to operator. Rebalance must not be in progress\n     */\n    function withdrawEtherBalance() external onlyOperator noRebalanceInProgress {\n        msg.sender.transfer(address(this).balance);\n    }\n```\n\nBut, the operator address is expected to be a MultiSig: 0x6904110f17feD2162a11B5FA66B188d801443Ea4\n\nAt least, that's the case for the other modules, e.g.\n- https://etherscan.io/address/0xb97f5a34696adf30db822612379235c3c53b714a#readContract#F10\n- https://etherscan.io/address/0x0749ce17c983deb806d6b841c65b7359c3d5b104#readContract#F10\n\nGnosisSafe proxies don't implement `receive()` but use `fallback()` which will use more than 2300 gas:\n\n```sol\n    fallback() external payable {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let _singleton := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\n            // 0xa619486e == keccak(\"masterCopy()\"). The value is right padded to 32-bytes with 0s\n            if eq(calldataload(0), 0xa619486e00000000000000000000000000000000000000000000000000000000) {\n                mstore(0, _singleton)\n                return(0, 0x20)\n            }\n            calldatacopy(0, 0, calldatasize())\n            let success := delegatecall(gas(), _singleton, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            if eq(success, 0) {\n                revert(0, returndatasize())\n            }\n            return(0, returndatasize())\n        }\n    }\n```\n\nThat will cause the transfer to fail.\n\n## Impact\nThe module won't be able to use an operator that's a MultiSig. That will heavily reduce the security of the module since key functionality and configuration is handled by that address. It being a simple 1:1 hot wallet increases the risk of the module being compromised.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L584\n\n## Tool used\n\nManual Review\n\n## Recommendation\nUse `call()` instead of `transfer()`. Since the address is trusted, there's no risk of reentrancy.\n","decidedSeverity":"false","decidedDuplication":"`withdrawEtherBalance()` will fail for MultiSig operator"},{"file":"169.md","watson":{"name":"shogoki","days":3,"is_team":false,"payout":409.37,"score":41.5791826772,"senior":false},"severity":"high","title":"Loss of user funds  - unchecked Return of ERC20 Transfer","markdown":"shogoki\n\nhigh\n\n# Loss of user funds  - unchecked Return of ERC20 Transfer\n\n## Summary\n\nSilently failing transfers can result in a partial or total loss of the users investment.\n\n## Vulnerability Detail\n\n\nSome ERC20 Tokens do not revert on failure of the transfer function, but return a bool value instead. Some do not return any value. Therefore it is required to check if a value was returned, and if true, which value it is. This is not done on some places in these contracts.\n\nThe `DebtIssuanceModulev2`, which is required to issue or redeem tokens whenever there is a LeverageModule involved uses the `invokeTransfer` function of the `Invoke` library to transfer ERC20 Tokens from the `SetToken` to the user.\n\n`invokeTransfer` is encoding the Calldata for the regular `transfer` function of ERC20 tokens and  passes it together with the target (ERC20 token address) the SetTokens generic `invoke` function, whichin turn uses `functionCallWithValue` from the Openzeppelin Address Library. This method is bubbling up a possible revert of the call and returning the raw data.\n\nThe generic `invoke` is returning this raw data, however in `invokeTransfer` the return value of `invoke` is ignored and not used. \nAs some ERC20 Tokens do not revert on a failed transfer, but instead return a `false` bool value, the stated behaviour can lead to silently failing transfers.\n\nThis is inside the `DebtIssuanceModulev2` used to:\n\n1. Transfer The \"debt\" (borrowed) Tokens to the user at Issuance\n2. Transfer back the main component Tokens (e.g. aTokens) to the user at Redemption\n\nIf such a Transfer silently fails, the funds will remain inside the setToken contract and the user has no chance to recover them.\n\nIn the issuance event the user receives the SetTokens but not the borrowed Tokens, which he has to repay when he wants to redeem the tokens. (Results in Loss of the \"Debt\")\n\nIn the redemption event the user repays his debt & bruns his Set Tokens, but never receives his original Tokens back. (Total Loss of investment)\n\n## Impact\n\nPossible Loss of all/part of the Investment for the User\n\n## Code Snippet\n\nUsage of invokeTransfer in`DebtIssuanceModulev2`:\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModuleV2.sol#L283\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModuleV2.sol#L315\n\n`invokeTransfer` function ignores return value of `invoke`:\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/lib/Invoke.sol#L66-L78\n\n`invoke` uses `functionCallwithValue` and returns the raw return Data (which is ignored in this case):\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/SetToken.sol#L197-L212\n \n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCheck for the existence and value of the returned data of the Transfer call. If there is a return value, it has to be true. This could be achieved by using Openzeppelins SafeERC20 library´s `safeTransfer`.  \n","decidedSeverity":"false","decidedDuplication":"Loss of user funds  - unchecked Return of ERC20 Transfer"},{"file":"170.md","watson":{"name":"shogoki","days":3,"is_team":false,"payout":409.37,"score":41.5791826772,"senior":false},"severity":"medium","title":"Possible miscalculation of Leverage Ratio because of unchecked Chainlink values","markdown":"shogoki\n\nmedium\n\n# Possible miscalculation of Leverage Ratio because of unchecked Chainlink values\n\n## Summary\n\nThe AAVE Leverage Strategy extension uses Chainlink oracles to determine the price of the collateral and the debt to calculate the leverage Ratio. It uses a deprecated way of fetching these prices and is not implementing any further measures to check the validity, which coud result in either 0 or a stale price returned.  \n\n## Vulnerability Detail\n\nIn `AaveV3LeverageStrategyExtension` chainlinkg Oracles are used to fetch the current price of the collateral and debt Tokens in USD. These prices are later used to calculate the current `leverageRatio`, which in turn is used as a basis for reabalancing or even the call of the `ripcord` function. \n\nThe price is fetched using the [deprecated](https://docs.chain.link/data-feeds/api-reference#latestanswer) `latestAnswer` function from Chainlink. Furthermore, there are no sanity checks done to check if the price is valid or not. \nThis can lead to the returned price either be 0 (no data) or stale (if the oracle was paused, or no current data is coming in).\n\nWhich in turn results in a wrong calculation of the `leverageRatio` and could result in bad rebalances or even a loss of `ether` because of the `leverageRatio` going wrongly above the `incentivicedRatio` and allows someone to call the ripcord function and get rewards.\n\n\n## Impact\n\n- wrong prices are used for calculations in rebalancing\n- possible loss of ETH because of miscalculated Leverage ratio and misuse of ripcord function\n \n\n## Code Snippet\n\nFetching of the price:\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L896\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L898\n\nPrices are used to calculate the value:\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L902-L903\n\nValues are used to calculate the leverage Ratio\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1019-L1028\n\nLeverage ratio is used as basis for calculations and require checks (only some examples listed:\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L315\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L984\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L627\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n1. Use `latestRoundData` instead of `latestAnswer` to fetch the price: [see Docs](https://docs.chain.link/data-feeds/api-reference#latestrounddata)\n2. Implement additional sanity and staleness checks using the additional returned data from `latestRoundData`\n","decidedSeverity":"medium","decidedDuplication":"Deprecated oracle function `latestAnswer()` could bring fund loss"},{"file":"171.md","watson":{"name":"Bauchibred","days":8,"is_team":false,"payout":24.18,"score":0.4085706709,"senior":false},"severity":"medium","title":"Inadequate Protection Against Negative or Zero Price","markdown":"Bauchibred\n\nmedium\n\n# Inadequate Protection Against Negative or Zero Price\n\n\n## Summary\n\nThe `_createActionInfo()` function does not handle scenarios where the price data fetched from a Chainlink oracle is negative or zero. This lack of protection can result in improper computations and faulty valuations within the contract, leading to potential economic implications.\n\n## Vulnerability Detail\n\nChainlink price feeds, used in the contract for real-time price information, return data as `int256`. While the contract accepts these prices as `int256`, it doesn't account for the potential of these prices to be negative or zero. Such values are valid within the scope of `int256` but are not appropriate for price calculations.\n\nTake a look at [AaveLeverageStrategyExtension.sol#L884-L907](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L884-L907)\n\n```solidity\n    /**\n     * Create the action info struct to be used in internal functions\n     *\n     * return ActionInfo                Struct containing data used by internal lever and delever functions\n     */\n    function _createActionInfo() internal view returns(ActionInfo memory) {\n        ActionInfo memory rebalanceInfo;\n\n        // Calculate prices from chainlink. Chainlink returns prices with 8 decimal places, but we need 36 - underlyingDecimals decimal places.\n        // This is so that when the underlying amount is multiplied by the received price, the collateral valuation is normalized to 36 decimals.\n        // To perform this adjustment, we multiply by 10^(36 - 8 - underlyingDecimals)\n        int256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\n        rebalanceInfo.collateralPrice = rawCollateralPrice.toUint256().mul(10 ** strategy.collateralDecimalAdjustment);\n        int256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer();\n        rebalanceInfo.borrowPrice = rawBorrowPrice.toUint256().mul(10 ** strategy.borrowDecimalAdjustment);\n\n        rebalanceInfo.collateralBalance = strategy.targetCollateralAToken.balanceOf(address(strategy.setToken));\n        rebalanceInfo.borrowBalance = strategy.targetBorrowDebtToken.balanceOf(address(strategy.setToken));\n        rebalanceInfo.collateralValue = rebalanceInfo.collateralPrice.preciseMul(rebalanceInfo.collateralBalance);\n        rebalanceInfo.borrowValue = rebalanceInfo.borrowPrice.preciseMul(rebalanceInfo.borrowBalance);\n        rebalanceInfo.setTotalSupply = strategy.setToken.totalSupply();\n\n        return rebalanceInfo;\n    }\n\n```\n\nThe issue arises in the following code snippet:\n\n```solidity\nint256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\nrebalanceInfo.collateralPrice = rawCollateralPrice.mul(10 ** strategy.collateralDecimalAdjustment);\nint256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer();\nrebalanceInfo.borrowPrice = rawBorrowPrice.mul(10 ** strategy.borrowDecimalAdjustment);\n```\n\nHere, price data is fetched from Chainlink using the `latestAnswer()` function, and the returned values are used directly without verifying if they are positive. The fetched prices are then multiplied by a power of 10 based on a decimal adjustment associated with the strategy, which leads to the calculation of collateral and borrow values. The contract doesn't guard against scenarios where the Chainlink price might be negative or zero.\n\n## Impact\n\nIf the price returned by Chainlink is negative or zero, this will cause incorrect computation of the `collateralPrice` and `borrowPrice`. These inaccuracies will propagate to the valuation of collateral and borrow balances, which may be misrepresented.\n\n## Code Snippet\n\n[AaveLeverageStrategyExtension.sol#L884-L907](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L884-L907)\n\n## Tool used\n\nManual review\n\n## Recommendation\n\nTo rectify this vulnerability, it is recommended to incorporate a check that reverts the execution if the Chainlink price is less than or equal to zero. This will ensure that invalid price data does not result in inaccurate token valuations.\n\nIt's crucial to consider the edge cases of price data and to include suitable checks to manage these scenarios. This precaution will prevent potential manipulation or unexpected behavior in the contract.\n","decidedSeverity":"medium","decidedDuplication":"Chainlink's latestRoundData return stale or incorrect result"},{"file":"172.md","watson":{"name":"shogoki","days":3,"is_team":false,"payout":409.37,"score":41.5791826772,"senior":false},"severity":"medium","title":"Leverage Module will not work for some ERC20 Tokens (no allowance to 0 first)","markdown":"shogoki\n\nmedium\n\n# Leverage Module will not work for some ERC20 Tokens (no allowance to 0 first)\n\n## Summary \n\nThe Aave Leverage Module uses an Exchange Adapter to swap borrowed Tokens for a Collateral Token to build up Leverage, or vice versa to reduce leverage. Therefore the Token to swap has to be approved to the Exchange Contract. However this will fail (revert) for some Tokens, as there is not approve to 0 first, whcich is required by some ERC20 Tokens (e.g. USDT)\n\n## Vulnerability Detail\n\nIn `AaveLeverageModulev3` the function `_executeTrade` is used to swap Tokens with an exchange Adapter to either lever or delever the position. Inside this function there is a call to `invokeApprove` of the `Invoke.sol` Library, whcih is used on the SetToken interface.\nThe same `invokeApprove` method is used in `repayBorrow`, which is used to repay debt on Aaave.\nInside `invokeApprove` the Calldata for a regular `approve` for ERC20 Tokens is encoded and passed to the SetTokens generic `invoke` function.\nHowever there is no check for the current allowance or an attempt to reset the allowance to 0 first, which is a required by some ERC20 Tokens, like USDT. If there is an outstanding allowance for such a Token, they will revert on the approve call, when not first approved to 0. \nThis would result in the call to `_executeTrade` or `repayBorrow` to revert, and the Module failing to lever/delever respectively.  \nOr even being unable to repay a debt, because `repayBorrow` reverts, whcih could finally lead to a liquidation.\n\n## Impact\n\n- Contract functionality is broken, as no lever/delever is possible and calls always revert.\n- Contract might cannot repay debt, which can lead to liquidation.\n\n \n## Code Snippet\n\n\nUsage of invokeApprove inside AaaveLeverageModulev3:\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L763\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L806-L810\n\ninvokeApprove function:\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/lib/Invoke.sol#L46-L56\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\n- Check for existing allowance and Approve to 0 first, if required\n\nCan be achieved by using increaseAllowance, too. \n","decidedSeverity":"medium","decidedDuplication":"AmmModule will not work with usdt"},{"file":"173.md","watson":{"name":"Auditwolf","days":14,"is_team":false,"payout":248.39,"score":4.731352302,"senior":false},"severity":"high","title":"Function invoke borrow sends debt to address (_setToken ) instead of address  (_OnbehalfOf )","markdown":"Auditwolf\n\nhigh\n\n# Function invoke borrow sends debt to address (_setToken ) instead of address  (_OnbehalfOf )\n\n## Summary\n\n## Vulnerability Detail\n\nto get relevant borrow data this function calls getborrowcalldata function which defines Onbehalfof parameter as the Address of the user who will receive the debt. Should be the address of the borrower itself calling the function if he wants to borrow against his own collateral, or the address of the credit delegator if he has been given credit delegation allowance. The address parameter in the function invoke borrow however is set always to the address of the borrower itself ( address of the set token ) and not ( on behalf of ) address meaning the address of the set token will always receive debt even if the user specified another address.\n\n        ( , , bytes memory borrowCalldata) = getBorrowCalldata(\n            _lendingPool,\n            _asset,\n            _amountNotional,\n            _interestRateMode,\n            0, \n            address(_setToken)\n        );\n        \n## Impact\nIf the user has  a credit delegator and has specified its address they might not be able to receive debt.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/integration/lib/AaveV3.sol#L230C2-L247C9\n\n## Tool used\n\nManual Review\n\n## Recommendation\nReplace address (_setToken ) with address(_OnbehalfOf )\n","decidedSeverity":"false","decidedDuplication":"Function invoke borrow sends debt to address (_setToken ) instead of address  (_OnbehalfOf )"},{"file":"174.md","watson":{"name":"Auditwolf","days":14,"is_team":false,"payout":248.39,"score":4.731352302,"senior":false},"severity":"high","title":"Function repay reduces debt for the wrong address.","markdown":"Auditwolf\n\nhigh\n\n# Function repay reduces debt for the wrong address.\n\n## Summary\n\n## Vulnerability Detail\n\nTo get repay data this function calls getrepaycalldata function which defines Onbehalfof parameter as the Address of the user who will get his debt reduced/removed. Should be the address of the user calling the function if he wants to reduce/remove his own debt, or the address of any other borrower whose debt should be removed. In contrast , the address specified in the function invoke repay is to be always the msg.sender and not (_onbehalfof ) meaning the debt of the address (set token ) will always be reduced even though debt of another address was supposed to be reduced.\n\n \n        ( , , bytes memory repayCalldata) = getRepayCalldata(\n            _lendingPool,\n            _asset,\n            _amountNotional,\n            _interestRateMode,\n            address(_setToken)\n        );\n        \n\n## Impact\nusers can't reduce debt for other borrowers even if they wanted to do so.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/integration/lib/AaveV3.sol#L305C1-L324C6\n\n## Tool used\n\nManual Review\n\n## Recommendation\nReplace address(_setToken ) with address (_OnbehalfOf )\n","decidedSeverity":"false","decidedDuplication":"Function repay reduces debt for the wrong address."},{"file":"175.md","watson":{"name":"jasonxiale","days":32,"is_team":false,"payout":170.12,"score":1.3684321955,"senior":false},"severity":"medium","title":"Missing deadline checks allow pending transaction to be unexpected executed","markdown":"jasonxiale\n\nmedium\n\n# Missing deadline checks allow pending transaction to be unexpected executed\n\n## Summary\nMissing deadline checks allow pending transaction to be unexpected executed \n\n## Vulnerability Detail\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L794-L799\n```solidity\n\n        (\n            address targetExchange,\n            uint256 callValue,\n            bytes memory methodData\n        ) = _actionInfo.exchangeAdapter.getTradeCalldata(\n            address(_sendToken),\n            address(_receiveToken),\n            address(setToken),\n            notionalSendQuantity,\n            _actionInfo.minNotionalReceiveQuantity,\n            _data\n        );\n\n        setToken.invoke(targetExchange, callValue, methodData);\n```\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/AmmModule.sol#L430-L444\n```solidity\n\n    function _executeAddLiquidity(ActionInfo memory _actionInfo) internal {\n        (\n            address targetAmm, uint256 callValue, bytes memory methodData\n        ) = _actionInfo.ammAdapter.getProvideLiquidityCalldata(\n            address(_actionInfo.setToken),\n            _actionInfo.liquidityToken,\n            _actionInfo.components,\n            _actionInfo.totalNotionalComponents,\n            _actionInfo.liquidityQuantity\n        );\n\n        _executeComponentApprovals(_actionInfo);\n\n        _actionInfo.setToken.invoke(targetAmm, callValue, methodData);\n    }\n```\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/AmmModule.sol#L446-L460\n```solidity\n    function _executeAddLiquiditySingleAsset(ActionInfo memory _actionInfo) internal {\n        (\n            address targetAmm, uint256 callValue, bytes memory methodData\n        ) = _actionInfo.ammAdapter.getProvideLiquiditySingleAssetCalldata(\n            address(_actionInfo.setToken),\n            _actionInfo.liquidityToken,\n            _actionInfo.components[0],\n            _actionInfo.totalNotionalComponents[0],\n            _actionInfo.liquidityQuantity\n        );\n\n        _executeComponentApprovals(_actionInfo);\n\n        _actionInfo.setToken.invoke(targetAmm, callValue, methodData);\n    }\n```\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/AmmModule.sol#L462-L480\n```solidity\n    function _executeRemoveLiquidity(ActionInfo memory _actionInfo) internal {\n        (\n            address targetAmm, uint256 callValue, bytes memory methodData\n        ) = _actionInfo.ammAdapter.getRemoveLiquidityCalldata(\n            address(_actionInfo.setToken),\n            _actionInfo.liquidityToken,\n            _actionInfo.components,\n            _actionInfo.totalNotionalComponents,\n            _actionInfo.liquidityQuantity\n        );\n\n        _actionInfo.setToken.invokeApprove(\n            _actionInfo.liquidityToken,\n            _actionInfo.ammAdapter.getSpenderAddress(_actionInfo.liquidityToken),\n            _actionInfo.liquidityQuantity\n        );\n\n        _actionInfo.setToken.invoke(targetAmm, callValue, methodData);\n    }\n```\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/AmmModule.sol#L482-L500\n```solidity\n    function _executeRemoveLiquiditySingleAsset(ActionInfo memory _actionInfo) internal {\n        (\n            address targetAmm, uint256 callValue, bytes memory methodData\n        ) = _actionInfo.ammAdapter.getRemoveLiquiditySingleAssetCalldata(\n            address(_actionInfo.setToken),\n            _actionInfo.liquidityToken,\n            _actionInfo.components[0],\n            _actionInfo.totalNotionalComponents[0],\n            _actionInfo.liquidityQuantity\n        );\n\n        _actionInfo.setToken.invokeApprove(\n            _actionInfo.liquidityToken,\n            _actionInfo.ammAdapter.getSpenderAddress(_actionInfo.liquidityToken),\n            _actionInfo.liquidityQuantity\n        );\n\n        _actionInfo.setToken.invoke(targetAmm, callValue, methodData);\n    }\n```\n\n## Impact\nAMMs provide their users with an option to limit the execution of their pending actions, such as swaps or adding and removing liquidity. The most common solution is to include a deadline timestamp as a parameter (for example see Uniswap V2 and Uniswap V3). If such an option is not present, users can unknowingly perform bad trades:\n\nAlice wants to swap 100 tokens for 1 ETH and later sell the 1 ETH for 1000 DAI.\n\nThe transaction is submitted to the mempool, however, Alice chose a transaction fee that is too low for miners to be interested in including her transaction in a block. The transaction stays pending in the mempool for extended periods, which could be hours, days, weeks, or even longer.\n\nWhen the average gas fee dropped far enough for Alice's transaction to become interesting again for miners to include it, her swap will be executed. In the meantime, the price of ETH could have drastically changed. She will still get 1 ETH but the DAI value of that output might be significantly lower.\n\nShe has unknowingly performed a bad trade due to the pending transaction she forgot about.\n\nAn even worse way this issue can be maliciously exploited is through MEV:\n\nThe swap transaction is still pending in the mempool. Average fees are still too high for miners to be interested in it.\n\nThe price of tokens has gone up significantly since the transaction was signed, meaning Alice would receive a lot more ETH when the swap is executed. But that also means that her maximum slippage value (sqrtPriceLimitX96 and minOut in terms of the Spell contracts) is outdated and would allow for significant slippage.\n\nA MEV bot detects the pending transaction. Since the outdated maximum slippage value now allows for high slippage, the bot sandwiches Alice, resulting in significant profit for the bot and significant loss for Alice.\n## Code Snippet\n\n## Tool used\n\nManual Review\n\n## Recommendation\n","decidedSeverity":"medium","decidedDuplication":"`AaveLeverageStrategyExtension.sol` does not allow user to specify slippage parameter during rebalance or ripcord"},{"file":"176.md","watson":{"name":"moneyversed"},"severity":"medium","title":"Inefficient Iteration in StringArrayUtils.sol","markdown":"moneyversed\n\nmedium\n\n# Inefficient Iteration in StringArrayUtils.sol\n\n## Summary\n\nThe StringArrayUtils library uses a linear search to find a string in an array in the `indexOf` function. This approach is inefficient, and may lead to high gas costs if the array's size is large.\n\n## Vulnerability Detail\n\nThe `indexOf` function in StringArrayUtils.sol uses a for loop to iterate through the array and find the index of a given string. This operation is O(n), with n being the size of the array. In case the array is large, the operation may cost a significant amount of gas, which may make the function expensive to call.\n\n## Impact\n\nHigh gas costs, inefficient code execution.\n\n## Code Snippet\n\n```solidity\nfor (uint256 i = 0; i < length; i++) {\n    if (keccak256(bytes(A[i])) == keccak256(bytes(a))) {\n        return (i, true);\n    }\n}\n```\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/lib/StringArrayUtils.sol#L35-L43\n\n## Tool used\n\nManual Review\n\n## Recommendation \n\nConsider using a more efficient data structure to store and search for strings. For instance, a mapping of string to uint256 would allow constant-time lookups. However, you would lose the order of insertion, which may or may not be important in your use case.\n\n## Proof Of Concept (Steps to reproduce the vulnerability)\n\n1. Deploy the contract on a test network.\n2. Call the `indexOf` function with a large array and a string not present in the array. This will force the function to iterate through the whole array, leading to high gas costs.\n","decidedSeverity":"false","decidedDuplication":"Inefficient Iteration in StringArrayUtils.sol"},{"file":"177.md","watson":{"name":"moneyversed"},"severity":"high","title":"Unchecked Dependency in the `Position.sol` Contract","markdown":"moneyversed\n\nhigh\n\n# Unchecked Dependency in the `Position.sol` Contract\n\n## Summary\n\nThe `Position.sol` library contract heavily depends on the `ISetToken` contract for several operations, yet it does not verify the legitimacy or the trustworthiness of the `ISetToken` contract.\n\n## Vulnerability Detail\n\nThe library contract `Position.sol` interacts with an instance of `ISetToken` contract in several of its functions. It doesn't validate the contract address, nor does it ensure the correctness of the responses received from the `ISetToken` contract methods. If a malicious `ISetToken` contract is used, it could lead to security issues.\n\n## Impact\n\nUnverified interactions with the `ISetToken` contract can lead to a variety of potential issues. For example, a compromised `ISetToken` contract could return incorrect data or maliciously altered state, causing `Position.sol` to operate under false assumptions. This could potentially lead to loss of funds, incorrect calculations, or other undesired side effects.\n\n## Code Snippet\n\n```solidity\nfunction hasDefaultPosition(ISetToken _setToken, address _component) internal view returns(bool) {\n    return _setToken.getDefaultPositionRealUnit(_component) > 0;\n}\n\nfunction hasExternalPosition(ISetToken _setToken, address _component) internal view returns(bool) {\n    return _setToken.getExternalPositionModules(_component).length > 0;\n}\n\n// Other instances follow the same pattern.\n```\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/lib/Position.sol#L52-L54\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/lib/Position.sol#L59-L61\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nImplement a verification mechanism to ensure the trustworthiness of the `ISetToken` contract. This could be achieved by, for example, checking a registry of trusted contract addresses, or by verifying the contract bytecode. Moreover, consider implementing checks for the correctness of the data returned by `ISetToken` methods.\n\n## Proof Of Concept (Steps to reproduce the vulnerability)\n\n1. Deploy the contract `Position.sol` on a test network.\n2. Interact with it using a malicious `ISetToken` contract that returns incorrect data.\n3. Observe the incorrect operation of `Position.sol` due to the unverified dependency.","decidedSeverity":"false","decidedDuplication":"Unchecked Dependency in the `Position.sol` Contract"},{"file":"178.md","watson":{"name":"moneyversed"},"severity":"high","title":"Lack of Checks in SetTokenCreator can Lead to Invalid SetTokens","markdown":"moneyversed\n\nhigh\n\n# Lack of Checks in SetTokenCreator can Lead to Invalid SetTokens\n\n## Summary\n\nThe `create()` function in `SetTokenCreator.sol` doesn't properly validate the input it receives. Particularly, it fails to check whether the addresses in `_components` are smart contracts, not normal addresses, which could potentially lead to errors in other functions relying on these addresses being valid smart contracts.\n\n## Vulnerability Detail\n\nSetTokenCreator contract has a function named 'create'. The 'create' function does not check for the validity of the `_manager` address. There is no check whether the `_manager` address passed to the `create` function is a contract address or an externally owned address (EOA). If the `_manager` address is a contract, it should be checked whether the contract implements necessary functions that a manager contract should have.\n\nMoreover, there is no check for zero addresses in the `_modules` array. If a zero address is added to the `_modules` array, it could cause an unwanted behavior as zero address is an invalid address in Ethereum.\n\nThe create function also lacks the validation for duplicate module addresses in the `_modules` array. The same module can be added multiple times into the `_modules` array which can cause logical errors in other parts of the system.\n\n## Impact\n\nIf a malicious actor were to input non-smart contract addresses, it could potentially result in an error or undefined behavior in other functions that interact with the `_components`. This would likely lead to an interruption of the service, and it may expose other vulnerabilities.\n\n## Code Snippet\n\nIn `SetTokenCreator.sol`:\n\n```solidity\nfunction create(\n    address[] memory _components,\n    int256[] memory _units,\n    address[] memory _modules,\n    address _manager,\n    string memory _name,\n    string memory _symbol\n)\n    external\n    returns (address)\n{\n    require(_components.length > 0, \"Must have at least 1 component\");\n    require(_components.length == _units.length, \"Component and unit lengths must be the same\");\n    require(!_components.hasDuplicate(), \"Components must not have a duplicate\");\n    ...\n    // No validation of whether the addresses in _components are smart contracts\n}\n```\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/SetTokenCreator.sol#L66-L109\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nA possible solution to this problem would be to add a function that checks whether a given address is a smart contract. This function could be used to validate the input of `_components` in the `create()` function. The proposed changes to the `create()` function are shown below:\n\n```solidity\nfunction create(\n    address[] memory _components,\n    ...\n)\n    external\n    returns (address)\n{\n    require(_components.length > 0, \"Must have at least 1 component\");\n    ...\n    for (uint256 i = 0; i < _components.length; i++) {\n        require(isContract(_components[i]), \"Component must be a smart contract\");\n    }\n    ...\n}\n\nfunction isContract(address _addr) internal view returns (bool) {\n    uint32 size;\n    assembly {\n        size := extcodesize(_addr)\n    }\n    return (size > 0);\n}\n```\n\n## Proof Of Concept (Steps in order to reproduce the vulnerability)\n\n1. Deploy `SetTokenCreator.sol` with the current code base.\n2. Call the `create()` function with an array of addresses where at least one address is not a smart contract, an invalid `_manager` address, a zero address or duplicate addresses to the `_modules` array\n3. Observe that the function does not revert and proceeds to create a `SetToken` with these addresses.\n","decidedSeverity":"false","decidedDuplication":"Lack of Checks in SetTokenCreator can Lead to Invalid SetTokens"},{"file":"179.md","watson":{"name":"moneyversed"},"severity":"high","title":"Fee Assignment Vulnerabilities in Controller Contract","markdown":"moneyversed\n\nhigh\n\n# Fee Assignment Vulnerabilities in Controller Contract\n\n## Summary\n\nThe Controller contract manages a number of resources including modules and factories, and it also manages fees assigned to these modules. However, the contract allows for fees to be assigned and edited without proper checks. This can potentially allow a malicious owner to assign unexpected or excessive fees.\n\n## Vulnerability Detail\n\nIn the `addFee` and `editFee` functions, the Controller contract doesn't have a maximum limit on the fee percentage that can be set. There's also no check to see if the new fee percentage is less than or equal to 100%. This could lead to a situation where fees are unexpectedly high, causing issues in other parts of the system that interact with these fees.\n\nIn addition, the `editFee` function allows an existing fee to be modified, which could be used to unexpectedly increase fees. While this action can only be done by the contract owner, it's generally a good practice to enforce restrictions or checks on such actions to ensure the stability of the system.\n\n## Impact\n\nIf exploited, this could lead to the assignment of excessive fees that could lead to a drain of funds in the system, affecting users who interact with these modules. It could also lead to potential issues in other parts of the system that expect reasonable fee percentages.\n\n## Code Snippet\n\nThe relevant functions in the Controller contract are:\n\n```solidity\nfunction addFee(address _module, uint256 _feeType, uint256 _newFeePercentage) external onlyInitialized onlyOwner {\n    require(isModule[_module], \"Module does not exist\");\n    require(fees[_module][_feeType] == 0, \"Fee type already exists on module\");\n    fees[_module][_feeType] = _newFeePercentage;\n    emit FeeEdited(_module, _feeType, _newFeePercentage);\n}\n\nfunction editFee(address _module, uint256 _feeType, uint256 _newFeePercentage) external onlyInitialized onlyOwner {\n    require(isModule[_module], \"Module does not exist\");\n    require(fees[_module][_feeType] != 0, \"Fee type does not exist on module\");\n    fees[_module][_feeType] = _newFeePercentage;\n    emit FeeEdited(_module, _feeType, _newFeePercentage);\n}\n```\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/Controller.sol#L291-L299\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/Controller.sol#L308-L316\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIt's recommended to add an upper bound check on the `_newFeePercentage` in the `addFee` and `editFee` functions to ensure that the fee percentage can't exceed 100%. This can be done by adding a `require` statement that checks this condition, like so:\n\n```solidity\nrequire(_newFeePercentage <= 100, \"Fee percentage cannot exceed 100%\");\n```\n\nFurthermore, consider adding a restriction or a workflow for editing fees to ensure stability in the system. This could be in the form of a time lock, or a requirement for multiple signatures.\n\n## Proof Of Concept (Steps in order to reproduce the vulnerability)\n\n1. Deploy the Controller contract with a valid `_feeRecipient` address.\n2. Call the `addFee` function with a `_newFeePercentage` greater than 100%. The function will successfully execute.\n3. Similarly, if you call the `editFee` function with a `_newFeePercentage` greater than 100% on a fee that already exists, the function will also successfully execute.","decidedSeverity":"false","decidedDuplication":"Fee Assignment Vulnerabilities in Controller Contract"},{"file":"180.md","watson":{"name":"moneyversed"},"severity":"high","title":"Inadequate Access Control in addComponent Function","markdown":"moneyversed\n\nhigh\n\n# Inadequate Access Control in addComponent Function\n\n## Summary:\nThe `addComponent` function in `SetToken.sol` is subject to inadequate access control vulnerability. This function can add a new component to the `components` array but there is a lack of authorization check allowing only authorized addresses to add new components. This could allow any address to modify the state of the contract by adding new components to the `components` array.\n\n## Vulnerability Detail:\n\nIn the contract `SetToken`, the function `addComponent` is marked with two modifiers `onlyModule` and `whenLockedOnlyLocker`. The `onlyModule` modifier checks if the caller is an initialized module but does not prevent other addresses from calling the function. The `whenLockedOnlyLocker` modifier restricts access when the contract is locked but allows all addresses to call the function when it's not locked.\n\n## Impact:\n\nAn attacker could add malicious components to the `components` array and potentially disrupt the intended functionality of the contract. This could lead to unexpected behaviors and even loss of funds if the added component is malicious and has a functionality that compromises the safety of the contract.\n\n## Code Snippet:\n\n```solidity\nfunction addComponent(address _component) external onlyModule whenLockedOnlyLocker {\n    require(!isComponent(_component), \"Must not be component\");\n    \n    components.push(_component);\n\n    emit ComponentAdded(_component);\n}\n```\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/SetToken.sol#L217-L223\n\n## Tool used\n\nManual Review\n\n## Recommendation:\n\nConsider implementing additional access controls to ensure only authorized addresses can call the `addComponent` function. This could be achieved by maintaining a list of approved addresses or by introducing roles with the OpenZeppelin Access Control library.\n\n## Proof Of Concept:\n\nHere are the steps to reproduce the vulnerability:\n\n1. Deploy the contract `SetToken.sol` with the constructor parameters filled with the proper addresses and values.\n2. Call the function `addComponent` with any address. This will add the address to the `components` array.\n3. Call the `getComponents` function to verify that the address has been added to the `components` array. This shows that any address can call the `addComponent` function and add new components.","decidedSeverity":"false","decidedDuplication":"Inadequate Access Control in addComponent Function"},{"file":"181.md","watson":{"name":"moneyversed"},"severity":"medium","title":"Lack of Authorization Check for \"claim\" Function","markdown":"moneyversed\n\nmedium\n\n# Lack of Authorization Check for \"claim\" Function\n\n## Summary\n\nIn the provided `ClaimModule.sol`, there exists a lack of proper authorization checks for the `claim` function, allowing any external entity to call the function potentially leading to unauthorized claims.\n\n## Vulnerability Detail\n\nThe `claim` function in the `ClaimModule` smart contract lacks a specific requirement to check if the caller is an authorized entity. The `claim` function uses the `onlyValidCaller` modifier for authorization, but the `_isValidCaller` function it calls could allow unauthorized access. \n\nIf `anyoneClaim` is set to `true` for a given `SetToken`, any account (not just the manager) can call the `claim` function due to the following condition:\n\n```javascript\nfunction _isValidCaller(ISetToken _setToken) internal view returns(bool) {\n    return anyoneClaim[_setToken] || isSetManager(_setToken, msg.sender);\n}\n```\nWhile this could be an intended feature (to allow any user to claim rewards), it also potentially allows unauthorized claims if not handled properly at the administrative level.\n\n## Impact\n\nAn attacker could manipulate the claim process, effectively claiming rewards they are not entitled to. This could result in financial losses for the legitimate participants of the contract.\n\n## Code Snippet\n\n```javascript\nfunction claim(\n    ISetToken _setToken,\n    address _rewardPool,\n    string calldata _integrationName\n)\n    external\n    onlyValidAndInitializedSet(_setToken)\n    onlyValidCaller(_setToken)\n{\n    _claim(_setToken, _rewardPool, _integrationName);\n}\n```\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/ClaimModule.sol#L106-L116\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIt is recommended to implement an additional layer of authorization for the `claim` function to ensure only valid participants can make a claim. Consider revising the `_isValidCaller` function to incorporate more robust checks.\n\n## Proof of Concept (Steps in order to reproduce the vulnerability)\n\n1. Deploy the `ClaimModule` contract in a local environment.\n2. Call the `initialize` function, setting `anyoneClaim` to `true`.\n3. From a different address (other than the manager), call the `claim` function.\n4. Observe that the claim is processed without any errors, demonstrating that the contract does not adequately check the authorization of the caller.","decidedSeverity":"false","decidedDuplication":"Lack of Authorization Check for \"claim\" Function"},{"file":"182.md","watson":{"name":"sashik_eth","days":7,"is_team":false,"payout":694.43,"score":34.2886048499,"senior":false},"severity":"high","title":"onlyEOA modifier could be bypassed on L2","markdown":"sashik_eth\n\nhigh\n\n# onlyEOA modifier could be bypassed on L2\n\n## Summary\n\nThe `onlyEOA` modifier could be bypassed on L2.\n\n## Vulnerability Detail\n\n`BaseExtension.sol` include the `onlyEOA` modifier which checks that the current `msg.sedner` is equal to `tx.origin`:\n```solidity\nFile: BaseExtension.sol\n56:     /**\n57:      * Throws if caller is a contract, can be used to stop flash loan and sandwich attacks\n58:      */\n59:     modifier onlyEOA() {\n60:         require(msg.sender == tx.origin, \"Caller must be EOA Address\");\n61:         _;\n62:     }\n```\n\nAs we could from the comments - this modifier should prevent external contracts from interacting with a function that has this modifier (`rebalance` for example).\n\nHowever, since the protocol is expected to be deployed to different L2s, including Optimism, this restriction could be bypassed. \nDue to Optimism docs `tx.origin` could be not only the EOA address but any address that initialized L1 -> L2 messaging:\nhttps://community.optimism.io/docs/developers/build/differences/#opcode-differences\n\nSo it's a possible situation when a smart contract on L1 sends a message to L2 and calls the protocol contract effectively bypassing the `onlyEOA` modifier. Worth mentioning that due to the logic of `CREATE` opcode it's possible to create two smart contracts with the same address on different chains, in the way that contract on L1 would send messages and the contract on L2 would work with callbacks from ERC777, etc. \n\n## Impact\n\n`onlyEOA` modifier could be bypassed. Since it was built with the intention to prevent flashloan and sandwich attacks, this type of attack would become possible. \n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/lib/BaseExtension.sol#L60\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider reviewing flow that prevents external contracts from interacting with extensions.","decidedSeverity":"medium","decidedDuplication":"onlyEOA modifier that ensures call is from EOA might not hold true with the eip 3074"},{"file":"183.md","watson":{"name":"Saeedalipoor01988"},"severity":"medium","title":"LastTradeTimestamp value for exchange is not updated in the disengage function.","markdown":"Saeedalipoor01988\n\nmedium\n\n# LastTradeTimestamp value for exchange is not updated in the disengage function.\n\n## Summary\nThe [globalLastTradeTimestamp and exchangeLastTradeTimestamp](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1207) values don't update in the [disengage ](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L412)function.\n\n## Vulnerability Detail\n\n```solidity\n     function _updateLastTradeTimestamp(string memory _exchangeName) internal {\n        globalLastTradeTimestamp = block.timestamp;\n        exchangeSettings[_exchangeName].exchangeLastTradeTimestamp = block.timestamp;\n     }\n\n```\nThis function updates both the exchange-specific and global timestamp so that the epoch rebalance can use the global timestamp (since the global timestamp is always equal to the most recently used exchange timestamp). This allows for multiple rebalances to occur simultaneously since only the exchange-specific timestamp is checked for non-epoch rebalances.\n\nBefore any trade execution, this function gets called in ripcord, iterateRebalance, rebalance and engage functions to update both the exchange-specific and global timestamp.\n\nBut in the [disengage ](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L412)function, trade execution get done without update LastTradeTimestamp for the exchange-specific and global timestamp.\n\n**What this means for investors: the TWAP Cooldown Period allows time for the relevant liquidity pools that the FLI contracts trade against during rebalancing to absorb the most recent rebalance transaction before submitting a subsequent one. Allowing the liquidity pool to rebalance after each trade shields FLI products from unfavorable slippage, minimizing operational costs and preserving AUM.**\n\nhttps://docs.indexcoop.com/index-coop-community-handbook/products/flexible-leverage-indices/fli-technical-documentation/fli-product-parameters#twap-cooldown-period\n\n## Impact\nPlease check the Vulnerability Detail.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L412\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1207\n\n## Tool used\nManual Review\n\n## Recommendation\nUpdate globalLastTradeTimestamp and exchangeLastTradeTimestamp values before the trade.","decidedSeverity":"false","decidedDuplication":"LastTradeTimestamp value for exchange is not updated in the disengage function."},{"file":"184.md","watson":{"name":"Cryptor","days":26,"is_team":false,"payout":47.1,"score":0.864264114,"senior":false},"severity":"false","title":"false","markdown":"Cryptor\n\nfalse\n\n# false\n\n","decidedSeverity":"false","decidedDuplication":"false"},{"file":"185.md","watson":{"name":"Diana","days":3,"is_team":false,"payout":0,"score":0.0011486465,"senior":false},"severity":"medium","title":"Missing onlyOperator modifier on transferTokens()","markdown":"Diana\n\nmedium\n\n# Missing onlyOperator modifier on transferTokens()\n\n## Summary\nThe function transferTokens() is missing the `onlyOperator` modifier. As per the comments, this should be OPERATOR ONLY.\n\n## Vulnerability Detail\nAs per the comment on [line 310](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/manager/BaseManagerV2.sol#L310), the function `transferTokens()` should be OPERATOR ONLY\n> * OPERATOR ONLY: Transfers _tokens held by the manager to _destination.\n\nHowever, the `onlyOperator` modifier is missing from this function \n\nIn all of the other functions, for instance, [addModule()](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/manager/BaseManagerV2.sol#L323-L327), [removeModule()](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/manager/BaseManagerV2.sol#L332-L337), [emergencyRemoveProtectedModule()](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/manager/BaseManagerV2.sol#L356) etc. - the natspec mentioned these to be OPERATOR ONLY, and they correctly have the `onlyOperator` modifier set.\n\n## Impact\ntransferTokens() is missing the `onlyOperator` modifier. Since this function transfers `_tokens` held by the manager to `_destination`, and can be used to recover anything sent here - proper checks as mentioned in the natspec, must be maintained\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/manager/BaseManagerV2.sol#L318\n\n```solidity\nfunction transferTokens(address _token, address _destination, uint256 _amount) external onlyExtension {\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\nImplement `onlyOperator` modifier for function transferTokens()","decidedSeverity":"medium","decidedDuplication":"Wrong modifier in `transferTokens()`"},{"file":"186.md","watson":{"name":"XDZIBEC"},"severity":"high","title":"XO-Unauthorized Access in isAllowedCaller Function","markdown":"XDZIBEC\n\nhigh\n\n# XO-Unauthorized Access in isAllowedCaller Function\n\n## Summary\n- The `isAllowedCaller` function does not check the `callAllowList` mapping if the `anyoneCallable` variable is set to `true.` This  can allows anyone to call the function, even if they are not authorized to do so.\n## Vulnerability Detail\n ```solidity\n\n    /**\n     * Determine if passed address is allowed to call function. If anyoneCallable set to true anyone can call otherwise needs to be approved.\n     *\n     * return bool Boolean indicating if allowed caller\n     */\n    function isAllowedCaller(address _caller) internal view virtual returns (bool) {\n        return anyoneCallable || callAllowList[_caller];\n    }\n}\n```\n- There is a vulnerability in the `isAllowedCaller` function,  so the `anyoneCallable` variable is a boolean value that indicates whether anyone can call the function. If` anyoneCallable` is true, then any address can call the function, even if it is not in the `callAllowList` mapping, The problem  is that the` callAllowList` mapping is only checked if `anyoneCallable` is false. this means that if `anyoneCallable` is true, then the function will always return true, regardless of whether the address is in the `callAllowList` mapping, this vulnerability allow an attacker to steal funds or data from the contract.\n\n## Impact\n- An attacker can steal funds or data from the contract if exploit this vulnerability.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/lib/BaseExtension.sol#L139C1-L148C2\n## Tool used\n\nManual Review\n\n## Recommendation\n- change the `isAllowedCaller` function so that it checks the `callAllowList` mapping regardless of the value of the `anyoneCallable` variable. ","decidedSeverity":"false","decidedDuplication":"XO-Unauthorized Access in isAllowedCaller Function"},{"file":"187.md","watson":{"name":"Diana","days":3,"is_team":false,"payout":0,"score":0.0011486465,"senior":false},"severity":"medium","title":"Use of deprecated chainlink function: latestAnswer()","markdown":"Diana\n\nmedium\n\n# Use of deprecated chainlink function: latestAnswer()\n\n## Summary\nAccording to Chainlink’s documentation ([API Reference](https://docs.chain.link/data-feeds/price-feeds/api-reference#latestanswer)), the `latestAnswer()` function is deprecated. This function does not throw an error if no answer has been reached, but instead returns 0, possibly causing an incorrect price to be fed to the different price feeds or even a Denial of Service by a division by zero.\n\n## Vulnerability Detail\nAccording to Chainlink’s documentation ([API Reference](https://docs.chain.link/data-feeds/price-feeds/api-reference#latestanswer)), the `latestAnswer()` function is deprecated. This function does not throw an error if no answer has been reached, but instead returns 0,  causing an incorrect price to be fed to the different price feeds.\n\n## Impact\nThe `latestAnswer()` function is deprecated. This could lead to stale prices. \nThis function does not throw an error if no answer has been reached, but instead returns 0,  causing an incorrect price to be fed to the different price feeds.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L895\n\n```solidity\n        int256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\n```\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L897\n\n```solidity\n        int256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer();\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\nIt is recommended to use Chainlink’s `latestRoundData()` function to get the price instead. It is also recommended to add checks on the return data with proper revert messages if the price is stale or the round is incomplete.","decidedSeverity":"medium","decidedDuplication":"Deprecated oracle function `latestAnswer()` could bring fund loss"},{"file":"188.md","watson":{"name":"XDZIBEC"},"severity":"medium","title":"XO- Runtime Error in removeStorage Function of StringArrayUtils Library","markdown":"XDZIBEC\n\nmedium\n\n# XO- Runtime Error in removeStorage Function of StringArrayUtils Library\n\n## Summary\n- The` removeStorage` function can cause a `runtime error` if the `index` is equal to the length of the `array`. This can lead to data loss or other problems.\n## Vulnerability Detail\n```solidity\n   /**\n     * @param A The input array to search\n     * @param a The string to remove\n     */\n    function removeStorage(string[] storage A, string memory a)\n        internal\n    {\n        (uint256 index, bool isIn) = indexOf(A, a);\n        if (!isIn) {\n            revert(\"String not in array.\");\n        } else {\n            uint256 lastIndex = A.length - 1; // If the array would be empty, the previous line would throw, so no underflow here\n            if (index != lastIndex) { A[index] = A[lastIndex]; }\n            A.pop();\n        }\n    }\n}\n```\n- There is a vulnerability in  the `removeStorage` function in the `StringArrayUtils` library, the problem is this `if (index != lastIndex) { A[index] = A[lastIndex]; }` tries to copy the value of the last element in the array to the element at the index where the string was found, if the index is equal to the length of the array, then the element at the index does not exist. This will cause a runtime error.\n\n## Impact\n- If an attacker exploit this vulnerabiity could cause data loss:\n    - An attacker sends a malicious transaction to the contract that calls the `removeStorage` function with a string that is not in the array.\n    - The `removeStorage` function will check the `indexOf` function to see if the string is in the `array`.\n    - The `indexOf` function will return false because the string is not in the` array`.\n    - The `removeStorage` function will then try to copy the value of the last element in the `array` to the element at the `index` where the string was found.\n    - Since the `index` is equal to the `length` of the `array`, the element at the `index` does not exist.\n    -This will cause a `runtime error` and the data in the `array` will be `lost`.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/lib/StringArrayUtils.sol#L45C1-L61C2\n## Tool used\n\nManual Review\n\n## Recommendation\n-  change the `removeStorage` function so that it checks to make sure that the index is less than the length of the array before trying to copy the value of the last element\n","decidedSeverity":"false","decidedDuplication":"XO- Runtime Error in removeStorage Function of StringArrayUtils Library"},{"file":"189.md","watson":{"name":"XDZIBEC"},"severity":"medium","title":"XO-Missing Library Import and Incorrect Function Usage in removeSet Function","markdown":"XDZIBEC\n\nmedium\n\n# XO-Missing Library Import and Incorrect Function Usage in removeSet Function\n\n## Summary\n- The `removeSet` function can cause a runtime error if the address is not in the sets mapping. This can lead to data loss or other problems.\n## Vulnerability Detail\n```solidity\n/**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to remove a Set\n     *\n     * @param _setToken               Address of the SetToken contract to remove\n     */\n    function removeSet(address _setToken) external onlyInitialized onlyOwner {\n        require(isSet[_setToken], \"Set does not exist\");\n\n        sets = sets.remove(_setToken);\n\n        isSet[_setToken] = false;\n\n        emit SetRemoved(_setToken);\n    }\n```\n- there is a vulnerability in the `removeSet` function, the problem is in the line `sets = sets.remove(_setToken);`, this line  is tries to remove the `_setToken` from the `sets` mapping, if the `_setToken` is not in the `sets` mapping, then this will cause a runtime error.\n## Impact\n- if an attacker exploit this it's can cause a runtime error, which can lead to data loss or other problems.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/Controller.sol#L170C2-L183C6\n## Tool used\n\nManual Review\n\n## Recommendation\n-  add a check to make sure that the `_setToken` is in the `sets` mapping before trying to remove it.","decidedSeverity":"false","decidedDuplication":"XO-Missing Library Import and Incorrect Function Usage in removeSet Function"},{"file":"190.md","watson":{"name":"XDZIBEC"},"severity":"medium","title":"XO- Missing Parameter Passing in SetTokenCreator's create Function","markdown":"XDZIBEC\n\nmedium\n\n# XO- Missing Parameter Passing in SetTokenCreator's create Function\n\n## Summary\n- The create function of the `SetTokenCreato`r contract does not pass the `positionState` parameter to the `SetToken` constructor. This could lead to unexpected behavior, such as the `SetToken` not performing as expected.\n## Vulnerability Detail\n```solidity\n      // Creates a new SetToken instance\n        SetToken setToken = new SetToken(\n            _components,\n            _units,\n            _modules,\n            controller,\n            _manager,\n            _name,\n            _symbol\n```\n- The  `SetTokenCreator` contract  has vulnerability in the `create` function,  the problem is that the `SetToken` constructor takes an additional parameter, `positionState`, which is the initial state of the position, this parameter is not being passed to the constructor, which could lead to unexpected behavior.\n## Impact\n- The `SetToken` could be created in an invalid state. This could prevent the `SetToken` from functioning properly.\n- The `SetToken` could be created with the wrong initial `positionState`. This could result in the `SetToken` performing differently than expected.\n- The `SetToken` could be created with the wrong manager. This could prevent the `SetToken` from being managed properly.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/SetTokenCreator.sol#L92C2-L101C11\n## Tool used\n\nManual Review\n\n## Recommendation\n- the create function should be updated to pass the positionState parameter to the SetToken constructor.","decidedSeverity":"false","decidedDuplication":"XO- Missing Parameter Passing in SetTokenCreator's create Function"},{"file":"191.md","watson":{"name":"yy","days":3,"is_team":false,"payout":0,"score":0.0011486465,"senior":false},"severity":"medium","title":"Lack of validation on _name and _symbol","markdown":"yy\n\nmedium\n\n# Lack of validation on _name and _symbol\n\n## Summary\nNo checking on _name and _symbol\n\n## Vulnerability Detail\nThe function accept `_name` and `_symbol` are left empty, the contract will still be deployed. \n\n## Impact\nIf `_name` and `_symbol` are left empty, the contract will still be deployed. The token will exist but it may not be easy to identify.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/SetTokenCreator.sol#L66\n\n## Tool used\nManual Review\n\n## Recommendation\nAdd a check for `_name` and `_symbol` to ensure that they are not empty","decidedSeverity":"false","decidedDuplication":"Lack of validation on _name and _symbol"},{"file":"192.md","watson":{"name":"ChaseTheLight"},"severity":"medium","title":"Contract can receive ETH with no way to withdraw","markdown":"ChaseTheLight\n\nmedium\n\n# Contract can receive ETH with no way to withdraw\n\n## Summary\n\nThe contract ```setToken``` contains a payable ```receive()``` function however contains no functionality to withdraw/retrieve received Ether thus potentially permanently locking all received Ether. \n\n## Vulnerability Detail\n\nThis smart contract represents a vulnerability as it contains a payable receive function that allows it to accept Ether, but it lacks a function to withdraw or transfer this Ether out of the contract. This design flaw essentially creates a black hole for funds: Ether can enter, but it can't leave. Any Ether sent to this contract will be trapped.\n\n## Impact\n\nA permanent loss of Ether received by the contract\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/tree/main/index-protocol/contracts/protocol/SetToken.sol#L43\n```javascript\ncontract SetToken is ERC20 {\n```\n\nhttps://github.com/sherlock-audit/2023-05-Index/tree/main/index-protocol/contracts/protocol/SetToken.sol#L536\n```javascript\nreceive() external payable {}\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nImplement a withdrawal function, accessible only to a trusted role such as the contract owner, to avoid the permanent loss of funds. Additionally, proper access controls should be enforced to prevent unauthorized withdrawal of funds.","decidedSeverity":"false","decidedDuplication":"Contract can receive ETH with no way to withdraw"},{"file":"193.md","watson":{"name":"XDZIBEC"},"severity":"medium","title":"XO-Lack of Balance Check in invokeWrapWETH() Function Leads to Out of Gas Error","markdown":"XDZIBEC\n\nmedium\n\n# XO-Lack of Balance Check in invokeWrapWETH() Function Leads to Out of Gas Error\n\n## Summary\n- The `invokeWrapWETH` function does not check to see if the user has enough `ETH` to `wrap`. This could lead to a user losing their `ETH` if they try to wrap more `ETH` than they have.\n## Vulnerability Detail\n```solidity\n /**\n     * Instructs the SetToken to wrap the passed quantity of ETH\n     *\n     * @param _setToken        SetToken instance to invoke\n     * @param _weth            WETH address\n     * @param _quantity        The quantity to unwrap\n     */\n    function invokeWrapWETH(ISetToken _setToken, address _weth, uint256 _quantity) internal {\n        bytes memory callData = abi.encodeWithSignature(\"deposit()\");\n        _setToken.invoke(_weth, _quantity, callData);\n    }\n}\n```\n- There is a vulnerability  in the line that calls the `deposit()` function on the `SetToken` contract. The `deposit()` function requires that the user have a balance of `ETH` in their` wallet`, but the `invokeWrapWETH()` function does not check to see if the user has enough `ETH`. This means that a user could call the `invokeWrapWETH()` function and pass in a quantity of `ETH` that they do not have, which would result in an `Out of Gas error`, this leading users to losing their ETH if they try to wrap more ETH than they have\n## Impact\n- An example :\n  1 - Alice wants to wrap 1 ETH.\n  2 - She calls the `invokeWrapWETH` function and passes in a quantity of 1 ETH.\n  3 - The `invokeWrapWETH` function does not check to see if Alice has enough ETH.\n  4 -  Alice does not have enough ETH.\n  5 -  The `invokeWrapWETH` function fails and Alice loses her ETH.\n- The vulnerability lead to Alice losing her ETH\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/lib/Invoke.sol#L133\n## Tool used\n\nManual Review\n\n## Recommendation\n- The `invokeWrapWETH()` function should be updated to check to see if the user has enough `ETH` before calling the `deposit()` function.\n- The `invokeWrapWETH` function could be updated to throw an error if the user does not have enough `ETH`.","decidedSeverity":"false","decidedDuplication":"XO-Lack of Balance Check in invokeWrapWETH() Function Leads to Out of Gas Error"},{"file":"194.md","watson":{"name":"XDZIBEC"},"severity":"medium","title":"XO-Flawed Collateralization Validation in IssuanceValidationUtils Library","markdown":"XDZIBEC\n\nmedium\n\n# XO-Flawed Collateralization Validation in IssuanceValidationUtils Library\n\n## Summary\n- The `validateCollateralizationPostTransferOut` function does not handle the case where the final set supply is `zero`. This could prevent users from redeeming their `tokens` from a `SetToken`, which could lead to financial `loss`.\n## Vulnerability Detail\n```SOLIDITY\n   function validateCollateralizationPostTransferOut(\n        ISetToken _setToken, \n        address _component, \n        uint256 _finalSetSupply\n    )\n        internal \n        view \n    {\n        uint256 newComponentBalance = IERC20(_component).balanceOf(address(_setToken));\n\n        uint256 defaultPositionUnit = _setToken.getDefaultPositionRealUnit(address(_component)).toUint256();\n\n        require(\n            // Use preciseMulCeil to increase lower bound and maintain over-collateralization\n            newComponentBalance >= _finalSetSupply.preciseMulCeil(defaultPositionUnit),\n            \"Invalid transfer out. Results in undercollateralization\"\n        );\n    }\n}\n\n```\n- There is a vulnerability is in the line that `requires` the new component` balance` to be greater than or equal to the final set supply multiplied by the default position `unit`. This is not always the case, because the final set supply may be zero. For example, if a user redeems all of the tokens from a `SetToken`, the final set supply will be zero. In this case, the require statement will always fail, which will prevent the user from redeeming their tokens.\n## Impact\n- It could prevent users from accessing their funds if the `SetToken` is hacked.\n- It could prevent users from participating in governance if the `SetToken` is a governance token.\n- It could prevent users from earning rewards if the `SetToken` is a yield farming token.\n## Code Snippet\n- https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/lib/IssuanceValidationUtils.sol#L75C1-L75C1\n## Tool used\n\nManual Review\n\n## Recommendation\n- The `validateCollateralizationPostTransferOut` function could be updated to check if the final set supply is zero. If the final set supply is zero, the function could return without requiring the new component balance to be greater than or equal to the default position unit.\n- The `validateCollateralizationPostTransferOut` function could be updated to throw an error if the final set supply is zero. This would prevent users from trying to redeem their tokens if the final set supply is zero.","decidedSeverity":"false","decidedDuplication":"XO-Flawed Collateralization Validation in IssuanceValidationUtils Library"},{"file":"195.md","watson":{"name":"XDZIBEC"},"severity":"medium","title":"XO-Null Pointer Exception When Calling hasDuplicate on Empty Array.","markdown":"XDZIBEC\n\nmedium\n\n# XO-Null Pointer Exception When Calling hasDuplicate on Empty Array.\n\n## Summary\n- The vulnerability occurs in the `AddressArrayUtils` library when calling the `hasDuplicate` function on an empty array without checking the length of the array beforehand. This results in a null pointer exception, as the `hasDuplicate` function is called with an empty array.\n## Vulnerability Detail\n```solidity\n  /**\n     * Validate address array is not empty and contains no duplicate elements.\n     *\n     * @param A          Array of addresses\n     */\n    function _validateLengthAndUniqueness(address[] memory A) internal pure {\n        require(A.length > 0, \"Array length must be > 0\");\n        require(!hasDuplicate(A), \"Cannot duplicate addresses\");\n    }\n}\n```\n- The vulnerability is in the line that calls the `hasDuplicate` function. The `hasDuplicate `function takes an array of addresses as input and returns true if the array contains any `duplicate` addresses. However, the _`validateLengthAndUniqueness` function does not check the length of the array before calling `hasDuplicate`. This means that if the array is empty, the `hasDuplicate` function will be called with a null pointer exception.\n## Impact\n- An  attackers can exploit this vulnerability and  gain access to a system or steal data.\n## Code Snippet\n- https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/lib/AddressArrayUtils.sol#L222\n## Tool used\n\nManual Review\n\n## Recommendation\n-  the _validateLengthAndUniqueness function should be updated to check the length of the array before calling hasDuplicate.","decidedSeverity":"false","decidedDuplication":"XO-Null Pointer Exception When Calling hasDuplicate on Empty Array."},{"file":"196.md","watson":{"name":"XDZIBEC"},"severity":"high","title":"XO-Invalid Check in PreciseUnitMath.neg Function","markdown":"XDZIBEC\n\nhigh\n\n# XO-Invalid Check in PreciseUnitMath.neg Function\n\n## Summary\n- The require statement in the `neg` function is always true, because the minimum value of an `int256 is -2**256`. This means that the require statement will never be triggered, and the `neg` function can always be called, even if a is negative. This could allow an attacker to cause the contract to behave in an unexpected way.\n## Vulnerability Detail\n```solidity\n/**\n     * Returns the negation of a\n     */\n    function neg(int256 a) internal pure returns (int256) {\n        require(a > MIN_INT_256, \"Inversion overflow\");\n        return -a;\n    }\n}\n```\n- The vulnerability is in the `require` statement. the condition `a > MIN_INT_256` will always be `true`, because the `minimum` value of an `int256 is -2**256`. this means that the `require` statement will never be `triggered`, and the `neg` function will always be able to be `called`, even if `a` is negative. This could allow an attacker to cause the contract to behave in an unexpected way.\n- In the `neg` function, the require statement is intended to ensure that negating a does not result in an overflow, the condition \n`a > MIN_INT_256` is incorrect because `MIN_INT_256` is already the minimum value of an `int256`. As a result, the require statement will always evaluate to true, allowing the negation of a even if it is negative\n## Impact\n- This vulnerability allow an attacker to cause the contract to behave in an unexpected way.\n## Code Snippet\n- https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/lib/PreciseUnitMath.sol#L231\n## Tool used\n\nManual Review\n\n## Recommendation\n- the `require` statement should be changed to `require(a < 0, \"Inversion overflow\");` this will ensure that the `neg` function can only be called if `a` is negative.\n","decidedSeverity":"false","decidedDuplication":"XO-Invalid Check in PreciseUnitMath.neg Function"},{"file":"197.md","watson":{"name":"XDZIBEC"},"severity":"medium","title":"XO-Unused Gas Parameter in ` SafeERC20.safeTransferFrom` Function","markdown":"XDZIBEC\n\nmedium\n\n# XO-Unused Gas Parameter in ` SafeERC20.safeTransferFrom` Function\n\n## Summary\n- There is a vulnerability in the ` SafeERC20.safeTransferFrom` function. The `safeTransferFrom` function takes a third parameter, which is the `gas` that should be used for the `transfer`, the `gas` parameter is not being used in the code. This means that the `transfer` could fail if the `gas` provided by the caller is not enough.\n## Vulnerability Detail\n```solidity\n    function transferFrom(\n        IERC20 _token,\n        address _from,\n        address _to,\n        uint256 _quantity\n    )\n        internal\n    {\n        // Call specified ERC20 contract to transfer tokens (via proxy).\n        if (_quantity > 0) {\n            uint256 existingBalance = _token.balanceOf(_to);\n\n            SafeERC20.safeTransferFrom(\n                _token,\n                _from,\n                _to,\n                _quantity\n            );\n\n            uint256 newBalance = _token.balanceOf(_to);\n\n            // Verify transfer quantity is reflected in balance\n            require(\n                newBalance == existingBalance.add(_quantity),\n                \"Invalid post transfer balance\"\n            );\n        }\n    }\n}\n```\n- In the `SafeERC20.safeTransferFrom` function, the `gas` parameter is included but not utilized within the code. This means that regardless of the `gas` value provided by the `caller`, the `transfer` will use the default `amount` of `gas`. If the default `gas` is not sufficient to complete the `transfer`, the `transaction` may fail, resulting in an incomplete `transfer` or an erroneous state.\n## Impact\n- If the transfer fails, the user may lose the tokens that they were trying to transfer.\n-  an attacker could exploit this vulnerability in the contract and can lead to loss of funds or other damage.\n## Code Snippet\n- https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/lib/ExplicitERC20.sol#L43C1-L71C2\n## Tool used\n\nManual Review\n\n## Recommendation\n- the `SafeERC20.safeTransferFrom` function should be called with a `gas` parameter.\n- fixing code :\n```solidity\nfunction transferFrom(\n        IERC20 _token,\n        address _from,\n        address _to,\n        uint256 _quantity,\n        uint256 _gas\n    )\n        internal\n    {\n        // Call specified ERC20 contract to transfer tokens (via proxy).\n        if (_quantity > 0) {\n            // Get the balance of the `_to` address before the transfer.\n            uint256 existingBalance = _token.balanceOf(_to);\n\n            // Transfer tokens from the `_from` address to the `_to` address.\n            SafeERC20.safeTransferFrom(\n                _token,\n                _from,\n                _to,\n                _quantity,\n                _gas\n            );\n\n            // Get the balance of the `_to` address after the transfer.\n            uint256 newBalance = _token.balanceOf(_to);\n\n            // Verify that the balance has increased by the quantity transferred.\n            require(\n                newBalance == existingBalance.add(_quantity),\n                \"Invalid post transfer balance\"\n            );\n        }\n    }\n```","decidedSeverity":"false","decidedDuplication":"XO-Unused Gas Parameter in ` SafeERC20.safeTransferFrom` Function"},{"file":"198.md","watson":{"name":"Phantasmagoria"},"severity":"medium","title":"Use of deprecated chainlink function","markdown":"Phantasmagoria\n\nmedium\n\n# Use of deprecated chainlink function\n\n## Summary\nChainlink's `latestAnswer` may return incorrect price\n## Vulnerability Detail\nAccording to Chainlink’s documentation (API Reference), the `latestAnswer` function is deprecated. This function does not throw an error if no answer has been reached, but instead returns 0, possibly causing an incorrect price to be fed to the different price feeds or even a Denial of Service by a division by zero.\n\n## Impact\nThis function might suddenly stop working if Chainlink stop supporting deprecated APIs. And the old API can return stale data.\n\n## Code Snippet\nhttps://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/adapters/AaveLeverageStrategyExtension.sol#L895-L897\n## Tool used\n\nManual Review\n\n## Recommendation\nIt is recommended to use Chainlink’s latestRoundData() function to get\nthe price instead. It is also recommended to add checks on the return\ndata with proper revert messages if the price is stale or the round is\nincomplete, for example:\n```solidity\n1: ( uint80 baseRoundID , int256 answer , , uint256 baseTimestamp , uint80 baseAnsweredInRound ) = assetChainlinkPriceFeed.latestAnswer() ;\n2: require( answer > 0, \" ChainlinkPriceOracle : answer <= 0\");\n3: require( baseAnsweredInRound >= baseRoundID , \" ChainlinkPriceOracle : Stale price \");\n4: require( baseTimestamp > 0, \" ChainlinkPriceOracle : Round not complete \");\n5: uint256 _price = uint256(answer);\n```","decidedSeverity":"medium","decidedDuplication":"Deprecated oracle function `latestAnswer()` could bring fund loss"},{"file":"199.md","watson":{"name":"Phantasmagoria"},"severity":"medium","title":"Missing checks for whether Arbitrum Sequencer is active","markdown":"Phantasmagoria\n\nmedium\n\n# Missing checks for whether Arbitrum Sequencer is active\n\n## Summary\nUsing Chainlink in L2 chains such as Arbitrum requires to check if the sequencer is down to avoid prices from looking like they are fresh although they are not.\n## Vulnerability Detail\nAs we know protocol will be deployed on different chains including Arbitrum and Optimism\n\nChainlink recommends that users using price oracles, check whether the Arbitrum sequencer is active\nhttps://docs.chain.link/data-feeds#l2-sequencer-uptime-feeds\nIf the sequencer goes down, the index oracles may have stale prices, since L2-submitted transactions (i.e. by the aggregating oracles) will not be processed.\n## Impact\nPrices may look like they are fresh but in reality they are not. If sequencer go down and stale price is returned `collateralValue` and `borrowValue` may be calculated incorrectly which are used when leveraging and deleveraging. \n## Code Snippet\nhttps://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/adapters/AaveLeverageStrategyExtension.sol#L895-L897\n## Tool used\n\nManual Review\n\n## Recommendation\nIt is recommended to follow the code example of Chainlink:\nhttps://docs.chain.link/data-feeds/l2-sequencer-feeds#example-code","decidedSeverity":"medium","decidedDuplication":"Missing checks for whether Arbitrum Sequencer is active"},{"file":"200.md","watson":{"name":"Phantasmagoria"},"severity":"medium","title":"Interactions with AMMs do not use deadlines for operations","markdown":"Phantasmagoria\n\nmedium\n\n# Interactions with AMMs do not use deadlines for operations\n\n## Summary\nThe absence of a deadline check in trading transactions can result in pending transactions\n\n## Vulnerability Detail\nThe transaction can be pending in mempool for a long and the trading activity is very time senstive. Without deadline check, the trade transaction can be executed in a long time after the user submit the transaction, at that time, the trade can be done in a sub-optimal price, which harms user's position.\n\nThe deadline check ensure that the transaction can be executed on time and the expired transaction revert.\n## Impact\nIf the deadline check is absent, the trade transaction may take a considerable amount of time to be executed after the user submits it. During this period, the trade could be completed at a sub-optimal price, resulting in harm to the user's position.\n## Code Snippet\nhttps://github.com/IndexCoop/index-protocol/blob/86be7ee76d9a7e4f7e93acfc533216ebef791c89/contracts/protocol/modules/v1/AmmModule.sol#L108-L115\n\nhttps://github.com/IndexCoop/index-protocol/blob/86be7ee76d9a7e4f7e93acfc533216ebef791c89/contracts/protocol/modules/v1/AmmModule.sol#L155-L162\n\nhttps://github.com/IndexCoop/index-protocol/blob/86be7ee76d9a7e4f7e93acfc533216ebef791c89/contracts/protocol/modules/v1/AmmModule.sol#L206-L213\n\nhttps://github.com/IndexCoop/index-protocol/blob/86be7ee76d9a7e4f7e93acfc533216ebef791c89/contracts/protocol/modules/v1/TradeModule.sol#L116-L124\n## Tool used\n\nManual Review\n\n## Recommendation\nAdd deadline arguments to all functions that interact with AMMs, and pass it along to AMM calls","decidedDuplication":"`AaveLeverageStrategyExtension.sol` does not allow user to specify slippage parameter during rebalance or ripcord","decidedSeverity":"medium"},{"file":"201.md","watson":{"name":"IamZKdevETH"},"severity":"medium","title":"Effective way of adding and Removing components  array in SetToken","markdown":"IamZKdevETH\n\nmedium\n\n# Effective way of adding and Removing components  array in SetToken\n\n## Summary\nThis audit report assesses the implementation of adding and removing components in the provided smart contract. The contract includes an address[] public components array for storing component addresses. The report highlights the existing code and proposes improvements to handle adding and removing components efficiently.\n\n## Vulnerability Detail\nThe current implementation of adding and removing components uses an array and a mapping. While the implementation is functional, there are opportunities for improvement. The code can be optimized to handle adding and removing components more efficiently and maintain an accurate index mapping.\n\n## Impact\nThe current implementation of removing components is now using AddressArrayUtils, there are better way to improve this without using for loops\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/lib/AddressArrayUtils.sol#L39\n```solidity\n/**\n     * Finds the index of the first occurrence of the given element.\n     * @param A The input array to search\n     * @param a The value to find\n     * @return Returns (index and isIn) for the first occurrence starting from index 0\n     */\n    function indexOf(address[] memory A, address a) internal pure returns (uint256, bool) {\n        uint256 length = A.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (A[i] == a) {\n                return (i, true);\n            }\n        }\n        return (uint256(-1), false);\n    }\n\n```\n## Tool used\nManual Review\n\n## Recommendation\n1) To improve the efficiency and readability of adding and removing components, the following recommendations are provided:\n```solidity\nmapping(address => uint256) componentIndex;\n```\nThis mapping will store the index of each component in the components array, allowing for efficient lookup and removal.\n\n2) the _storeComponent function as follows:\n```solidity\n function _storeComponent(address component) internal returns (bool) {\n     uint256 arrayIndex = components.length;\n  \n     components.push(component);\n     componentIndex[component] = arrayIndex + 1;\n\n     emit ComponentStored(component);\n     return true;\n }\n```\n3) the _deleteComponent function as follows:\n```solidity\n/**\n * @notice Delete a component from the storage.\n * @dev We are going to switch the last item in the array with the one we are replacing.\n * That way, when we pop, we are removing the correct item.\n *\n * There are two cases we need to handle:\n *  - The address we are removing is not the last address in the array.\n *  - The address is the last address in the array.\n *\n * @param component The address of the component to delete.\n * @return Returns a boolean value indicating whether the operation succeeded.\n */\nfunction _deleteComponent(address component) internal returns (bool) {\n    uint256 index = componentIndex[component];\n    if (index == 0) revert NotExistComponent(component);\n\n    uint256 arrayIndex = index - 1;\n    uint256 length = components.length;\n    if (arrayIndex >= length) {\n        revert ArrayIndexOutOfBounds(\"component\");\n    }\n\n    if (arrayIndex != length - 1) {\n        address lastComponent = components[length - 1];\n        components[arrayIndex] = lastComponent;\n        componentIndex[lastComponent] = index;\n    }\n\n    components.pop();\n    delete componentIndex[component];\n    \n    emit ComponentDeleted(component, index);\n    return true;\n}\n```\n","decidedSeverity":"false","decidedDuplication":"Effective way of adding and Removing components  array in SetToken"},{"file":"202.md","watson":{"name":"IamZKdevETH"},"severity":"medium","title":"Effective way of adding and Removing modules array in SetToken","markdown":"IamZKdevETH\n\nmedium\n\n# Effective way of adding and Removing modules array in SetToken\n\n## Summary\nThis audit report assesses the implementation of adding and removing modules in the provided smart contract. The contract includes an `address[] public modules` array for storing module addresses. The report highlights the existing code and proposes improvements to handle adding and removing modules efficiently.\n\n## Vulnerability Detail\nThe current implementation of adding and removing modules uses an array and a mapping. While the implementation is functional, there are opportunities for improvement. The code can be optimized to handle adding and removing modules more efficiently and maintain an accurate index mapping.\n\n## Impact\nThe current implementation of removing modules is now using `AddressArrayUtils`. There are better ways to improve this without using `for` loops.\n\n## Code Snippet\nThe code snippet below is from the `AddressArrayUtils.sol` library, which is referenced in the contract implementation for finding the index of the first occurrence of an element in an address array.\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/lib/AddressArrayUtils.sol#L39\n```solidity\n/**\n * Finds the index of the first occurrence of the given element.\n * @param A The input array to search\n * @param a The value to find\n * @return Returns (index, isIn) for the first occurrence starting from index 0\n */\nfunction indexOf(address[] memory A, address a) internal pure returns (uint256, bool) {\n    uint256 length = A.length;\n    for (uint256 i = 0; i < length; i++) {\n        if (A[i] == a) {\n            return (i, true);\n        }\n    }\n    return (uint256(-1), false);\n}\n```\n\n## Tool used\nManual Review\n\n## Recommendation\n1) To improve the efficiency and readability of adding and removing modules, the following recommendations are provided:\n```solidity\nmapping(address => uint256) moduleIndex;\n```\nThis mapping will store the index of each module in the modules array, allowing for efficient lookup and removal.\n\n2) the _storeModule function as follows:\n```solidity\n function _storeModule(address module) internal returns (bool) {\n    uint256 index = modules.length;\n\n    modules.push(module);\n    moduleIndex[module] = index + 1;\n\n    emit ModuleStored(module);\n    return true;\n}\n```\n3) the _deleteModule function as follows:\n```solidity\n/**\n * @notice Delete a module from the storage.\n * @dev We are going to switch the last item in the array with the one we are replacing.\n * That way, when we pop, we are removing the correct item.\n *\n * There are two cases we need to handle:\n *  - The address we are removing is not the last address in the array.\n *  - The address is the last address in the array.\n *\n * @param moduleToDelete The address of the module to delete.\n * @return Returns a boolean value indicating whether the operation succeeded.\n */\nfunction _deleteModule(address moduleToDelete) internal returns (bool) {\n    uint256 index = moduleIndex[moduleToDelete];\n    if (index == 0) revert NotExistModule(moduleToDelete);\n\n    uint256 arrayIndex = index - 1;\n    uint256 length = modules.length;\n    if (arrayIndex >= length) {\n        revert ArrayIndexOutOfBounds(\"module\");\n    }\n\n    if (arrayIndex != length - 1) {\n        address lastModule = modules[length - 1];\n        modules[arrayIndex] = lastModule;\n        moduleIndex[lastModule] = index;\n    }\n\n    modules.pop();\n    delete moduleIndex[moduleToDelete];\n\n    emit ModuleDeleted(moduleToDelete, index);\n    return true;\n}\n```","decidedSeverity":"false","decidedDuplication":"Effective way of adding and Removing modules array in SetToken"},{"file":"203.md","watson":{"name":"IamZKdevETH"},"severity":"medium","title":"Informational underscore prefix or private  and internal functions","markdown":"IamZKdevETH\n\nmedium\n\n# Informational underscore prefix or private  and internal functions\n\n## Summary\nThe project does not consistently use an underscore prefix for private  and internal functions and variables, which deviates from the recommended style guide for Solidity. Adding an underscore prefix to private functions and variables improves code readability and distinguishes them from public and external ones.\n\n## Vulnerability Detail\nThe contracts does not follow the convention of using an underscore prefix for private functions and variables. This can make it more challenging to identify the visibility of functions and variables when reviewing the code, potentially leading to confusion and mistakes.\n\nThe impact of not using an underscore prefix for private functions and variables is primarily on code readability and maintainability. By not adhering to the standard convention, it may take additional effort for developers and auditors to differentiate between different visibility levels. This can lead to confusion, errors, or delays when working with the contract code.\n\nexample: https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/lib/ModuleBase.sol#L117\n## Impact\n\n## Code Snippet\n```solidity\nfunction transferFrom(IERC20 _token, address _from, address _to, uint256 _quantity) internal {\n        ExplicitERC20.transferFrom(_token, _from, _to, _quantity);\n    }\n\n    /**\n     * Gets the integration for the module with the passed in name. Validates that the address is not empty\n     */\n    function getAndValidateAdapter(string memory _integrationName) internal view returns(address) { \n        bytes32 integrationHash = getNameHash(_integrationName);\n        return getAndValidateAdapterWithHash(integrationHash);\n    }\n\n    /**\n     * Gets the integration for the module with the passed in hash. Validates that the address is not empty\n     */\n    function getAndValidateAdapterWithHash(bytes32 _integrationHash) internal view returns(address) { \n        address adapter = controller.getIntegrationRegistry().getIntegrationAdapterWithHash(\n            address(this),\n            _integrationHash\n        );\n\n        require(adapter != address(0), \"Must be valid adapter\"); \n        return adapter;\n    }\n\n    /**\n     * Gets the total fee for this module of the passed in index (fee % * quantity)\n     */\n    function getModuleFee(uint256 _feeIndex, uint256 _quantity) internal view returns(uint256) {\n        uint256 feePercentage = controller.getModuleFee(address(this), _feeIndex);\n        return _quantity.preciseMul(feePercentage);\n    }\n```\n## Tool used\n\nManual Review\n\n## Recommendation\nTo improve code clarity and adherence to best practices, it is recommended to add an underscore prefix to private functions and variables. This will enhance readability and make it easier to distinguish between different visibility levels.","decidedSeverity":"false","decidedDuplication":"Informational underscore prefix or private  and internal functions"},{"file":"204.md","watson":{"name":"IamZKdevETH"},"severity":"medium","title":"Removing airdrops array in struct AirdropSettings, AirdropModule.sol. DoS removing huge amount of addresses","markdown":"IamZKdevETH\n\nmedium\n\n# Removing airdrops array in struct AirdropSettings, AirdropModule.sol. DoS removing huge amount of addresses\n\n## Summary\nThis audit report assesses the implementation of adding and removing airdrops in the provided smart contract. The contract includes an address[] airdrops; array for storing airdrop addresses. The report highlights the existing code and proposes improvements to handle adding and removing airdrops efficiently.\n\n## Vulnerability Detail\nThe current implementation of adding and removing airdrops uses an array and a mapping. While the implementation is functional, there are opportunities for improvement. The code can be optimized to handle adding and removing airdrops more efficiently and maintain an accurate index mapping.\n\n## Impact\nThe current implementation of removing airdrops is now using AddressArrayUtils, there are better way to improve this without using for loops\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/lib/AddressArrayUtils.sol#L39\n```solidity\n/**\n     * Finds the index of the first occurrence of the given element.\n     * @param A The input array to search\n     * @param a The value to find\n     * @return Returns (index and isIn) for the first occurrence starting from index 0\n     */\n    function indexOf(address[] memory A, address a) internal pure returns (uint256, bool) {\n        uint256 length = A.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (A[i] == a) {\n                return (i, true);\n            }\n        }\n        return (uint256(-1), false);\n    }\n\n```\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AirdropModule.sol#L55\n```solidity\n struct AirdropSettings {\n        address[] airdrops;                     // Array of tokens manager is allowing to be absorbed\n        address feeRecipient;                   // Address airdrop fees are sent to\n        uint256 airdropFee;                     // Percentage in preciseUnits of airdrop sent to feeRecipient (1e16 = 1%)\n        bool anyoneAbsorb;                      // Boolean indicating if any address can call absorb or just the manager\n    }\n```\n## Tool used\nManual Review\n\n## Recommendation\n1) To improve the efficiency and readability of adding and removing airdrops, the following recommendations are provided:\n```solidity\nmapping(address => uint256) airdropIndex;\n```\nThis mapping will store the index of each airdrop in the airdrops array, allowing for efficient lookup and removal.\n\n2) the _storeAirdrop function as follows:\n```solidity\n function _storeAirdrop(address airdrop) internal returns (bool) {\n     uint256 arrayIndex = airdrops.length;\n  \n     airdrops.push(airdrop);\n     airdropIndex[airdrop] = arrayIndex + 1;\n\n     emit AirdropStored(airdrop);\n     return true;\n }\n```\n3) the _deleteAirdrop function as follows:\n```solidity\n/**\n * @notice Delete a airdrop address from the storage.\n * @dev We are going to switch the last item in the array with the one we are replacing.\n * That way, when we pop, we are removing the correct item.\n *\n * There are two cases we need to handle:\n *  - The address we are removing is not the last address in the array.\n *  - The address is the last address in the array.\n *\n * @param airdrop The address of the airdrop to delete.\n * @return Returns a boolean value indicating whether the operation succeeded.\n */\nfunction _deleteAirdrop(address airdrop) internal returns (bool) {\n    uint256 index = airdropIndex[airdrop];\n    if (index == 0) revert NotExistAirdrop(airdrop);\n\n    uint256 arrayIndex = index - 1;\n    uint256 length = airdrops.length;\n    if (arrayIndex >= length) {\n        revert ArrayIndexOutOfBounds(\"airdrop\");\n    }\n\n    if (arrayIndex != length - 1) {\n        address lastAirdrop = airdrops[length - 1];\n        airdrops[arrayIndex] = lastAirdrop;\n        airdropIndex[lastAirdrop] = index;\n    }\n\n    airdrops.pop();\n    delete airdropIndex[airdrop];\n    \n    emit AirdropDeleted(airdrop, index);\n    return true;\n}\n```\n","decidedSeverity":"false","decidedDuplication":"Removing airdrops array in struct AirdropSettings, AirdropModule.sol. DoS removing huge amount of addresses"},{"file":"205.md","watson":{"name":"0x007","days":6,"is_team":false,"payout":6.53,"score":0.2490655024,"senior":false},"severity":"medium","title":"msg.sender == tx.origin does not protect against attacks like sandwich","markdown":"0x007\n\nmedium\n\n# msg.sender == tx.origin does not protect against attacks like sandwich\n\n## Summary\nAccording to the [codebase](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/lib/BaseExtension.sol#L56-L62), some functions are restricted to EOA to stop flash loan and sandwich attacks. However, this solution is not thorough for the following reasons\n* Sandwich can be done on L1 using tools like flashbots to submit bundles.\n* Institutions are trying their hands on MEV, so capital might not be restriction for enticing opportunities that involve sandwich.\n* msg.sender == tx.origin does not imply EOA on L2 chains when the transaction is sent from L1\n* EOA might not be only address that can start transactions in the future on ethereum because of ongoing discussion and plans on account abstraction.\n\n## Vulnerability Detail\n\n\n## Impact\nThe smart contract is attacked from onlyEOA functions such as [rebalance](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L304), [iterateRebalance](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L338), [ripcord](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L376)\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/lib/BaseExtension.sol#L56-L62\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L304\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L338\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L376\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nMake sure the smart contract is resilient no matter the msg.sender or tx.origin.\n","decidedSeverity":"false","decidedDuplication":"msg.sender == tx.origin does not protect against attacks like sandwich"},{"file":"206.md","watson":{"name":"0x007","days":6,"is_team":false,"payout":6.53,"score":0.2490655024,"senior":false},"severity":"medium","title":"Oracle price could be stale","markdown":"0x007\n\nmedium\n\n# Oracle price could be stale\n\n## Summary\npriceOracle.latestAnswer() is a deprecated function and it could return stale price. latestRoundData is the recommended function with validation before using the price such as\n* timestamp is not too old\n* Price > 0\n* Round is the latest\n\n## Vulnerability Detail\nAaveLeverageStrategyExtension uses chainlink deprecated latestAnswer() which could return stale and incorrect price.\n\n## Impact\nIncorrect price could cause a lot of issues such as incorrect leveraging and slippage tolerance.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L889-L907\n\n## Tool used\n\nManual Review\n\n## Recommendation\n[Chainlink](https://docs.chain.link/data-feeds/api-reference) advises against using latestAnswer() and recommends using latestRoundData() instead. It provides data which can be checked to know how recent the price is such as round, and timestamp.\n","decidedSeverity":"medium","decidedDuplication":"Chainlink's latestRoundData return stale or incorrect result"},{"file":"207.md","watson":{"name":"0x007","days":6,"is_team":false,"payout":6.53,"score":0.2490655024,"senior":false},"severity":"medium","title":"Use sequencer oracle before deploying to arbitrum or optimism","markdown":"0x007\n\nmedium\n\n# Use sequencer oracle before deploying to arbitrum or optimism\n\n## Summary\nChainlink oracle could return stale data when sequencer is down. To combat this, they provide sequencer oracle as well.\n\n## Vulnerability Detail\nWhen price are used in AaveLeverageStrategyExtension, it doesn't check if there sequencer is experiencing a downtime.\n\n## Impact\nWrong prices could be used across the protocol\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L889-L907\n\n## Tool used\n\nManual Review\n\n## Recommendation\nUse chainlink [sequencer feed](https://docs.chain.link/data-feeds/l2-sequencer-feeds)\n","decidedSeverity":"medium","decidedDuplication":"Missing checks for whether Arbitrum Sequencer is active"},{"file":"208.md","watson":{"name":"0x007","days":6,"is_team":false,"payout":6.53,"score":0.2490655024,"senior":false},"severity":"high","title":"AaveLeverageStrategyExtension assumes all USD price feed decimals is 8","markdown":"0x007\n\nhigh\n\n# AaveLeverageStrategyExtension assumes all USD price feed decimals is 8\n\n## Summary\nAaveLeverageStrategyExtension assumes all USD price feed decimals are 8, but this is not always true. AAVE V2 has AMPL is it's [list of deployed assets](https://docs.aave.com/developers/v/2.0/deployed-contracts/deployed-contracts) and the [price feed](https://etherscan.io/address/0x492575FDD11a0fCf2C6C719867890a7648d526eB#readContract) is 18 decimals\n\n## Vulnerability Detail\nAaveLeverageStrategyExtension will use the wrong decimals and prices for collateral and borrowed assets if it includes AMPL or other assets that are not 18 decimals\n\n## Impact\nThis would affect leveraging and slippage tolerance and make the contract susceptible to sandwich and bad attacks\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L88-L89\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L94-L95\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L895-L898\n\n## Tool used\n\nManual Review\n\n## Recommendation\nGet decimals from price feed and use it.\n","decidedSeverity":"medium","decidedDuplication":"Wrongly assume chainlink oracle decimal is always 8"},{"file":"209.md","watson":{"name":"0x007","days":6,"is_team":false,"payout":6.53,"score":0.2490655024,"senior":false},"severity":"medium","title":"Use pool.supply instead of pool.deposit","markdown":"0x007\n\nmedium\n\n# Use pool.supply instead of pool.deposit\n\n## Summary\nAAVE V2 uses deposit function to supply tokens. However, V3 uses supply function. deposit function is not mentioned in the [AAVE docs](https://docs.aave.com/developers/core-contracts/pool). It is included **at the bottom** of the [code](https://github.com/aave/aave-v3-core/blob/94e571f3a7465201881a59555314cd550ccfda57/contracts/protocol/pool/Pool.sol#L754-L774) just for backward compatibility. The IPool interface also has a [message for devs](https://github.com/aave/aave-v3-core/blob/94e571f3a7465201881a59555314cd550ccfda57/contracts/interfaces/IPool.sol#L740) to use supply instead.\n\n## Vulnerability Detail\nAAVEV3 library uses deprecated deposit function\n\n## Impact\nIt won't be great using such a deprecated function, especially considering the fact that the pool contract could be upgraded and AAVEV3 library should be resilient\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/integration/lib/AaveV3.sol#L64\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/integration/lib/AaveV3.sol#L52-L101\n\n## Tool used\n\nManual Review\n\n## Recommendation\nUse the supply function rather than deposit function for AAVE V3 library.\n","decidedSeverity":"medium","decidedDuplication":"AaveV3 library uses deprecated deposit function"},{"file":"210.md","watson":{"name":"0x007","days":6,"is_team":false,"payout":6.53,"score":0.2490655024,"senior":false},"severity":"medium","title":"ripcord could be frontrun by operator calling withdrawEtherBalance","markdown":"0x007\n\nmedium\n\n# ripcord could be frontrun by operator calling withdrawEtherBalance\n\n## Summary\nripcord caller is incentivized ETH, but this same ETH could also withdrawn by operator instantly without timelock.\n\n## Vulnerability Detail\nIf operator's withdrawEtherBalance is mined before a user's ripcord is mined, then they won't receive ether reward.\n\n## Impact\nUser don't get their expected reward.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L392\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L583-L585\n\n## Tool used\n\nManual Review\n\n## Recommendation\nAdd another check to `withdrawEtherBalance` that's similar to `noRebalanceInProgress` but protects ripcord caller. Or add timelock to ETH withdraws by operator.\n","decidedSeverity":"false","decidedDuplication":"ripcord could be frontrun by operator calling withdrawEtherBalance"},{"file":"211.md","watson":{"name":"0x007","days":6,"is_team":false,"payout":6.53,"score":0.2490655024,"senior":false},"severity":"high","title":"Operator can make setToken call functions not authorized by the methodologist","markdown":"0x007\n\nhigh\n\n# Operator can make setToken call functions not authorized by the methodologist\n\n## Summary\nThe BaseManagerV2 contract is meant to decentralize power over the SetToken. Operator is meant to run daily operations while methodologist is meant to put guardrails on the operator's action. This is mentioned on [discord](https://discord.com/channels/812037309376495636/1109133391904915557/1111458670199447603) and the contract is designed that way with features like\n* protected modules\n* initialization required by methodologist\n* mutualUpgrades for some config update\n\nHowever, `_senderAuthorizedForModule` always return true for modules that are not protected.\n\n## Vulnerability Detail\ninteractManager is the key point in the BaseManagerV2 contracts cause it invokes modules which in turn invoke setToken. It requires that the methodologist has signed off the protected modules which are meant to interact with the setToken by calling `authorizeInitialization`.\n\nHowever, `_senderAuthorizedForModule` always return true for modules that are not protected. And this could be used by `operator` to make the setToken invoke calls that are unprecedented.\n\n### POC\n* Configuration using AAVE V3 strategy is complete and methodologist initializes BaseManagerV2\n* operator creates a new smart contract called EvilExtension with the following properties\n    * manager() which returns the BaseManagerV2 contract address\n    * execute() which calls manager.interactManager(). PS: it can be protected by require(owner == operatorAddress)\n* operator calls addExtension to add the `EvilExtension` contract\n* operator calls addModule to add each module in the controller\n* operator can call evilExtension.execute to invokeManager and execute whatever he wants. Example include using AAVE V2 to leverage, and any onlyManager functions on modules to his interest.\n\n## Impact\noperator controls the SetToken, rather than BaseManagerV2 contract.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/manager/BaseManagerV2.sol#L300-L307\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/manager/BaseManagerV2.sol#L207-210\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/manager/BaseManagerV2.sol#L606-L612\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/manager/BaseManagerV2.sol#L327-L329\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/manager/BaseManagerV2.sol#L228-L233\n\n## Tool used\n\nManual Review\n\n## Recommendation\nreturn false when module is not protected in [_senderAuthorizedForModule](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/manager/BaseManagerV2.sol#L611)\n","decidedSeverity":"false","decidedDuplication":"Operator can make setToken call functions not authorized by the methodologist"},{"file":"212.md","watson":{"name":"0x007","days":6,"is_team":false,"payout":6.53,"score":0.2490655024,"senior":false},"severity":"high","title":"Operator can drain tokens from BaseManagerV2","markdown":"0x007\n\nhigh\n\n# Operator can drain tokens from BaseManagerV2\n\n## Summary\nThe BaseManagerV2 contract ought to be used to collect the fee. Based on the `transferTokens` [docs](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/manager/BaseManagerV2.sol#L312), `In BaseManagerV2, extensions should be the only contracts designated as feeRecipient in fee modules.` and it has as onlyExtension modifier.\n\nNote: this report assumes `OPERATOR ONLY` is a mistake in the docs and ought to be `ADAPTER ONLY`. If transferTokens is meant to be `OPERATOR ONLY`, then correct the modifier to be `onlyOperator` rather than `onlyExtension`.\n\n## Vulnerability Detail\nonlyExtension modifier would pass if operator creates a new smart contract called EvilExtension with the following properties\n* manager() which returns the BaseManagerV2 contract address\n* execute() which calls manager.transferTokens(). PS: it can be protected by require(owner == operatorAddress)\n\n## Impact\nOperator controls funds in BaseManagerV2 including fees sent to the contract.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/manager/BaseManagerV2.sol#L309-L320\n\n## Tool used\n\nManual Review\n\n## Recommendation\nUpdate docs and code to be clear, and do expected behaviour.\n","decidedSeverity":"false","decidedDuplication":"Operator can drain tokens from BaseManagerV2"},{"file":"213.md","watson":{"name":"0x007","days":6,"is_team":false,"payout":6.53,"score":0.2490655024,"senior":false},"severity":"medium","title":"Every settings in AaveLeverageStrategyExtension is configured by onlyOperator including methodology","markdown":"0x007\n\nmedium\n\n# Every settings in AaveLeverageStrategyExtension is configured by onlyOperator including methodology\n\n## Summary\nBased on [discord message](https://discord.com/channels/812037309376495636/1109133391904915557/1111458670199447603) and [docs](https://docs.indexcoop.com/index-coop-community-handbook/products/flexible-leverage-indices#what-is-the-methodology-behind-fli) methodologist has an important role of controlling parameters that defines a strategy. There's also an `onlyMethodologist` modifier in the BaseExtension contract.\n\n## Vulnerability Detail\n`onlyMethodologist` is not used for any settings including `setMethodologySettings` for setting `methodology`. All the settings are configured by operator.\n\n## Impact\noperator could changed the configuration from methodologist specification by calling functions like `setMethodologySettings`.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L446\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L466\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L484\n\n## Tool used\n\nManual Review\n\n## Recommendation\nChange modifier from `onlyOperator` to `onlyMethodologist` for functions like `setMethodologySettings`\n","decidedSeverity":"false","decidedDuplication":"Every settings in AaveLeverageStrategyExtension is configured by onlyOperator including methodology"},{"file":"214.md","watson":{"name":"0x007","days":6,"is_team":false,"payout":6.53,"score":0.2490655024,"senior":false},"severity":"medium","title":"SetToken could be locked if they enable USDT as borrowed asset on Ethereum network","markdown":"0x007\n\nmedium\n\n# SetToken could be locked if they enable USDT as borrowed asset on Ethereum network\n\n## Summary\nNote the following\n* [USDT on ethereum](https://etherscan.io/token/0xdac17f958d2ee523a2206206994597c13d831ec7#code) requires that allowance is 0 when setting a new value that's not 0.\n* All approvals in the index protocol assumes the next call such as transfer, invokeTrade etc uses the full amount approve\n* [AAVE V3](https://github.com/aave/aave-v3-core/blob/94e571f3a7465201881a59555314cd550ccfda57/contracts/protocol/libraries/logic/BorrowLogic.sol#L180-L265) would transfer only the amount owed if it less than parameter amount for repayBorrow.\n* `sync` AaveV3LeverageModule is called when DebtIssuanceModule wants to issue or redeem setToken. This would update borrow position by using `_getBorrowPosition` which rounds up unit\n* if `borrowedUSDTRaw < totalSupply/1e18`, debt unit would be rounded up to 1\n* During redeem, debts are repayed using `notionalDebt` calculated in `componentRedeemHook`\n* for `notionalDebt`, `1 unit == _setTokenQuantity/1e18` where _setTokenQuantity is the redeemed amount with fees\n* If `notionalDebt > borrowedUSDTRaw`, the whole notionalDebt would not be redeemed by AAVE V3 leaving some allowance from the setToken to the pool. This can be achieved by redeeming more than `borrowedUSDTRaw * 1e18` raw setToken.\n* USDT is 6 decimals while setToken is 18 decimals\n* USDT would be deployed on ethereum based on this [discussion](https://governance.aave.com/t/arfc-add-usdt-to-ethereum-v3-market/11536)\n\n\n## Vulnerability Detail\nAssume, there's this scenario where\n* borrowed USDT is 1,000 (raw: 1e9)\n* total supply of setToken is 10 billion (raw: 1e10 * 1e18)\n* 2 billion is being redeemed (raw: 2e9 * 1e18)\n\nThen, setToken would approve 2,000 USDT to AAVE V3 pool. But only 1,000 would be transferred and another 1,000 would be left in approval.\n\nThis affects both `DebtIssuanceModule` and `DebtIssuanceModuleV2`.\n\n\n## Impact\nThe smart contract would be locked and it would be impossible to\n* redeem setToken cause new approval won't work\n* delever cause approval is needed for repay\n\nHowever, new deposits and token issuance would take place if users don't know about the issue.\n\n## Code Snippet\nhttps://etherscan.io/token/0xdac17f958d2ee523a2206206994597c13d831ec7#code\nhttps://github.com/aave/aave-v3-core/blob/94e571f3a7465201881a59555314cd550ccfda57/contracts/protocol/libraries/logic/BorrowLogic.sol#L213-L215\nhttps://github.com/aave/aave-v3-core/blob/94e571f3a7465201881a59555314cd550ccfda57/contracts/protocol/libraries/logic/BorrowLogic.sol#L254\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L675-L686\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L437-L469\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L1149\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L715-726\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModule.sol#L164-L205\n\n## Tool used\n\nManual Review\n\n## Recommendation\nDon't repay more than you owe.\n","decidedSeverity":"medium","decidedDuplication":"AmmModule will not work with usdt"},{"file":"215.md","watson":{"name":"caventa","days":102,"is_team":false,"payout":1746.02,"score":3.7299897076,"senior":false},"severity":"medium","title":"No size checking in SetToken#removeComponent function may raise several problems","markdown":"caventa\n\nmedium\n\n# No size checking in SetToken#removeComponent function may raise several problems\n\n## Summary\nNo size checking in SetToken#removeComponent function may raise several problems\n\n## Vulnerability Detail\nSee the variable SetToken#components\n\n```solidity\naddress[] public components;\n```\n\nit should exists with the size > 0. There is such checking in SetTokenCreator#create. See\n\n```solidity\nrequire(_components.length > 0, \"Must have at least 1 component\");\n```\n\nbut there is no such checking in SetToken#removeComponent. See\n\n```solidity\n    function removeComponent(address _component) external onlyModule whenLockedOnlyLocker {\n        components.removeStorage(_component);\n\n        emit ComponentRemoved(_component);\n    }\n```\n\n## Impact\nThis will at least raise 2 problems as far as I am concerned.\n\n1. Calling SetToken#._getPositionsAbsMinimumVirtualUnit will always throw error\n\n```solidity\nfunction _getPositionsAbsMinimumVirtualUnit() internal view returns(int256) {\n        // Additional assignment happens in the loop below\n        uint256 minimumUnit = uint256(-1); // @audit minimumUnit = uint max\n\n        for (uint256 i = 0; i < components.length; i++) { // @audit if no component, skip this loop\n            address component = components[i];\n\n            // A default position exists if the default virtual unit is > 0\n            uint256 defaultUnit = _defaultPositionVirtualUnit(component).toUint256();\n            if (defaultUnit > 0 && defaultUnit < minimumUnit) {\n                minimumUnit = defaultUnit;\n            }\n\n            address[] memory externalModules = _externalPositionModules(component);\n            for (uint256 j = 0; j < externalModules.length; j++) {\n                address currentModule = externalModules[j];\n\n                uint256 virtualUnit = _absoluteValue(\n                    _externalPositionVirtualUnit(component, currentModule)\n                );\n                if (virtualUnit > 0 && virtualUnit < minimumUnit) {\n                    minimumUnit = virtualUnit;\n                }\n            }\n        }\n\n        return minimumUnit.toInt256();  // Casting uint max to int256 will always throw error\n  }\n```\n\nAs SetToken#editPositionMultiplier => SetToken#_validateNewMultiplier => SetToken#_getPositionsAbsMinimumVirtualUnit\n\nIn general, module is unable to call SetToken#editPositionMultiplier for SetToken that is without components. A good example is, streamingFeeModule is unable to accruedFee\n\n```solidity\nfunction accrueFee(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet\n    (_setToken) {\n        uint256 managerFee;\n        uint256 protocolFee;\n\n        if (_streamingFeePercentage(_setToken) > 0) {\n            uint256 inflationFeePercentage = _calculateStreamingFee(_setToken);\n\n            // Calculate incentiveFee inflation\n            uint256 feeQuantity = _calculateStreamingFeeInflation(_setToken, inflationFeePercentage);\n\n            // Mint new Sets to manager and protocol\n            (\n                managerFee,\n                protocolFee\n            ) = _mintManagerAndProtocolFee(_setToken, feeQuantity);\n\n            _editPositionMultiplier(_setToken, inflationFeePercentage); // @audit this call will always return error\n        }\n\n        feeStates[_setToken].lastStreamingFeeTimestamp = block.timestamp;\n\n        emit FeeActualized(address(_setToken), managerFee, protocolFee);\n    }\n```\n\n2. Calling DebtIssuanceModule#issue and DebtIssuanceModule#redeem could be allowed without any components\n\nSee SetToken#issue\n\n```solidity\nfunction issue(\n        ISetToken _setToken,\n        uint256 _quantity,\n        address _to\n    )\n        external\n        virtual\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        require(_quantity > 0, \"Issue quantity must be > 0\");\n\n        address hookContract = _callManagerPreIssueHooks(_setToken, _quantity, msg.sender, _to);\n\n        _callModulePreIssueHooks(_setToken, _quantity);\n\n        (\n            uint256 quantityWithFees,\n            uint256 managerFee,\n            uint256 protocolFee\n        ) = calculateTotalFees(_setToken, _quantity, true);\n\n        (\n            address[] memory components,\n            uint256[] memory equityUnits,\n            uint256[] memory debtUnits\n        ) = _calculateRequiredComponentIssuanceUnits(_setToken, quantityWithFees, true); // @audit Nothing execute if components if empty\n\n        _resolveEquityPositions(_setToken, quantityWithFees, _to, true, components, equityUnits); // @audit Nothing execute if components if empty\n        _resolveDebtPositions(_setToken, quantityWithFees, true, components, debtUnits); // @audit Nothing execute if components if empty\n        _resolveFees(_setToken, managerFee, protocolFee); \n\n        _setToken.mint(_to, _quantity);\n\n        emit SetTokenIssued(\n            _setToken,\n            msg.sender,\n            _to,\n            hookContract,\n            _quantity,\n            managerFee,\n            protocolFee\n        );\n    }\n```\n\nSee SetToken#redeem\n\n```solidity\nfunction redeem(\n        ISetToken _setToken,\n        uint256 _quantity,\n        address _to\n    )\n        external\n        virtual\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        require(_quantity > 0, \"Redeem quantity must be > 0\");\n\n        _callModulePreRedeemHooks(_setToken, _quantity);\n\n        // Place burn after pre-redeem hooks because burning tokens may lead to false accounting of synced positions\n        _setToken.burn(msg.sender, _quantity);\n\n        (\n            uint256 quantityNetFees,\n            uint256 managerFee,\n            uint256 protocolFee\n        ) = calculateTotalFees(_setToken, _quantity, false);\n\n        (\n            address[] memory components,\n            uint256[] memory equityUnits,\n            uint256[] memory debtUnits\n        ) = _calculateRequiredComponentIssuanceUnits(_setToken, quantityNetFees, false); // @audit Nothing execute if components if empty\n\n        _resolveDebtPositions(_setToken, quantityNetFees, false, components, debtUnits); // @audit Nothing execute if components if empty\n        _resolveEquityPositions(_setToken, quantityNetFees, _to, false, components, equityUnits); // @audit Nothing execute if components if empty\n        _resolveFees(_setToken, managerFee, protocolFee);\n\n        emit SetTokenRedeemed(\n            _setToken,\n            msg.sender,\n            _to,\n            _quantity,\n            managerFee,\n            protocolFee\n        );\n    }\n```\n\nAlso, this is apply to DebtIssuanceModuleV2 too (Not only V1)\n\n(Note: Sponsor has confirmed with me that it is pointless to issue or redeem a set components without any components)\n\n## Code Snippet\nhttps://github.com/IndexCoop/index-protocol/blob/master/contracts/protocol/SetToken.sol#L228-L232\nhttps://github.com/IndexCoop/index-protocol/blob/master/contracts/protocol/SetToken.sol#L600-L627\nhttps://github.com/IndexCoop/index-protocol/blob/master/contracts/protocol/SetToken.sol#L600-L627\nhttps://github.com/IndexCoop/index-protocol/blob/master/contracts/protocol/modules/v1/StreamingFeeModule.sol#L86-L108\nhttps://github.com/IndexCoop/index-protocol/blob/master/contracts/protocol/modules/v1/DebtIssuanceModule.sol#L109-L152\nhttps://github.com/IndexCoop/index-protocol/blob/master/contracts/protocol/modules/v1/DebtIssuanceModule.sol#L164-L205\n\n## Tool used\nManual Review and hardhat test\n\n1. \n\nWithout components, both SetToken#editPositionMultiplier and streamingFeeModule#accrueFee will throw\n\n```SafeCast: value doesn't fit in an int256``` error\n\n2.\n\nNo error thrown if issue or redeem setToken that is without components\n\n## Recommendation\nChange SetToken#removeComponent\n\n```solidity\nfunction removeComponent(address _component) external onlyModule whenLockedOnlyLocker {\n   // Ensure size of components array is not 0 after removal\n}\n```\n\nSponsor told me that only MODULES can called modules though so nobody or even manager will be able to call removeModules DIRECTLY. To me this is a double sword, this mean that modules could remove all its components one day INDIRECTLY. And as addComponent also accessed by MODULES only. (See the following code)\n\n```solidity\n    function addComponent(address _component) external onlyModule whenLockedOnlyLocker {\n        require(!isComponent(_component), \"Must not be component\");\n        \n        components.push(_component);\n\n        emit ComponentAdded(_component);\n    }\n```    \n\nOnce all components are removed, it is IMPOSSIBLE for external admin to add the components back","decidedSeverity":"false","decidedDuplication":"No size checking in SetToken#removeComponent function may raise several problems"},{"file":"216.md","watson":{"name":"caventa","days":102,"is_team":false,"payout":1746.02,"score":3.7299897076,"senior":false},"severity":"medium","title":"Remove component should remove its componentPositions","markdown":"caventa\n\nmedium\n\n# Remove component should remove its componentPositions\n\n## Summary\nRemove component should remove its componentPositions\n\n## Vulnerability Detail\nThe creation of componentPosition\n\n```solidity\nmapping(address => ISetToken.ComponentPosition) private componentPositions;\n```\n\nis depend on components\n\n```solidity\naddress[] public components;\n```\n\nSee the following code in setToken.sol\n\n```solidity\n constructor(\n        address[] memory _components,\n        int256[] memory _units,\n        address[] memory _modules,\n        IController _controller,\n        address _manager,\n        string memory _name,\n        string memory _symbol\n    )\n        public\n        ERC20(_name, _symbol)\n    {\n        controller = _controller;\n        manager = _manager;\n        positionMultiplier = PreciseUnitMath.preciseUnitInt();\n        components = _components; // @audit\n\n        // Modules are put in PENDING state, as they need to be individually initialized by the Module\n        for (uint256 i = 0; i < _modules.length; i++) {\n            moduleStates[_modules[i]] = ISetToken.ModuleState.PENDING;\n        }\n\n        // Positions are put in default state initially\n        for (uint256 j = 0; j < _components.length; j++) {\n            componentPositions[_components[j]].virtualUnit = _units[j]; // @audit\n        }\n    }\n```    \n\nHowever, when remove component, component position is not removed. See the following code\n\n```solidity\n    function removeComponent(address _component) external onlyModule whenLockedOnlyLocker {\n        components.removeStorage(_component); \n        // @audit No remove component position logic here\n         \n        emit ComponentRemoved(_component);\n    }\n```\n    \n## Impact\nComponent position is not removed when component is removed\n\nSome functions are unable to function properly. For eg getPosition\n\n```solidity\nfunction getPositions() external view returns (ISetToken.Position[] memory) {\n        ISetToken.Position[] memory positions = new ISetToken.Position[](_getPositionCount());\n        uint256 positionCount = 0;\n\n        for (uint256 i = 0; i < components.length; i++) { // @audit no components here\n            address component = components[i];\n\n            // A default position exists if the default virtual unit is > 0\n            if (_defaultPositionVirtualUnit(component) > 0) { // @audit Got value here\n                positions[positionCount] = ISetToken.Position({\n                    component: component,\n                    module: address(0),\n                    unit: getDefaultPositionRealUnit(component),\n                    positionState: DEFAULT,\n                    data: \"\"\n                });\n\n                positionCount++;\n            }\n\n            address[] memory externalModules = _externalPositionModules(component);\n            for (uint256 j = 0; j < externalModules.length; j++) { // @audit Got value here\n                address currentModule = externalModules[j];\n\n                positions[positionCount] = ISetToken.Position({\n                    component: component,\n                    module: currentModule,\n                    unit: getExternalPositionRealUnit(component, currentModule),\n                    positionState: EXTERNAL,\n                    data: _externalPositionData(component, currentModule)\n                });\n\n                positionCount++;\n            }\n        }\n\n        return positions;\n    }\n```\n\nThe code has _defaultPositionVirtualUnit and _externalPositionModules. But because if components are removed, system is unable to retrieve the value.\n\n## Code Snippet\nhttps://github.com/IndexCoop/index-protocol/blob/master/contracts/protocol/SetTokenCreator.sol#L66-L109\nhttps://github.com/IndexCoop/index-protocol/blob/master/contracts/protocol/SetToken.sol#L158-L184\nhttps://github.com/IndexCoop/index-protocol/blob/master/contracts/protocol/SetToken.sol#L228-L232\n\n## Tool used\nManual Review\n\n## Recommendation\nWhen removing component, ensure all its component positions are removed ","decidedSeverity":"false","decidedDuplication":"Remove component should remove its componentPositions"},{"file":"217.md","watson":{"name":"coollaitar"},"severity":"medium","title":"[M-01] `accrueFee` sets the higherInflationFeePercentage value due fallacious `block.timestamp`","markdown":"coollaitar\n\nmedium\n\n# [M-01] `accrueFee` sets the higherInflationFeePercentage value due fallacious `block.timestamp`\n\n## Summary\n\n[M-01] `accrueFee` sets the higherInflationFeePercentage value due to fallacious `block.timestamp`\n\n## Vulnerability Detail\n\nThe vulnerability lies in the usage of the block.timestamp within the _calculateStreamingFee function. By manipulating the block.timestamp value, an attacker can cause unexpected changes in the distribution of sets.\n\nTo summarize, the attacker extends the block.timestamp to elevate the inflationFeePercentage, causing an undesired increase in the feeQuantity. This manipulation undermines the fairness of set distribution, disadvantaging either the manager or the protocol.\n\n## Impact\n\nHere the `block.timestamp` can be extended present in `_calculateStreamingFee` by sending a transaction with a higher gas price so that the value of `uint256 inflationFeePercentage` gets higher value in return than real one. Now this higher value of `inflationFeePercentage` will increase the `uint256 feeQuantity` which is calculated using `_calculateStreamingFeeInflation(_setToken, inflationFeePercentage);` which takes two parameters and one of them is `inflationFeePercentage` which is an higher value and this leads to increase in value of `feeQuantity` which leads to an uneven or not fair distribution of `sets` to both the manager and the protocol.\n\n## Code Snippet\n\n1. From here, the attacker stops processing the below step and calls other transactions, leading to an incorrect `inflationFeePercentage` value.\n   [Code Reference 1](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/StreamingFeeModule.sol#L91)\n\n   ```solidity\n               uint256 inflationFeePercentage = _calculateStreamingFee(_setToken);\n   ```\n\n   [Code Reference 2](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/StreamingFeeModule.sol#L203-L208)\n\n   ```solidity\n      function _calculateStreamingFee(ISetToken _setToken) internal view returns(uint256) {\n        uint256 timeSinceLastFee = block.timestamp.sub(_lastStreamingFeeTimestamp(_setToken));\n\n        // Streaming fee is streaming fee times years since the last fee\n        return timeSinceLastFee.mul(_streamingFeePercentage(_setToken)).div(ONE_YEAR_IN_SECONDS);\n    }\n\n   ```\n\n2. And consequently `feeQuantity` value also changes.\n   [Code Reference 3](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/StreamingFeeModule.sol#L94)\n\n   ```solidity\n              uint256 feeQuantity = _calculateStreamingFeeInflation(_setToken, inflationFeePercentage);\n   ```\n\n   [Code Reference 4](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/StreamingFeeModule.sol#L224-L241)\n\n   ```solidity\n      function _calculateStreamingFeeInflation(\n        ISetToken _setToken,\n        uint256 _feePercentage\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 totalSupply = _setToken.totalSupply();\n\n        // fee * totalSupply\n        uint256 a = _feePercentage.mul(totalSupply);\n\n        // ScaleFactor (10e18) - fee\n        uint256 b = PreciseUnitMath.preciseUnit().sub(_feePercentage);\n\n        return a.div(b);\n    }\n\n   ```\n\n3. This leads to an uneven or unfair distribution of `sets` to the manager and the protocol.\n\n   [Code Reference 5](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/StreamingFeeModule.sol#L252-L263)\n\n   ```solidity\n       function _mintManagerAndProtocolFee(ISetToken _setToken, uint256 _feeQuantity) internal returns (uint256, uint256) {\n        address protocolFeeRecipient = controller.feeRecipient();\n        uint256 protocolFee = controller.getModuleFee(address(this), PROTOCOL_STREAMING_FEE_INDEX);\n\n        uint256 protocolFeeAmount = _feeQuantity.preciseMul(protocolFee);\n        uint256 managerFeeAmount = _feeQuantity.sub(protocolFeeAmount);\n\n        _setToken.mint(_feeRecipient(_setToken), managerFeeAmount);\n\n        if (protocolFeeAmount > 0) {\n            _setToken.mint(protocolFeeRecipient, protocolFeeAmount);\n        }\n   ```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider using an alternate method for calculating `block.timestamp` or implementing a logic based on `block.number` that miners cannot manipulate.\n","decidedSeverity":"false","decidedDuplication":"[M-01] `accrueFee` sets the higherInflationFeePercentage value due fallacious `block.timestamp`"},{"file":"218.md","watson":{"name":"caventa","days":102,"is_team":false,"payout":1746.02,"score":3.7299897076,"senior":false},"severity":"medium","title":"Wrapped ether's deposit and withdraw(uint) functions do not work in some chains","markdown":"caventa\n\nmedium\n\n# Wrapped ether's deposit and withdraw(uint) functions do not work in some chains\n\n## Summary\n Wrapped ether's deposit and withdraw(uint) functions do not work in some chains\n \n## Vulnerability Detail\nSee Invoke.sol,\n\ninvokeWrapWETH function will call ```deposit()```\ninvokeUnwrapWETH function will call ```withdraw(uint256)```\n\nBoth function are used in WrapModuleV2#_validateUnwrapAndUpdate and WrapModuleV2#_validateWrapAndUpdate\n\nSee\n\n```solidity\n_setToken.invokeWrapWETH(address(weth), address(_setToken).balance);\n_setToken.invokeUnwrapWETH(address(weth), notionalUnderlying);\n```\n\nFor every WrapModuleV2 deployed, owner needs to specify weth\n\n```solidity\n    constructor(IController _controller, IWETH _weth) public ModuleBase(_controller) {\n        weth = _weth;\n    }\n```\n\nSystem assumes wrapped ether contract has ```deposit``` and ```withdraw(uint256)``` function. See IWETH interface\n\n```solidity\ninterface IWETH is IERC20{\n    function deposit()\n        external\n        payable;\n\n    function withdraw(\n        uint256 wad\n    )\n        external;\n}\n```\n\nAccording to https://app.sherlock.xyz/audits/contests/81\n\nQ: On what chains are the smart contracts going to be deployed?\n**mainnet**, **Polygon**, **Optimism**, **Avalanche**, and **Arbitrum**\n\nBelow are the wrapped ether URLS for these 5 chains\n\n- Etherscan https://etherscan.io/token/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code\n\n- Polygon\nhttps://polygonscan.com/token/0x7ceb23fd6bc0add59e62ac25578270cff1b9f619#code\n\n- Optimism https://optimistic.etherscan.io/token/0x4200000000000000000000000000000000000006#code\n\n- Avalanche\nhttps://snowtrace.io/token/0x49d5c2bdffac6ce2bfdb6640f4f80f226bc10bab#code\n\n- Arbitrum\nhttps://arbiscan.io/token/0x82af49447d8a07e3bd95bd0d56f35241523fbab1#code (Proxy)\nhttps://arbiscan.io/address/0x8b194beae1d3e0788a1a35173978001acdfba668#code (Implementation)\n\nAnd all mentioned WETH **official website** is https://weth.io/\n\nEthereum, Optimism and Avalanche have deposit() function\nEthereum, Polygon, Optimism and Avalanche have withdraw(uint) function\n\nPolygon and Avalanche do not have deposit() function\nAvalanche does not have withdraw(uint) function\n\n## Impact\nCalling WrapModuleV2#WrapWithEther and WrapModuleV2#unwrapWithEther will always not work in some chains\n\n## Code Snippet\nhttps://github.com/IndexCoop/index-protocol/blob/master/contracts/protocol/modules/v1/WrapModuleV2.sol#L89\nhttps://github.com/IndexCoop/index-protocol/blob/master/contracts/protocol/modules/v1/WrapModuleV2.sol#L424\nhttps://github.com/IndexCoop/index-protocol/blob/master/contracts/protocol/modules/v1/WrapModuleV2.sol#L350\n\n## Tool used\nManual Review\n\n## Recommendation\nFor chains that do not support deposit or withdraw(uint) function, use another alternative functions that offer the same function","decidedSeverity":"false","decidedDuplication":"Wrapped ether's deposit and withdraw(uint) functions do not work in some chains"},{"file":"219.md","watson":{"name":"coollaitar"},"severity":"false","title":"Low","markdown":"coollaitar\n\nfalse\n\n# Low\n\n| ID     |                                       Title                                        | Instances |\n| :----- | :--------------------------------------------------------------------------------: | --------: |\n| [L-01] |         Refactor the event `FeeEdited` to also return `_oldFeePercentage`          |         1 |\n| [L-02] |         Add `require()` statement to check `isExternalPositionModule` true         |         1 |\n| [L-03] |     There is should an bool value for succesful validation of `LeveragedInfo`      |         3 |\n| [L-04] | `onlyEOA` modifier is risky because it just checks whether `msg.sender==tx.origin` |         1 |\n\n## [L-01] Refactor the event `FeeEdited` to also return `_oldFeePercentage`\n\n[Code Reference](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/Controller.sol#L40)\n\n```solidity\n  event FeeEdited(address indexed _module, uint256 indexed _feeType, uint256 _feePercentage);\n```\n\n## [L-02] Add `require()` statement to check `isExternalPositionModule` true before removing it from storage in the `function removeExternalPositionModule()`\n\n[Code Reference](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/SetToken.sol#L261-L269)\n\n```solidity\n    function removeExternalPositionModule(\n        address _component,\n        address _positionModule\n    )\n        external\n        onlyModule\n        whenLockedOnlyLocker\n    {\n        componentPositions[_component].externalPositionModules.removeStorage(_positionModule);\n```\n\n## [L-03] There is should an bool value for succesful validation of `LeveragedInfo` so that we can check wether the validation is true or false and then only execute ahead\n\n[Code Reference](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#LL304C6-L309C6)\n\n```solidity\n  function rebalance(string memory _exchangeName) external onlyEOA onlyAllowedCaller(msg.sender) {\n        LeverageInfo memory leverageInfo = _getAndValidateLeveragedInfo(\n            execution.slippageTolerance,\n            exchangeSettings[_exchangeName].twapMaxTradeSize,\n            _exchangeName\n        );\n```\n\n## [L-04] The `onlyEOA` modifier, which checks msg.sender == tx.origin, is risky as it fails to guarantee the authenticity of the owner due to the possibility of private key compromise in the `function ripcord()`\n\n[Code Reference](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L376-L381)\n\n```solidity\n    function ripcord(string memory _exchangeName) external onlyEOA {\n        LeverageInfo memory leverageInfo = _getAndValidateLeveragedInfo(\n            incentive.incentivizedSlippageTolerance,\n            exchangeSettings[_exchangeName].incentivizedTwapMaxTradeSize,\n            _exchangeName\n        );\n```\n","decidedSeverity":"false","decidedDuplication":"Low"},{"file":"220.md","watson":{"name":"Oxsadeeq"},"severity":"high","title":"Manager/Users would not be able to withdraw rewards from Comptroller","markdown":"Oxsadeeq\n\nhigh\n\n# Manager/Users would not be able to withdraw rewards from Comptroller\n\n## Summary:Rewards accrued by the setToken cannot be claimed .\n\n## Vulnerability Detail:In the contract ClaimModule, the function claim() which is used to claim ctokens accrued over time by supplying to the protocol. A call to the claim() goes like this:claim()==>_claim()==>Adapter.getClaimedData, when a call is made to the claim contract either by the manager/users passing in the (setToken instance,address of reward Pool, and string Adapters Name) it forwards the call  to an internal function _claim() which does some check and utilizes another contract to prepare data, the bug is spotted when preparing the data ,\nbytes memory callData = abi.encodeWithSignature(\"claimComp(address)\", _setToken)\n\nthe claimComp function takes in an address as input,but passed as an input is an instance of _setToken rather than address of the setToken.This would obviously revert since it is a mismatched data type case.\n\n## Impact:The rewards for all setTokens that has rewards in the pool would be forever stuck in the contract\n\n## Code Snippet:\nunction getClaimCallData(ISetToken _setToken, address /* _rewardPool */) external view returns (address, uint256, bytes memory) {\n        bytes memory callData = abi.encodeWithSignature(\"claimComp(address)\", _setToken);// (address(_setToken))\n        //_setToken is not an address \n\n        return (address(comptroller), 0, callData);\n    }\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/ClaimModule.sol#L375\n\n## Tool used\n\nManual Review\n\n## Recommendation:Change from _setToken to address(_setToken)\n","decidedSeverity":"false","decidedDuplication":"Manager/Users would not be able to withdraw rewards from Comptroller"},{"file":"221.md","watson":{"name":"Oxsadeeq"},"severity":"high","title":"DOS due to the use of deprecated function","markdown":"Oxsadeeq\n\nhigh\n\n# DOS due to the use of deprecated function\n\n## Summary:Most action calls  will always revert\n\n## Vulnerability Detail:AaveLeverageStrategyExtension that implements Index strategy for FLI tokens.The function createActionInfo ()  fetches/prepare latest data before new actions are taken.The bug comes in  play \nwhen getting the prices of Collateral and Borrow, it utilizes chainlink deprecated function latestAnswer(), which unfortunately does’nt revert instead it returns 0.This contract would revert in an attempt to convert the price to Uint256(conversion from int=>uint does not support 0 as an input in Openzeppelin safeCast).\nThis internal function _createActionInfo() is called to initialize the leverage Ratio and other functions would revert because of dependency on  the uninitialized leverageRatio.\nint256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer()\nrebalanceInfo.collateralPrice = rawCollateralPrice.toUint256().mul(10 ** strategy.collateralDecimalAdjustment);\n\n\n## Impact:Bots,contracts and users would not be able to interact with functions in the contract,which is eventually a DOS scenario\n\n## Code Snippet:https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L895\n\n## Tool used\n\nManual Review\n\n## Recommendation:Uses chainlink latestdata() instead of latestAnswer\n","decidedSeverity":"medium","decidedDuplication":"Deprecated oracle function `latestAnswer()` could bring fund loss"},{"file":"222.md","watson":{"name":"XDZIBEC"},"severity":"high","title":"XO- Vulnerability in `interactManager` Function leading to Reentrancy attack","markdown":"XDZIBEC\n\nhigh\n\n# XO- Vulnerability in `interactManager` Function leading to Reentrancy attack\n\n## Summary\n- there is a vulnerability in the `BaseManager.sol` contract, specially in ` interactManager` function that is leading to `reentrancy `attack. this function is used by adapters to interact with the `SetToken` contract.\n## Vulnerability Detail\n```solidity\n */\n    function interactManager(address _module, bytes calldata _data) external onlyAdapter {\n        // Invoke call to module, assume value will always be 0\n        _module.functionCallWithValue(_data, 0);\n    }\n\n    /**\n```\n- There is a vulnerability in the `interactManager` function, this function is used by adapters to interact with the `SetToken` contract. The function are takes two arguments, ` _module` is the address of the module contract and `_data` it is  the data to be passed to the module contract, and this function works by calling the` functionCallWithValue` function on the module contract. this function sends a `transaction` to the module contract and waits for the `transaction` to be mined, a,d the probem here is that the `functionCallWithValue` function is vulnerable to a `reentrancy` attack. that can an attacker can call a function recursively before the function has finished executing. This can allow the attacker to drain the contract's funds, and in the i`nteractManager` function, the `functionCallWithValue` function is called without any `safeguards` to prevent a `reentrancy` attack. This means that an attacker could call the `interactManager` function and then call the `functionCallWithValue` function recursively. This would allow the attacker to drain the `SetToken` contract's funds.\n## Impact\n- An attacker allow to drain the contract's funds.\n- How an attacker can use this vulnerability.\n    - An attacker creates a new contract that inherits from the `IAdapter` interface.\n    - The attacker calls the `addAdapter` function on the `SetToken` contract to add the new contract as an adapter.\n    - The attacker then calls the` interactManager` function on the `SetToken` contract to interact with the module contract.\n    - The module contract calls back to the` interactManage`r function on the `SetToken` contract.\n    - The attacker exploits the `reentrancy` vulnerability to drain the `SetToken` contract's funds.\n\n## Code Snippet\n- https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/manager/BaseManager.sol#L164C1-L170C8\n## Tool used\n\nManual Review\n\n## Recommendation\n-  the `interactManager` function should be made `constant`. This will prevent the function from being called from other contracts. and, the `functionCallWithValue` function should be `updated` to include `safeguards` to prevent a `reentrancy attack`.","decidedSeverity":"false","decidedDuplication":"XO- Vulnerability in `interactManager` Function leading to Reentrancy attack"},{"file":"223.md","watson":{"name":"XDZIBEC"},"severity":"medium","title":"XO-`Resource ID`  mapping not updated after removal","markdown":"XDZIBEC\n\nmedium\n\n# XO-`Resource ID`  mapping not updated after removal\n\n## Summary\n- The vulnerability is in the `addResource` function, the function does not update the `resourceId` mapping to reflect the removal of the resource. This means that the` resourceId` mapping will still contain the `ID` of the removed resource, his would cause the new resource to overwrite the old resource.\n## Vulnerability Detail\n```solidity\n  */\nunction addResource(address _resource, uint256 _id) external onlyInitialized onlyOwner {\n        require(!isResource[_resource], \"Resource already exists\");\n\n        require(resourceId[_id] == address(0), \"Resource ID already exists\");\n\n        isResource[_resource] = true;\n\n        resourceId[_id] = _resource;\n\n        resources.push(_resource);\n\n        emit ResourceAdded(_resource, _id);\n    }\n\n    /**\n     * PRIVILEGED GOVERNANCE FUNCTION. Allows governance to remove a resource\n     *\n     * @param _id               ID of the resource contract to remove\n     */\n    function removeResource(uint256 _id) external onlyInitialized onlyOwner {\n        address resourceToRemove = resourceId[_id];\n\n        require(resourceToRemove != address(0), \"Resource does not exist\");\n\n        resources = resources.remove(resourceToRemove);\n\n        delete resourceId[_id];\n\n        isResource[resourceToRemove] = false;\n\n        emit ResourceRemoved(resourceToRemove, _id);\n    }\n\n```\n- There is a vulnerability  in the `addResource` function, is that the `resourceId` `mapping` is never updated to reflect the removal of a resource  means that if a resource is removed, its `ID` will still be in the `mapping`, and it will be possible to add a new `resource` with the same `ID`. This could lead to confusion and errors, and  the` removeResource` function removes the resource from the resources array and the `isResource` `mapping`, it does not update the `resourceId` `mapping`. means that the `resourceId` `mapping` will still contain the `ID` of the removed resource.\n## Impact\n- This could lead to confusion and errors\n## Code Snippet\n- https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/Controller.sol#L251C4-L266C28\n## Tool used\n\nManual Review\n\n## Recommendation\n- the `removeResource` function should also update the `resourceId` mapping.","decidedSeverity":"false","decidedDuplication":"XO-`Resource ID`  mapping not updated after removal"},{"file":"224.md","watson":{"name":"PRAISE","days":64,"is_team":false,"payout":403.7,"score":1.9031785617,"senior":false},"severity":"high","title":"slippageTolerance is neglected in the engage() and disengage() function","markdown":"PRAISE\n\nhigh\n\n# slippageTolerance is neglected in the engage() and disengage() function\n\n## Summary\nThese functions engage(), disengage()  and all externally called functions within them fail to check the slippageTolerance within a require statement / if statement. \n\n## Vulnerability Detail\nThere is a default slippageTolerance set in the constructor by manager. \n\nThe issue is that the default slippageTolerance set by the manager is used to calculate some things within the engage() and disengage() functions but the engage(), disengage() functions and all externally called functions within them fail to check the slippageTolerance within a require statement / if statement.\n\nSince the slippageTolerance is \"% in precise units to price min token receive amount from trade quantities\" these functions are supposed to check and ensure with a require statement that the receive amount from trade quantities isn't below/ less than the slippageTolerance set by the manager.\n\n## Impact\nthere can be slippage when operator uses engage() and disengage() functions\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L256\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L412\n## Tool used\n\nManual Review\n\n## Recommendation\nEnsure with a require statement that the slippageTolerance is checked within these functions. \n","decidedSeverity":"false","decidedDuplication":"slippageTolerance is neglected in the engage() and disengage() function"},{"file":"225.md","watson":{"name":"Inspex","days":34,"is_team":false,"payout":2774.5,"score":21.6732265969,"senior":false},"severity":"medium","title":"Interactions with AMMs typically do not involve the use of `deadline` for operations.","markdown":"Inspex\n\nmedium\n\n# Interactions with AMMs typically do not involve the use of `deadline` for operations.\n\n## Summary\nWhen calling the `trade()` function, the `deadline` parameter cannot be set. This limitation could potentially result in users obtaining a suboptimal price and allowing malicious miners to profit from the situation.\n\n## Vulnerability Detail\nThe `trade()` function in the `TradeModule` contract does not include a deadline parameter. Instead, it relies on the `block.timestamp` value, which means the transaction will be considered valid whenever the miner decides to include it in a block, based on the current timestamp.\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/TradeModule.sol#L140\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/TradeModule.sol#L236-L263\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/integration/exchange/UniswapV2ExchangeAdapterV2.sol#L74-L100\n\nThe absence of a `deadline` can result in transactions being delayed in the mempool and executed at a time later than desired by the user. Consequently, users may end up with a worse price because a validator can intentionally delay the transaction. When the transaction is eventually included in a block, it will be executed based on the current `block.timestamp`, offering no protection to the user.\n\n## Impact\nA malicious miner can hold the transaction to deliberately delay its execution without any restrictions.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/TradeModule.sol#L140\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/TradeModule.sol#L236-L263\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/integration/exchange/UniswapV2ExchangeAdapterV2.sol#L74-L100\n\n## Tool used\n\nManual Review\n\n## Recommendation\nAdd the `deadline` parameter to the `trade()` function and ensure it is passed along to AMM calls.\n","decidedSeverity":"medium","decidedDuplication":"`AaveLeverageStrategyExtension.sol` does not allow user to specify slippage parameter during rebalance or ripcord"},{"file":"226.md","watson":{"name":"Inspex","days":34,"is_team":false,"payout":2774.5,"score":21.6732265969,"senior":false},"severity":"medium","title":"User can steal tokens of the `SetToken` contract via the `redeem()` function in the `DebtIssuanceModuleV2` contract","markdown":"Inspex\n\nmedium\n\n# User can steal tokens of the `SetToken` contract via the `redeem()` function in the `DebtIssuanceModuleV2` contract\n\n## Summary\nThe new component can be added as the collateral token. This will create an opportunity to steal the tokens of other users by calling the `redeem()` function after the new component has been added and other users call the `issue()` function after that.\n\n## Vulnerability Detail\nThe user can borrow the asset via the `issue()` function by transferring the required component tokens as collateral to exchange for the desired borrow token.\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModuleV2.sol#L75-L126\n\nHowever, when the user wants to retrieve the collateral, the `redeem()` function will be called to repay and transfer the collateral, depending on the components in the SetToken contract.\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModuleV2.sol#L142-L190\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModule.sol#L502\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModule.sol#L566-L569\n\nIf components are added and the `manager` has arbitrarily added a position after a user calls the `issue()` function, and another user has also called `issue()` subsequently, the first user could call the `redeem()` function to obtain the added component as additional collateral.\n\nThe proof of concept is as follows:\n```typescript\nit(\"adding component after issue, then redeem it after\", async () => {\n  ///// Step 0: setup \n  subjectQuantity = ether(100);\n  await token1.connect(owner.wallet).transfer(alice.address, ether(1000));\n  await token2.connect(owner.wallet).transfer(alice.address, ether(1000));\n  await token1.connect(owner.wallet).transfer(bob.address, ether(1000));\n\n  await token1.connect(owner.wallet).transfer(debtModule.address, ether(1000));\n  await token2.connect(owner.wallet).transfer(debtModule.address, ether(1000));\n\n  await setup.dai.transfer(debtModule.address, ether(1000));\n  await setup.dai.transfer(alice.address, ether(1));///for paying fee\n\n  //// Before Exploit\n  let token1Balance = await token1.balanceOf(bob.address);\n  let token2Balance = await token2.balanceOf(bob.address)\n  let daiBalance = await setup.dai.balanceOf(bob.address)\n\n  expect(token1Balance).to.eq(ether(1000));\n  expect(token2Balance).to.eq(ether(0));\n  expect(daiBalance).to.eq(ether(0));\n\n  /// Step 1: subjectCaller start issuing\n  [neededComponents, neededEquityUnits, neededDebtUnits] = await debtIssuance.getRequiredComponentIssuanceUnits(subjectSetToken, subjectQuantity);\n  neededWithFee = neededEquityUnits[0].mul(1005).div(1000);\n  token1.connect(bob.wallet).approve(debtIssuance.address, neededWithFee);\n  await debtIssuance.connect(bob.wallet).issue(\n    subjectSetToken,\n    subjectQuantity,\n    bob.address,\n  );\n\n  /// Step 2: manager module add token2 component\n  await setToken.connect(manager.wallet).addComponent(token2.address);\n  await setToken.connect(manager.wallet).addExternalPositionModule(token2.address, debtModule.address);\n  await setToken.connect(manager.wallet).editDefaultPositionUnit(token2.address, ether(1));\n\n  //// Step 3: \n  [neededComponents, neededEquityUnits, neededDebtUnits] = await debtIssuance.getRequiredComponentIssuanceUnits(subjectSetToken, subjectQuantity);\n  neededWithFee = neededEquityUnits[0].mul(1005).div(1000);\n  token1.connect(alice.wallet).approve(debtIssuance.address, neededWithFee);\n  neededWithFee = neededEquityUnits[2].mul(1005).div(1000);\n  token2.connect(alice.wallet).approve(debtIssuance.address, neededWithFee);\n  await debtIssuance.connect(alice.wallet).issue(\n    subjectSetToken,\n    subjectQuantity,\n    alice.address,\n  );\n\n  //// Step 4: \n  [neededComponents, neededEquityUnits, neededDebtUnits] = await debtIssuance.getRequiredComponentRedemptionUnits(subjectSetToken, subjectQuantity);\n  neededWithFee = neededDebtUnits[1].mul(1005).div(1000);\n  setup.dai.connect(bob.wallet).approve(debtIssuance.address, neededWithFee);\n  await debtIssuance.connect(bob.wallet).redeem(\n    subjectSetToken,\n    subjectQuantity,\n    bob.address,\n  );\n\n  //// After Exploit\n  token1Balance = await token1.balanceOf(bob.address);\n  token2Balance = await token2.balanceOf(bob.address)\n  daiBalance = await setup.dai.balanceOf(bob.address)\n\n  expect(token1Balance).to.eq(ether(999));\n  expect(token2Balance).to.eq(ether(99.5));\n  expect(daiBalance).to.eq(ether(1));\n});\n```\n## Impact\nThe attacker can steal other users' tokens by calling the `redeem()` function after the new component has been added and another user calls the `issue()` function after that.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModuleV2.sol#L75-L126\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModuleV2.sol#L142-L190\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModule.sol#L502\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModule.sol#L566-L569\n\n## Tool used\n\nManual Review\n\n## Recommendation\nWe recommend adding validation before adding the new component in the `addComponent()` function in the SetToken contract, for example.\n\n```diff\nfunction addComponent(address _component) external onlyModule whenLockedOnlyLocker {\n    require(!isComponent(_component), \"Must not be component\");\n+   require(totalSupply() == 0, \"SetToken must not be minted\");\n    components.push(_component);\n\n    emit ComponentAdded(_component);\n}\n```","decidedSeverity":"false","decidedDuplication":"User can steal tokens of the `SetToken` contract via the `redeem()` function in the `DebtIssuanceModuleV2` contract"},{"file":"227.md","watson":{"name":"Inspex","days":34,"is_team":false,"payout":2774.5,"score":21.6732265969,"senior":false},"severity":"medium","title":"Protocol incompatibility with Fee-on-transfer/deflationary tokens","markdown":"Inspex\n\nmedium\n\n# Protocol incompatibility with Fee-on-transfer/deflationary tokens\n\n## Summary\nThe issue mechanism in contract `DebtIssuanceModuleV2` doesn't handle fee-on-transfer/deflationary correctly.\n\n\n## Vulnerability Detail\nWhen the user issues the SetToken, the user's token will be transferred as an underlying asset to the SetToken contract. Then the validation function `validateCollateralizationPostTransferInPreHook()` validates the transferred token.\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModuleV2.sol#L276\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/lib/IssuanceValidationUtils.sol#L48-L66\n\nAfter the deflationary token is transferred, the protocol will receive a lower amount than expected for validation, resulting in a validation failure.\n\n\n\n## Impact\nThe user will be unable to issue the SetToken with a component that is a fee-on-transfer token.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/lib/IssuanceValidationUtils.sol#L48-L66\n\n## Tool used\n\nManual Review\n\n## Recommendation\nWe recommend using balance validation both before and after token transfers in the contract.","decidedSeverity":"medium","decidedDuplication":"Protocol will not work with fee on transfer tokens"},{"file":"228.md","watson":{"name":"Brenzee","days":16,"is_team":false,"payout":126.56,"score":2.3261912329,"senior":false},"severity":"medium","title":"`call()` should be used instead of `transfer()`","markdown":"Brenzee\n\nmedium\n\n# `call()` should be used instead of `transfer()`\n\n## Summary\n`transfer()` is deprecated and `call()` is better to use since `call()` doesn't have fixed gas limit of 2300.\n\n## Vulnerability Detail\nThe `transfer()` and `send()` functions forward a fixed amount of 2300 gas. However, this limits the AaveLevarageStrategyExtension and AaveV3LevarageStrategyExtension contracts to interact with other contracts that need more than 2300 gas to process the transaction.\n\n## Impact\n`transfer()` uses a fixed amount of gas, which can result in a reverted transaction.\n\n## Code Snippet\n[- AaveLevarageStrategyExtension.1221](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1221)\n\n## Tool used\nManual Review\n\n## Recommendation\nChange the line to the code below\n```solidity\n        (success, result) = msg.sender.call{value: etherToTransfer}(\"\");\n```\n","decidedSeverity":"false","decidedDuplication":"`call()` should be used instead of `transfer()`"},{"file":"229.md","watson":{"name":"kn0t"},"severity":"medium","title":"onlyEOA modifier that ensures call is from EOA might not hold true in the future","markdown":"kn0t\n\nmedium\n\n# onlyEOA modifier that ensures call is from EOA might not hold true in the future\n\n## Summary\nThe modifier `onlyEOA` is implemented to restrict calls only to Externally Owned Accounts (EOAs). However, the implications of EIP 3074 could render this modifier ineffective.\n\n## Vulnerability Detail\nThe `onlyEOA` modifier uses `tx.origin` to validate that the transaction originates from an EOA and not a smart contract.\n```solidity\n    modifier onlyEOA() {\n        require(msg.sender == tx.origin, \"Caller must be EOA Address\");\n        _;\n    }\n```\n\nHowever, [EIP 3074](https://eips.ethereum.org/EIPS/eip-3074#abstract) introduces two EVM instructions: `AUTH` and `AUTHCALL`. The former sets a context variable based on an ECDSA signature, and the latter enables a call from the authorized account. This process essentially grants control of the EOA to a smart contract. Therefore, the usage of `tx.origin` to confirm `msg.sender` as an EOA might become unreliable if EIP 3074 is implemented.\n\n## Impact\nThe reliability of the `onlyEOA` modifier to restrict calls to EOAs might be compromised if EIP 3074 is adopted.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/lib/BaseExtension.sol#L59-L62\n\n## Tool used\n\nManual Review\n\n## Recommendation\nIt is recommended to use OpenZeppelin's isContract function (https://docs.openzeppelin.com/contracts/4.x/api/utils#Address-isContract-address-). However, this approach is not foolproof as it is vulnerable to edge cases such as contracts in the constructor. Therefore, caution should be exercised while using this solution.\n\n```solidity\n    modifier onlyEOA() {\n        require(!isContract(msg.sender), \"Caller must be EOA Address\");\n        _;\n    }\n```","decidedSeverity":"medium","decidedDuplication":"onlyEOA modifier that ensures call is from EOA might not hold true with the eip 3074"},{"file":"230.md","watson":{"name":"Brenzee","days":16,"is_team":false,"payout":126.56,"score":2.3261912329,"senior":false},"severity":"medium","title":"Chainlink's `latestAnswer` function is deprecated","markdown":"Brenzee\n\nmedium\n\n# Chainlink's `latestAnswer` function is deprecated\n\n## Summary\n`AaveLeverageStrategyExtension` use Chainlink's oracle to get prices of collateral and borrow tokens, but a deprecated function is used to fetch the prices.\n\n## Vulnerability Detail\nAccording to Chainlink's documentation, function [`latestAnswer`](https://docs.chain.link/data-feeds/api-reference) is deprecated and not intended to be used. \n\n## Impact\nUsing a deprecated function might DoS the AaveLeverageStrategyExtension and return incorrect prices \n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L895\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L897\n\n## Tool used\nManual Review\n\n## Recommendation\nIt is recommended to use Chainlink’s [latestRoundData()](https://docs.chain.link/data-feeds/api-reference) function to get the price instead.\n","decidedSeverity":"medium","decidedDuplication":"Deprecated oracle function `latestAnswer()` could bring fund loss"},{"file":"231.md","watson":{"name":"Brenzee","days":16,"is_team":false,"payout":126.56,"score":2.3261912329,"senior":false},"severity":"medium","title":"Precision loss is made in function `AaveLeverageStrategyExtension._calculateChunkRebalanceNotional`","markdown":"Brenzee\n\nmedium\n\n# Precision loss is made in function `AaveLeverageStrategyExtension._calculateChunkRebalanceNotional`\n\n## Summary\nThe function `_calculateChunkRebalanceNotional` is used to calculate the total notional rebalance quantity and chunked rebalance quantity in collateral units. The issue is that calculating `totalRebalanceNotional` may encounter precision loss\n\n## Vulnerability Detail\nIn Solidity if a division is being done before multiplication, precision might be lost.\nThis is what happens when `totalRebalanceNotional` is calculated\n\n```solidity\n        uint256 totalRebalanceNotional = leverageRatioDifference.preciseDiv(_leverageInfo.currentLeverageRatio).preciseMul(_leverageInfo.action.collateralBalance);\n```\n\n## Impact\nA precision loss might happen when `totalRebalanceNotional` is calculated in `_calculateChunkRebalanceNotional` function, which may cause unexpected values to be calculated.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1068\n\n## Tool used\nManual Review\n\n## Recommendation\nMake sure to multiply before dividing \n```solidity\n        uint256 totalRebalanceNotional = leverageRatioDifference.preciseMul(_leverageInfo.action.collateralBalance).preciseDiv(_leverageInfo.currentLeverageRatio);\n```\n","decidedSeverity":"false","decidedDuplication":"Precision loss is made in function `AaveLeverageStrategyExtension._calculateChunkRebalanceNotional`"},{"file":"232.md","watson":{"name":"0x007","days":6,"is_team":false,"payout":6.53,"score":0.2490655024,"senior":false},"severity":"medium","title":"Collateral and debt positions are not updated after issue and redeem of set token","markdown":"0x007\n\nmedium\n\n# Collateral and debt positions are not updated after issue and redeem of set token\n\n## Summary\nThe last steps in `DebtIssuanceModule` and `DebtIssuanceModuleV2` are resolving debts, equity and fees. resolving debts and equities would call `componentIssueHook` and `componentRedeemHook` from `AaveV3LeverageModule` if it was registered. `componentIssueHook` and `componentRedeemHook` call `_borrow` and `_repayBorrow` respectively which would `increase` and `decrease` debt token respectively. Unlike lever and delever, they don't update external positions. Nor update default position from changes in aToken balance.\n\n## Vulnerability Detail\nprimary position and external position are not updated after token issuance or redemption.\n\n## Impact\n* positionMultiplier cannot be updated\n* position would not be removed if newUnit is 0\n* get methods for position would return wrong value to initialized modules such as amm, airdrop, trade, and wrap. And depending on configuration, access control and transaction order, this could be devastating or annoying.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L695-L726\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L762-L788\n\n## Tool used\n\nManual Review\n\n## Recommendation\nUpdate collateral and debt position in component hooks. This could be as simple as calling `sync` again or `_updateCollateralPosition` and `_updateBorrowPosition` for better efficiency.\n","decidedSeverity":"false","decidedDuplication":"Collateral and debt positions are not updated after issue and redeem of set token"},{"file":"233.md","watson":{"name":"0x007","days":6,"is_team":false,"payout":6.53,"score":0.2490655024,"senior":false},"severity":"high","title":"_editPositionMultiplier compounds positionMultiplier","markdown":"0x007\n\nhigh\n\n# _editPositionMultiplier compounds positionMultiplier\n\n## Summary\nfees are streamed linearly across a year. So redeeming once at the end of the year and redeeming every day would result in the same amount of fees accrued. But the positionMultiplier is not linear and rather compounds\n\n## Vulnerability Detail\nThis table shows how frequency could affect `positionMultiplier` assuming the time between accruals is the same and streamingFeePercentage is 10%\n\n| accrue times  | newMultiplier formula | newMultiplier value   |\n| ------------- | --------------------- | --------------------- |\n| 1             | 0.9 ^ 1               | 0.9                   |\n| 10            | 0.99 ^ 10             | 0.90438               |\n| 100           | 0.999 ^ 100           | 0.90479               |\n| 1000          | 0.9999 ^ 1000         | 0.90483               |\n\n## Impact\nPositions have a slightly higher value than they ought to\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/StreamingFeeModule.sol#L278-L283\n\n## Tool used\n\nManual Review\n\n## Recommendation\nAn imperfect recommendation is to use `int256 newMultiplier = currentMultiplier.sub(_inflationFee.toInt256());` cause positionMultiplier starts from preciseUnit.\n","decidedSeverity":"false","decidedDuplication":"_editPositionMultiplier compounds positionMultiplier"},{"file":"234.md","watson":{"name":"Ocean_Sky"},"severity":"high","title":"Use of Deprecated Chainlink Function: latestAnswer()","markdown":"Ocean_Sky\n\nhigh\n\n# Use of Deprecated Chainlink Function: latestAnswer()\n\n## Summary\nUse of Deprecated Chainlink Function: latestAnswer()\n\n## Vulnerability Detail\nAccording to Chainlink’s documentation (API Reference), https://docs.chain.link/data-feeds/api-reference#latestanswer the latestAnswer function is deprecated. This function does not throw an error if no answer has been reached, but instead returns 0, possibly causing an incorrect price to be fed to the different price feeds.\n\n## Impact\nSeveral functions will be affected by wrong computation of collateralValue and borrowValue which is derived from chainlink price feed. These values are part of struct result of function _createActionInfo in which it is being used extensively within the contract AaveLeverageStrategyExtension.\n\nHere are the directly affected functions but the effect could also branch out with other related functions.\n1. Engage \n2. getCurrentLeverageRatio()\n3. getChunkRebalanceNotional\n4. _getAndValidateLeveragedInfo\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L895\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L897\n\n## Tool used\n\nManual Review\n\n## Recommendation\nIt is recommended to use Chainlink’s latestRoundData() function to get the price instead. It is also recommended to add checks on the return data with proper revert messages if the price is stale or the round is incomplete. Check also for L2 sequencer status whether it is active or not if the protocol will be deployed to Arbitrum and Optimism.\n","decidedSeverity":"medium","decidedDuplication":"Deprecated oracle function `latestAnswer()` could bring fund loss"},{"file":"235.md","watson":{"name":"0x007","days":6,"is_team":false,"payout":6.53,"score":0.2490655024,"senior":false},"severity":"medium","title":"transfer method is used to send Ether rather than call","markdown":"0x007\n\nmedium\n\n# transfer method is used to send Ether rather than call\n\n## Summary\ntransfer methods forwards a hardcoded 2300 gas limit and that might not be sufficient for transferring ETH if changes were made to gas requirements.\n\n## Vulnerability Detail\ntransfer method is used in `AaveLeverageStrategyExtension` to send ETH.\n\n## Impact\nThe contract might be incompatible on ethereum in the future or other chains.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L584\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1221\n\n## Tool used\n\nManual Review\n\n## Recommendation\nIt is recommended to use the call method for sending ETH\n","decidedSeverity":"false","decidedDuplication":"transfer method is used to send Ether rather than call"},{"file":"236.md","watson":{"name":"0x007","days":6,"is_team":false,"payout":6.53,"score":0.2490655024,"senior":false},"severity":"high","title":"invokeTransfer could cause fund to be lost for tokens that return false and don't revert","markdown":"0x007\n\nhigh\n\n# invokeTransfer could cause fund to be lost for tokens that return false and don't revert\n\n## Summary\ninvokeTransfer is used in DebtIssuanceModuleV2 on issue and redeem. invokeTransfer uses setToken to invoke `transfer(address,uint256)` method and it doesn't check the returned data. This could be an issue if token returns false for failed transfer.\n\n## Vulnerability Detail\nSome ERC20 tokens return false when transfer or approve fails. They don't revert and it's expected that the caller handles the failure by checking the returned boolean. An example of such token is [ZRX](https://etherscan.io/address/0xE41d2489571d322189246DaFA5ebDe1F4699F498#code).\n\n## Impact\nIf transfer fail, the transaction would still be successful and token would be minted or burned. Scenarios that could lead to loss of fund\n* user that called issue doesn't get debt token\n* user that called redeem doesn't get equity token\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModuleV2.sol#L283\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModuleV2.sol#L315\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/lib/Invoke.sol#L66-L78\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/lib/Invoke.sol#L46-L66\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/SetToken.sol#L197-L212\n\n## Tool used\n\nManual Review\n\n## Recommendation\nIf there's returndata from `_setToken.invoke` in `invokeTransfer` and `invokeApprove`, check that it is true and revert if false. `if (returndata.length > 0) require(abi.decode(returndata, (bool)), \"ErrMsg\");`\n","decidedSeverity":"medium","decidedDuplication":"AmmModule will not work with usdt"},{"file":"237.md","watson":{"name":"0x007","days":6,"is_team":false,"payout":6.53,"score":0.2490655024,"senior":false},"severity":"high","title":"Some iterated arrays are unbounded and could lead to permanent DoS on issue and redeem of set token","markdown":"0x007\n\nhigh\n\n# Some iterated arrays are unbounded and could lead to permanent DoS on issue and redeem of set token\n\n## Summary\nSome arrays are looped through till the end for some operation. If this array gets too big, operation could require gas that's more than block gas limit and therefore those operations won't be performed. A function that uses these arrays frequently is `issue` and `redeem` in `DebtIssuanceModule`.\n\n## Vulnerability Detail\nUnbounded array cases include\n* SetToken default and external position during `editPositionMultiplier` or module operations like issue, redeem\n* AaveV3LeverageModule's collateralAssets and borrowAssets in `removeModule` and `sync` (which would be called on issue and redeem)\n* exchangeNames in AaveLeverageStrategyExtension\n* airdrop tokens in AirdropModule can affect operations that rely on `getAirdrops` plus `batchAbsorb` such as [syncing](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/hooks/AirdropIssuanceHook.sol#L76-L79)\n\nissue and redeem function in DebtIssuanceModule and DebtIssuanceModuleV2 loop through setToken components 4 times in `_calculateRequiredComponentIssuanceUnits`, `_resolveEquityPositions`, `_resolveDebtPositions`, and `_resolveFees`. But that's after calling `_callManagerPreIssueHooks` and `_callModulePreIssueHooks` which could trigger `AaveV3LeverageModule.sync` and loop through collateralAssets and borrowAssets\n\n## Impact\nDoS is possible and it could affect issuance and redemption of setToken. If it affects issuance and redemption, then tokens would be locked. It would be impossible to unlock and regain activity cause they would be needed to remove positions by moving them to 0. The only way to remove position is in [editDefaultPosition](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/lib/Position.sol#L105) and [editExternalPosition](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/lib/Position.sol#L153).\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/SetToken.sol#L600-L624\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModule.sol#L453-L484\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModuleV2.sol#L106-L112\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/lib/Position.sol#L105\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/lib/Position.sol#L153\n\n## Tool used\n\nManual Review\n\n## Recommendation\nHave a limit on number of positions in a setToken.\n","decidedSeverity":"false","decidedDuplication":"Some iterated arrays are unbounded and could lead to permanent DoS on issue and redeem of set token"},{"file":"238.md","watson":{"name":"rugpull_detector"},"severity":"high","title":"PriceOracle.getPrice() will revert when inverse price is zero and there's no direct oracle but inverse, because of division by zero.","markdown":"rugpull_detector\n\nhigh\n\n# PriceOracle.getPrice() will revert when inverse price is zero and there's no direct oracle but inverse, because of division by zero.\n\nPriceOracle.getPrice() will revert when inverse price is zero and there's no direct oracle but inverse, because of division by zero.\n\n## Summary\n[PriceOracle.getPrice()#L126](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/PriceOracle.sol#L126) will always revert because of division by zero when there's no direct oracle and inverse oracle price is zero.\n\n## Vulnerability Detail\n- PriceOracle.getPrice() is very critical function of this system as it feeds important price information.\n- It always call _getDirectOrInversePrice() first. _getDirectOrInversePrice checks if there's any direct oracle registered\n- there's none then, it goes on to look for inverse oracle. \n- calculated price is PreciseUnitMath.preciseUnit() / Inverse oracle price is\n- But if Inverse oracle read price is zero,  it reverts.\n\n## Impact\nThere are several functions that rely on PriceOracle.getPrice()\n- SetValuer.calculateSetTokenValuation()#L92 (https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/SetValuer.sol#L92)\n- SetValuer.calculateSetTokenValuation()#L106 (https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/SetValuer.sol#L106)\n- UniswapPairPriceAdapter.getPrice()#L138 (https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/integration/oracles/UniswapPairPriceAdapter.sol#L138)\n- UniswapPairPriceAdapter.getPrice()#L145 (https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/integration/oracles/UniswapPairPriceAdapter.sol#L145)\n\n## Code Snippets\nPriceOracle.getPrice() https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/PriceOracle.sol#L117-L139\nPriceOracle._getDirectOrInversePrice() https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/PriceOracle.sol#L253-L279\nPriceOracle._calculateInversePrice() https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/PriceOracle.sol#L351-L356\n\n## Tool used\n\nManual Review\n\n## Recommendation\nIt should return false not revert when inverse oracle price indicates zero.\n\nPriceOracle._calculateInversePrice()\n```solidity\n    function _calculateInversePrice(IOracle _inverseOracle) internal view returns(bool, uint256) {\n        uint256 inverseValue = _inverseOracle.read();\n+        if (inverseValue == 0)\n+                return (false, 0);\n\n-        return PreciseUnitMath.preciseUnit().preciseDiv(inverseValue);\n+        return (true, PreciseUnitMath.preciseUnit().preciseDiv(inverseValue));\n    }\n```\nPriceOracle._getDirectOrInversePrice()\n```solidity\n        // If not, check asset 2 -> asset 1. If exists, then return 1 / asset1 -> asset2\n        if (hasInverseOracle) {\n-                return (true, _calculateInversePrice(inverseOracle));\n+                return calculateInversePrice(inverseOracle);\n        }\n```","decidedSeverity":"medium","decidedDuplication":"Unhandled chainlink revert would lock price oracle access"},{"file":"239.md","watson":{"name":"kn0t"},"severity":"medium","title":"Use of deprecated chainlink function: latestAnswer()","markdown":"kn0t\n\nmedium\n\n# Use of deprecated chainlink function: latestAnswer()\n\n## Summary\nAccording to Chainlink’s documentation ([API Reference](https://docs.chain.link/data-feeds/api-reference#latestanswer)), the latestAnswer function is deprecated. This function does not throw an error if no answer has been reached, but instead returns 0, possibly causing an incorrect price to be fed to the different price feeds or even a Denial of Service.\n\n## Vulnerability Detail\n```solidity\n    function _createActionInfo() internal view returns(ActionInfo memory) {\n        ActionInfo memory rebalanceInfo;\n\n        // Calculate prices from chainlink. Chainlink returns prices with 8 decimal places, but we need 36 - underlyingDecimals decimal places.\n        // This is so that when the underlying amount is multiplied by the received price, the collateral valuation is normalized to 36 decimals. \n        // To perform this adjustment, we multiply by 10^(36 - 8 - underlyingDecimals)\n        int256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\n        rebalanceInfo.collateralPrice = rawCollateralPrice.toUint256().mul(10 ** strategy.collateralDecimalAdjustment);\n        int256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer();\n        rebalanceInfo.borrowPrice = rawBorrowPrice.toUint256().mul(10 ** strategy.borrowDecimalAdjustment);\n\n        rebalanceInfo.collateralBalance = strategy.targetCollateralAToken.balanceOf(address(strategy.setToken));\n        rebalanceInfo.borrowBalance = strategy.targetBorrowDebtToken.balanceOf(address(strategy.setToken));\n        rebalanceInfo.collateralValue = rebalanceInfo.collateralPrice.preciseMul(rebalanceInfo.collateralBalance);\n        rebalanceInfo.borrowValue = rebalanceInfo.borrowPrice.preciseMul(rebalanceInfo.borrowBalance);\n        rebalanceInfo.setTotalSupply = strategy.setToken.totalSupply();\n\n        return rebalanceInfo;\n    }\n```\n## Impact\nIncorrect return price value lead to incorrect `collateralPrice`, `collateralValue`, `borrowPrice` and `borrowValue`  calculations.\nwhich are used in functions `engage`, `getCurrentLeverageRatio`, `_getAndValidateLeveragedInfo` and `getChunkRebalanceNotional`.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L895\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L897\n\n## Tool used\n\nManual Review\n\n## Recommendation\nIt is recommended to use Chainlink’s `latestRoundData()` function to get the price instead. It is also recommended to add checks on the return data with proper revert messages if the price is stale or the round is incomplete, for example:\n```solidity\n    function _createActionInfo() internal view returns(ActionInfo memory) {\n        ActionInfo memory rebalanceInfo;\n\n        // Calculate prices from chainlink. Chainlink returns prices with 8 decimal places, but we need 36 - underlyingDecimals decimal places.\n        // This is so that when the underlying amount is multiplied by the received price, the collateral valuation is normalized to 36 decimals. \n        // To perform this adjustment, we multiply by 10^(36 - 8 - underlyingDecimals)\n        (uint80 collateralBaseRoundID, int256 rawCollateralPrice, , uint256 collateralBaseTimestamp, uint80 collateralBaseAnsweredInRound) = strategy.collateralPriceOracle.latestRoundData();\n        require(rawCollateralPrice > 0, \"Collateral Price <= 0\");\n        require(collateralBaseAnsweredInRound >= collateralBaseRoundID , \"Collateral Stale price\");\n        require(collateralBaseTimestamp > 0, \"Collateral round not complete\");\n        rebalanceInfo.collateralPrice = rawCollateralPrice.toUint256().mul(10 ** strategy.collateralDecimalAdjustment);\n        (uint80 borrowBaseRoundID, int256 rawBorrowPrice, , uint256 borrowBaseTimestamp, uint80 borrowBaseAnsweredInRound) = strategy.borrowPriceOracle.latestRoundData();\n        require(rawBorrowPrice > 0, \"Borrow Price <= 0\");\n        require(borrowBaseAnsweredInRound >= borrowBaseRoundID , \"Borrow Stale price\");\n        require(borrowBaseTimestamp > 0, \"Borrow round not complete\");\n        rebalanceInfo.borrowPrice = rawBorrowPrice.toUint256().mul(10 ** strategy.borrowDecimalAdjustment);\n\n        rebalanceInfo.collateralBalance = strategy.targetCollateralAToken.balanceOf(address(strategy.setToken));\n        rebalanceInfo.borrowBalance = strategy.targetBorrowDebtToken.balanceOf(address(strategy.setToken));\n        rebalanceInfo.collateralValue = rebalanceInfo.collateralPrice.preciseMul(rebalanceInfo.collateralBalance);\n        rebalanceInfo.borrowValue = rebalanceInfo.borrowPrice.preciseMul(rebalanceInfo.borrowBalance);\n        rebalanceInfo.setTotalSupply = strategy.setToken.totalSupply();\n\n        return rebalanceInfo;\n    }\n```\n","decidedSeverity":"medium","decidedDuplication":"Deprecated oracle function `latestAnswer()` could bring fund loss"},{"file":"240.md","watson":{"name":"caventa","days":102,"is_team":false,"payout":1746.02,"score":3.7299897076,"senior":false},"severity":"medium","title":"Allow a setToken to have too many components and too many external module for every component will cause certain functions not be able to be run","markdown":"caventa\n\nmedium\n\n# Allow a setToken to have too many components and too many external module for every component will cause certain functions not be able to be run\n\n## Summary\nAllow a setToken to have too many components and too many external modules for every component will cause certain functions not be able to be run due to EVM gas limit.\n\n## Vulnerability Detail\nLet's take DebtIssuanceModuleV2#issue as an example,\n\n```solidity\nfunction issue(\n        ISetToken _setToken,\n        uint256 _quantity,\n        address _to\n    )\n        external\n        override\n        nonReentrant\n        onlyValidAndInitializedSet(_setToken)\n    {\n        require(_quantity > 0, \"Issue quantity must be > 0\");\n\n        address hookContract = _callManagerPreIssueHooks(_setToken, _quantity, msg.sender, _to);\n\n        _callModulePreIssueHooks(_setToken, _quantity);\n\n        uint256 initialSetSupply = _setToken.totalSupply();\n\n        (\n            uint256 quantityWithFees,\n            uint256 managerFee,\n            uint256 protocolFee\n        ) = calculateTotalFees(_setToken, _quantity, true);\n\n        // Prevent stack too deep\n        {\n            (\n                address[] memory components,\n                uint256[] memory equityUnits,\n                uint256[] memory debtUnits\n            ) = _calculateRequiredComponentIssuanceUnits(_setToken, quantityWithFees, true); // audit => There are 2 loopings of components here. In the first looping, there is a looping of external position\n\n            uint256 finalSetSupply = initialSetSupply.add(quantityWithFees);\n\n            _resolveEquityPositions(_setToken, quantityWithFees, _to, true, components, equityUnits, initialSetSupply, finalSetSupply); // @audit => There is 1 looping of components here. In the looping there is a looping of its external position\n            \n            _resolveDebtPositions(_setToken, quantityWithFees, true, components, debtUnits, initialSetSupply, finalSetSupply); // @audit => There is 1 looping of components here. In the looping there is a looping of its external position\n            _resolveFees(_setToken, managerFee, protocolFee);\n        }\n\n        _setToken.mint(_to, _quantity);\n\n        emit SetTokenIssued(\n            _setToken,\n            msg.sender,\n            _to,\n            hookContract,\n            _quantity,\n            managerFee,\n            protocolFee\n        );\n    }\n```\n\n1. _calculateRequiredComponentIssuanceUnits\n\nThere are 2 loopings of components here. In the first looping, there is a looping of external position\n\n2.  _resolveEquityPositions\n\nThere is 1 looping of components here. In the looping there is a looping of its external position\n\n3. _resolveDebtPositions\n\nThere is 1 looping of components here. In the looping there is a looping of its external position\n\n## Impact\n\nIf too many components and too many external modules is added to the component, it is possible that the function is will always get reverted due to breaching gas limit of a block.\n\n## Code Snippet\nhttps://github.com/IndexCoop/index-protocol/blob/master/contracts/protocol/modules/v1/DebtIssuanceModuleV2.sol#L75-L126\n\n## Tool used\nManual Review\n\n## Recommendation\nAdd a number as the limit to components and its external module","decidedSeverity":"false","decidedDuplication":"Allow a setToken to have too many components and too many external module for every component will cause certain functions not be able to be run"},{"file":"241.md","watson":{"name":"Madalad","days":3,"is_team":false,"payout":0.3,"score":0.0697269825,"senior":false},"severity":"medium","title":"Check that call is from EOA may not hold true in the future","markdown":"Madalad\n\nmedium\n\n# Check that call is from EOA may not hold true in the future\n\n## Summary\n\nWithin the `onlyEOA` modifier, the following code is used to check that the caller is an EOA:\n\n```solidity\n    require(msg.sender == tx.origin, \"Caller must be EOA Address\");\n```\n\nHowever, [EIP3074](https://eips.ethereum.org/EIPS/eip-3074) would mean that this does not provide such a guarantee.\n\n## Vulnerability Detail\n\n[EIP3074](https://eips.ethereum.org/EIPS/eip-3074) introduces two EVM instructions `AUTH` and `AUTHCALL`. The first sets a context variable authorized based on an ECDSA signature. The second sends a call as the authorized account. This essentially delegates control of the externally owned account (EOA) to a smart contract.\n\nTherefore, using tx.origin to ensure msg.sender is an EOA will not hold true in the event EIP 3074 goes through.\n\n## Impact\n\nCurrent checks to ensure caller is an EOA will be easily bypassable in the event that EIP3074 goes through.\n\n## Code Snippet\n\n```solidity\nFile: ..//index-coop-smart-contracts/contracts/lib/BaseExtension.sol\n\n60:         require(msg.sender == tx.origin, \"Caller must be EOA Address\");\n\n```\nhttps://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/lib/BaseExtension.sol#L60\n\n```solidity\nFile: ..//index-protocol/contracts/protocol/modules/v1/SingleIndexModule.sol\n\n130:         require(msg.sender == tx.origin, \"Caller must be EOA Address\");\n\n```\nhttps://github.com/IndexCoop/index-protocol/blob/86be7ee76d9a7e4f7e93acfc533216ebef791c89/contracts/protocol/modules/v1/SingleIndexModule.sol#L130\n\n```solidity\nFile: ..//index-protocol/contracts/protocol/modules/v1/GeneralIndexModule.sol\n\n1164:             require(msg.sender == tx.origin, \"Caller must be EOA Address\");\n\n```\nhttps://github.com/IndexCoop/index-protocol/blob/86be7ee76d9a7e4f7e93acfc533216ebef791c89/contracts/protocol/modules/v1/GeneralIndexModule.sol#L1164\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCheck the bytecode size of the calling address to determine whether the user is an EOA:\n\n```solidity\n    require(msg.sender.code.length == 0, \"Caller must be EOA Address\");\n```\n\nNote that this check will still be passed by\n- a contract in construction\n- an address where a contract will be created\n- an address where a contract lived, but was destroyed\n\nhence caution is still required.","decidedSeverity":"medium","decidedDuplication":"onlyEOA modifier that ensures call is from EOA might not hold true with the eip 3074"},{"file":"242.md","watson":{"name":"Madalad","days":3,"is_team":false,"payout":0.3,"score":0.0697269825,"senior":false},"severity":"medium","title":"Use of deprecated Chainlink functions","markdown":"Madalad\n\nmedium\n\n# Use of deprecated Chainlink functions\n\n## Summary\n\n`AaveLeverageStrategyExtension#__createActionInfo` uses a deprecated function to fetch oracle prices.\n\n## Vulnerability Detail\n\nThe [Chainlink docs](https://docs.chain.link/data-feeds/api-reference#latestanswer) state that the `latestAnswer` function is deprecated and warns \"DO NOT USE THIS FUNCTION\". It is unwise to continue using deprecated functions because they are outdated and often lack important functionality that can be found in newer alternatives. Also, they can be eventually removed completely, which would be very problematic if the protocol has not prepared for such an event in advance.\n\n## Impact\n\n`latestAnswer` does not throw an error if no answer has been reached, but instead returns 0, possibly causing an incorrect price to be fed to the different price feeds or even a Denial of Service by a division by zero. Moreover, if the returned value is non-zero, there is no way to determine the staleness of the result, meaning outdated prices could be used which could negatively affect users.\n\n## Code Snippet\n\n```solidity\n    function _createActionInfo() internal view returns(ActionInfo memory) {\n        ActionInfo memory rebalanceInfo;\n\n        // Calculate prices from chainlink. Chainlink returns prices with 8 decimal places, but we need 36 - underlyingDecimals decimal places.\n        // This is so that when the underlying amount is multiplied by the received price, the collateral valuation is normalized to 36 decimals. \n        // To perform this adjustment, we multiply by 10^(36 - 8 - underlyingDecimals)\n        int256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer(); // @audit latestAnswer is deprecated\n        rebalanceInfo.collateralPrice = rawCollateralPrice.toUint256().mul(10 ** strategy.collateralDecimalAdjustment);\n        int256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer(); // @audit latestAnswer is deprecated\n\n        // ...\n    \n    }\n```\nhttps://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/adapters/AaveLeverageStrategyExtension.sol#L889-L907\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse [`latestRoundData`](https://docs.chain.link/data-feeds/api-reference#latestrounddata-1) instead of `latestAnswer`, and make sure to properly validate the returned data.\n\n```diff\n    function _createActionInfo() internal view returns(ActionInfo memory) {\n        ActionInfo memory rebalanceInfo;\n\n        // Calculate prices from chainlink. Chainlink returns prices with 8 decimal places, but we need 36 - underlyingDecimals decimal places.\n        // This is so that when the underlying amount is multiplied by the received price, the collateral valuation is normalized to 36 decimals. \n        // To perform this adjustment, we multiply by 10^(36 - 8 - underlyingDecimals)\n\n-       int256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\n+       (,int256 rawCollateralPrice,,uint256 updatedAt,) = strategy.collateralPriceOracle.latestRoundData();\n+       require(rawCollateralPrice > 0, \"invalid price\");\n+       require(block.timestamp - updatedAt < MAX_DELAY, \"stale price\");\n\n        rebalanceInfo.collateralPrice = rawCollateralPrice.toUint256().mul(10 ** strategy.collateralDecimalAdjustment);\n\n-       int256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer();\n+       (,int256 rawBorrowPrice,,uint256 updatedAt,) = strategy.borrowPriceOracle.latestRoundData();\n+       require(rawBorrowPrice > 0, \"invalid price\");\n+       require(block.timestamp - updatedAt < MAX_DELAY, \"stale price\");\n\n        // ...\n    \n    }\n\n```","decidedSeverity":"medium","decidedDuplication":"Deprecated oracle function `latestAnswer()` could bring fund loss"},{"file":"243.md","watson":{"name":"Madalad","days":3,"is_team":false,"payout":0.3,"score":0.0697269825,"senior":false},"severity":"medium","title":"Ether sent to `SetToken` contract will be trapped indefinitely","markdown":"Madalad\n\nmedium\n\n# Ether sent to `SetToken` contract will be trapped indefinitely\n\n## Summary\n\nSetToken.sol implements a `receive` function allowing it to receive ether, however there is no way to retrieve ether from the contract.\n\n## Vulnerability Detail\n\nThe presence of a `receive` function in SetToken.sol implies that the contract is expected to receive ether. However in the current implementation all ether sent to the contract, intentionally or not, will be trapped in the contract forever.\n\n## Impact\n\nLoss of ether.\n\n## Code Snippet\n\n```solidity\nFile: index-protocol/contracts/protocol/SetToken.sol\n\n536:    receive() external payable {} // solium-disable-line quotes\n```\nhttps://github.com/IndexCoop/index-protocol/blob/86be7ee76d9a7e4f7e93acfc533216ebef791c89/contracts/protocol/SetToken.sol#L536\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nIf the contract is intended to be able to receive ether, implement a function to withdraw the contracts ether balance. Otherwise, remove the `receive` function so that should anyone accidentally attempt to send ether to the contract, the call will revert and the ether will not become trapped.","decidedSeverity":"false","decidedDuplication":"Ether sent to `SetToken` contract will be trapped indefinitely"},{"file":"244.md","watson":{"name":"seerether"},"severity":"high","title":"No checks in emergencyRemoveProtectedModule","markdown":"seerether\n\nhigh\n\n# No checks in emergencyRemoveProtectedModule\n\n## Summary\n emergencyRemoveProtectedModule can be misused  by the operator\n\n## Vulnerability Detail\nIt leaves the system in an inconsistent state , disrupt the functionality of the smart contract and affect other modules or extensions that rely on the removed module resulting to loss of fund and trust\n\n## Impact\nThe principle of decentralization is undermined. It concentrates power in the hands of a single entity, which goes against the philosophy of blockchain and smart contracts.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/manager/BaseManagerV2.sol#L356-L362\n\n## Tool used\nManual Review\n\n## Recommendation \nUse a  modified function that adds a check to ensure that there are no authorized extensions remaining for the module being removed\n\nhttps://github.com/seerether/IndexCoop/blob/d6fafe70e6dddbee484c0501c3ea746bbd155639/indexcoopmitigation#L15-L18","decidedSeverity":"false","decidedDuplication":"No checks in emergencyRemoveProtectedModule"},{"file":"245.md","watson":{"name":"martin","days":56,"is_team":false,"payout":328.54,"score":1.3928867099,"senior":false},"severity":"medium","title":"Usage of deprecated `transfer` to send eth","markdown":"martin\n\nmedium\n\n# Usage of deprecated `transfer` to send eth\n\n## Summary\n\nUsage of a deprecated way to send the entire Ether balance can lead to reverting `withdrawEtherBalance()` method.\n\n## Vulnerability Detail\n\nThe use of the deprecated `transfer()` function for an address will inevitably make the transaction fail when:\n\n1. The claimer smart contract does not implement a payable function.\n2. The claimer smart contract does implement a payable fallback which uses more than 2300 gas unit.\n3. The claimer smart contract implements a payable fallback function that needs less than 2300 gas units but is called through proxy, raising the call's gas usage above 2300. Additionally, using higher than 2300 gas might be mandatory for some multisig wallets. Even if the current design is the operator to use an EOA, you might decide to use a multisig in a later stage, and using `call()` will work for both, unlike `transfer()`.\n\n## Impact\n\nUsage of deprecated way to send the entire Ether balance can lead to reverting `withdrawEtherBalance()` method.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L584\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1221\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse `call()` with value instead of `transfer()`.\n\n```diff\n-- msg.sender.transfer(address(this).balance);\n\n++ (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n++ require(success, \"Transfer failed\");0.\n```\n","decidedSeverity":"false","decidedDuplication":"Usage of deprecated `transfer` to send eth"},{"file":"246.md","watson":{"name":"tsvetanovv","days":71,"is_team":false,"payout":1472.34,"score":8.4782267837,"senior":false},"severity":"high","title":"`mutualUpgrade()` modifier can be bypass","markdown":"tsvetanovv\n\nhigh\n\n# `mutualUpgrade()` modifier can be bypass\n\n## Summary\n\n`MutualUpgrade.sol` we have modifier `mutualUpgrade()`:\n```solidity\nmodifier mutualUpgrade(address _signerOne, address _signerTwo) { \n        require(\n            msg.sender == _signerOne || msg.sender == _signerTwo,\n            \"Must be authorized address\"\n        );\n\n        address nonCaller = _getNonCaller(_signerOne, _signerTwo);\n\n        // The upgrade hash is defined by the hash of the transaction call data and sender of msg,\n        // which uniquely identifies the function, arguments, and sender.\n        bytes32 expectedHash = keccak256(abi.encodePacked(msg.data, nonCaller));\n\n        if (!mutualUpgrades[expectedHash]) {\n            bytes32 newHash = keccak256(abi.encodePacked(msg.data, msg.sender));\n            mutualUpgrades[newHash] = true;\n            emit MutualUpgradeRegistered(newHash);\n            return;\n        }\n\n        delete mutualUpgrades[expectedHash];\n\n        // Run the rest of the upgrades\n        _;\n    }\n```\nThis modifier is very important for the protocol and is used in `StreamingFeeSplitExtension.sol` and `BaseManagerV2.sol` contracts which are in audit scope. \n\nIt is used to ensure that it will be called necessarily by two signers (`_signerOne`, `_signerTwo`) and requires the mutual agreement of both before proceeding to action.\n\n## Vulnerability Detail\n\nThe modifier can be completely bypassed because didn't check if the same signer from calling the function twice consecutively.\n\n- The first call from the signer will create a hash using the `msg.data` and the address of the other signer (`nonCaller`). This hash will be used as a key to set a flag in the `mutualUpgrades` mapping.\n- Now, if the same signer makes the exact same call again, the system will again create the same hash as in the first call because the `msg.data` is the same (same function and parameters) and the `nonCaller` is the same. The system will see that the flag is already set in the `mutualUpgrades` mapping for this hash and will proceed to the deletion of the flag in `mutualUpgrades` mapping and execution of the code denoted by `_`.\n\nThis is a serious vulnerability. One signer can execute actions without the consent of the other, defeating the purpose of the two-signer control mechanism.\n\n## Impact\n\nThe requirement of having two different signers approve an action is effectively bypassed.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/lib/MutualUpgrade.sol#L41-L67\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nYou could implement a mechanism to store and check the address of the signer who initiated each action. For example, you could use an additional mapping to store the initiator's address for each action. Before an action is performed, you could check that the initiator is not the same as the current caller.","decidedSeverity":"false","decidedDuplication":"`mutualUpgrade()` modifier can be bypass"},{"file":"247.md","watson":{"name":"n33k","days":50,"is_team":false,"payout":1586.04,"score":11.3705816321,"senior":false},"severity":"medium","title":"invokeApprove should approve 0 first","markdown":"n33k\n\nmedium\n\n# invokeApprove should approve 0 first\n\n## Summary\n\nSome non-standard ERC20 tokens, such as USDT, require approve 0 first, otherwise they will revert. The `invokeApprove` method is not handling this case which makes the modules incompatible with these tokens.\n\n## Vulnerability Detail\n\nThe invokeApprove is called in modules to make ERC20 approvals. But it does not approve 0 first.\n\n```solidity\n    function invokeApprove(\n        ISetToken _setToken,\n        address _token,\n        address _spender,\n        uint256 _quantity\n    )\n        internal\n    {\n        bytes memory callData = abi.encodeWithSignature(\"approve(address,uint256)\", _spender, _quantity);\n        _setToken.invoke(_token, 0, callData);\n    }\n```\n\n## Impact\n\nThe modules is not compatible with certain ERC20 tokens.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/lib/Invoke.sol#L46-L56\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nApprove 0 first.\n\n```diff\n    function invokeApprove(\n        ISetToken _setToken,\n        address _token,\n        address _spender,\n        uint256 _quantity\n    )\n        internal\n    {\n+       bytes memory callData0 = abi.encodeWithSignature(\"approve(address,uint256)\", _spender, 0);\n+       _setToken.invoke(_token, 0, callData0);\n+\n        bytes memory callData = abi.encodeWithSignature(\"approve(address,uint256)\", _spender, _quantity);\n        _setToken.invoke(_token, 0, callData);\n    }\n```","decidedSeverity":"medium","decidedDuplication":"AmmModule will not work with usdt"},{"file":"248.md","watson":{"name":"tallo","days":34,"is_team":false,"payout":104.47,"score":0.8373650399,"senior":false},"severity":"high","title":"```ClaimModule``` does not update the position which leads to the accumulated rewards being lost","markdown":"tallo\n\nhigh\n\n# ```ClaimModule``` does not update the position which leads to the accumulated rewards being lost\n\n## Summary\n```ClaimModule``` contains functionality to accumulate rewards through the ```_claim``` function. This function does not properly update the setTokens position as other modules such as ```AirdropModule``` do. This leads to the accumulated/claimed rewards not incrementing the position value through ```position#editDefaultPosition```.  \n\n## Vulnerability Detail\ninside ```ClaimModule#_claim``` the functionality to claim rewards is implemented. The function calculates the before and after balance of the ```rewardsToken``` for the passed SetToken before emitting an event and returning without calling ```_setToken.editDefaultPosition``` \n```solidity\n    function _claim(ISetToken _setToken, address _rewardPool, string calldata _integrationName) internal {\n        require(isRewardPool(_setToken, _rewardPool), \"RewardPool not present\");\n        IClaimAdapter adapter = _getAndValidateIntegrationAdapter(_setToken, _rewardPool, _integrationName);\n\n        IERC20 rewardsToken = IERC20(adapter.getTokenAddress(_rewardPool));\n        \n        //@audit rewards token before balance\n        uint256 initRewardsBalance = rewardsToken.balanceOf(address(_setToken));\n        \n\n        (\n            address callTarget,\n            uint256 callValue,\n            bytes memory callByteData\n        ) = adapter.getClaimCallData(\n            _setToken,\n            _rewardPool\n        );\n        //@audit calls from the context of _setToken the protocol specific claim function such as claimComp for compound.\n        _setToken.invoke(callTarget, callValue, callByteData);\n\n        //@audit calculate the final balance of the rewards token after claiming\n        //the total rewards received will be finalRewardsBalance-initRewardsBalance\n        uint256 finalRewardsBalance = rewardsToken.balanceOf(address(_setToken));\n\n        //@audit here the position should be updated \n        //..\n\n        emit RewardClaimed(_setToken, _rewardPool, adapter, finalRewardsBalance.sub(initRewardsBalance));\n    }\n```\n\n## Impact\nThe position is what keeps track of the amount of tokens held for a specific component and is used when calling ```DebtIssuanceModule#redeem``` so that the setToken manager can redeem their SetToken shares for the underyling assets. The ```DebtIssuanceModule#redeem``` function makes further function calls to ```DebtIssuanceModule#_calculateRequiredComponentIssuanceUnits``` and ```DebtIssuanceModule#_getTotalIssuanceUnits``` which is where the individual position values are summed up to get the total position value. This value won't include the accumulated rewards, so the rewards will be trapped in the contract. \n\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModule.sol#L191\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModule.sol#L495\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/ClaimModule.sol#L375\n\n## Tool used\n\nManual Review\n\n## Recommendation\nThe include functionality that edits the default position by calling ```_setToken.editDefaultPosition``` to take into account the newly accrued tokens. Airdrop for instance correctly updates the position to account for the recently airdropped tokens.\n```solidity\n    function _handleAirdropPosition(ISetToken _setToken, IERC20 _token) internal {\n        uint256 preFeeTokenBalance = _token.balanceOf(address(_setToken));\n        uint256 amountAirdropped = preFeeTokenBalance.sub(_setToken.getDefaultTrackedBalance(address(_token)));\n\n        if (amountAirdropped > 0) {\n            (uint256 managerTake, uint256 protocolTake, uint256 totalFees) = _handleFees(_setToken, _token, amountAirdropped);\n\n            uint256 newUnit = _getPostAirdropUnit(_setToken, preFeeTokenBalance, totalFees);\n\n            _setToken.editDefaultPosition(address(_token), newUnit);\n\n            emit ComponentAbsorbed(_setToken, _token, amountAirdropped, managerTake, protocolTake);\n        }\n    }\n```\n\nNote that this method can still lead to a griefing attack on rewards. Since certain rewards pools such as ```comptroller#claimComp``` implement the claim function publicly, its possible for anybody to call the function for anybody else. This means the rewards would still be sent without updating the setToken and the same issue above would occur. A workaround to this would be to include additional functionality that tracks setTokens individual token balances to see if there are inconsistencies between that and componentPositions virtualUnits.","decidedSeverity":"false","decidedDuplication":"```ClaimModule``` does not update the position which leads to the accumulated rewards being lost"},{"file":"249.md","watson":{"name":"MohammedRizwan"},"severity":"medium","title":"Unhandled chainlink revert would lock price oracle access","markdown":"MohammedRizwan\n\nmedium\n\n# Unhandled chainlink revert would lock price oracle access\n\n## Summary\nChainlink's latestAnswer() is used which could potentially revert and make it impossible to query any prices. This could lead to permanent denial of service.\n\n## Vulnerability Detail\nFollowing smart contract function uses latestAnswer(),\n\nIn AaveLeverageStrategyExtension.sol contract, _createActionInfo() function is given by,\n\n```solidity\nFile: contracts/adapters/AaveLeverageStrategyExtension.sol\n\n895        int256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\n\n897        int256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer();\n\n```\n[Link to code](https://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/adapters/AaveLeverageStrategyExtension.sol#L895-L897)\n\nAs seen above, _createActionInfo() function makes use of Chainlink's latestAnswer() to get the latest price. However, there is no fallback logic to be executed when the access to the Chainlink data feed is denied by Chainlink's multisigs. Chainlink's multisigs can immediately block access to price feeds at will. Therefore, to prevent denial of service scenarios, it is recommended to query Chainlink price feeds using a defensive approach with Solidity’s try/catch structure. In this way, if the call to the price feed fails, the caller contract is still in control and can handle any errors safely and explicitly.\n\n## Impact\nCall to latestAnswer could potentially revert and make it impossible to query any prices. This could lead to permanent denial of service.\n\n## Code Snippet\nhttps://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/adapters/AaveLeverageStrategyExtension.sol#L895-L897\n\nOpenzeppelin reference-\n\nRefer to https://blog.openzeppelin.com/secure-smart-contract-guidelines-the-dangers-of-price-oracles/ for more information regarding potential risks to account for when relying on external price feed providers.\n\n## Tool used\nManual Review\n\n## Recommendation\nSurround the call to latestAnswer() with try/catch instead of calling it directly. In a scenario where the call reverts, the catch block can be used to call a fallback oracle or handle the error in any other suitable way.\n\nNOTE:\nlatestAnswer() is deprecated and it is already recommended to use latestRoundData() instead of latestAnswer(). However, Please note that this issue is also applicable to  latestAnswer() as well as latestRoundData().\n","decidedSeverity":"medium","decidedDuplication":"Unhandled chainlink revert would lock price oracle access"},{"file":"250.md","watson":{"name":"jprod15","days":31,"is_team":false,"payout":744.74,"score":13.8198723654,"senior":false},"severity":"medium","title":"The transfer fails if the token does not comply with the ERC-20 standard.","markdown":"jprod15\n\nmedium\n\n# The transfer fails if the token does not comply with the ERC-20 standard.\n\n## Summary\nTokens like USDT don’t work because they don’t comply with the ERC-20 standard and they don’t return true or false.\n## Vulnerability Detail\nTokens like USDT don’t work because they don’t comply with the ERC-20 standard and they don’t return true or false.return true o false\n## Impact\ntrasnfer will revert \n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/lib/Invoke.sol#L75\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/lib/Invoke.sol#L54\n## Tool used\n\nManual Review\n\n## Recommendation\nuse safe from openzepelling ","decidedSeverity":"false","decidedDuplication":"The transfer fails if the token does not comply with the ERC-20 standard."},{"file":"251.md","watson":{"name":"0x52","days":191,"is_team":false,"payout":418040.47,"score":142.1939095937,"senior":true},"severity":"high","title":"eMode implementation is completely broken","markdown":"0x52\n\nhigh\n\n# eMode implementation is completely broken\n\n## Summary\n\nEnabling eMode allows assets of the same class to be borrowed at much higher a much higher LTV. The issue is that the current implementation makes the incorrect calls to the Aave V3 pool making so that the pool can never take advantage of this higher LTV.\n\n## Vulnerability Detail\n\n[AaveLeverageStrategyExtension.sol#L1095-L1109](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1095-L1109)\n\n    function _calculateMaxBorrowCollateral(ActionInfo memory _actionInfo, bool _isLever) internal view returns(uint256) {\n        \n        // Retrieve collateral factor and liquidation threshold for the collateral asset in precise units (1e16 = 1%)\n        ( , uint256 maxLtvRaw, uint256 liquidationThresholdRaw, , , , , , ,) = strategy.aaveProtocolDataProvider.getReserveConfigurationData(address(strategy.collateralAsset));\n\n        // Normalize LTV and liquidation threshold to precise units. LTV is measured in 4 decimals in Aave which is why we must multiply by 1e14\n        // for example ETH has an LTV value of 8000 which represents 80%\n        if (_isLever) {\n            uint256 netBorrowLimit = _actionInfo.collateralValue\n                .preciseMul(maxLtvRaw.mul(10 ** 14))\n                .preciseMul(PreciseUnitMath.preciseUnit().sub(execution.unutilizedLeveragePercentage));\n\n            return netBorrowLimit\n                .sub(_actionInfo.borrowValue)\n                .preciseDiv(_actionInfo.collateralPrice);\n\nWhen calculating the max borrow/repay allowed, the contract uses the getReserveConfigurationData subcall to the pool. \n\n[AaveProtocolDataProvider.sol#L77-L100](https://github.com/aave/aave-v3-core/blob/29ff9b9f89af7cd8255231bc5faf26c3ce0fb7ce/contracts/misc/AaveProtocolDataProvider.sol#L77-L100)\n\n    function getReserveConfigurationData(\n      address asset\n    )\n      external\n      view\n      override\n      returns (\n          ...\n      )\n    {\n      DataTypes.ReserveConfigurationMap memory configuration = IPool(ADDRESSES_PROVIDER.getPool())\n        .getConfiguration(asset);\n  \n      (ltv, liquidationThreshold, liquidationBonus, decimals, reserveFactor, ) = configuration\n        .getParams();\n\nThe issue with using getReserveConfigurationData is that it always returns the default settings of the pool. It never returns the adjusted eMode settings. This means that no matter the eMode status of the set token, it will never be able to borrow to that limit due to calling the incorrect function.\n\nIt is also worth considering that the set token as well as other integrated modules configurations/settings would assume this higher LTV. Due to this mismatch, the set token would almost guaranteed be misconfigured which would lead to highly dangerous/erratic behavior from both the set and it's integrated modules. Due to this I believe that a high severity is appropriate.\n\n## Impact\n\nUsage of eMode, a core function of the contracts, is completely unusable causing erratic/dangerous behavior \n\n## Code Snippet\n\n[AaveLeverageStrategyExtension.sol#L1095-L1109](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1095-L1109)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nPull the adjusted eMode settings rather than the base pool settings","decidedSeverity":"high","decidedDuplication":"eMode implementation is completely broken"},{"file":"252.md","watson":{"name":"jprod15","days":31,"is_team":false,"payout":744.74,"score":13.8198723654,"senior":false},"severity":"medium","title":"Griefing attacks are possible with ERC-777 tokens.","markdown":"jprod15\n\nmedium\n\n# Griefing attacks are possible with ERC-777 tokens.\n\n## Summary\nSmart contracts can take control of transactions with ERC-777 tokens when they are transferred, this allow behaviors that could damaged the flow of transactions  \n## Vulnerability Detail\nwhen the function  strictInvokeTransfer is called and the tokens is an erc777 \n\n         Invoke.invokeTransfer(_setToken, _token, _to, _quantity);//@audit invokeTransfer \n\nthis line transfers the token and thus allows taking control of the transaction flow to the address “_to”.\n\n    function invokeTransfer(\n        ISetToken _setToken,\n        address _token,\n        address _to,\n        uint256 _quantity\n    )\n        internal\n    {\n        if (_quantity > 0) {\n            bytes memory callData = abi.encodeWithSignature(\"transfer(address,uint256)\", _to, _quantity);\n            _setToken.invoke(_token, 0, callData);\n        }\n    }\nThe issue is that the require  statement in strictInvokeTransfer checks if newBalance is equal to existingBalance minus _quantity. This allows the address _to. can revert the function by transferring tokens to _setToken in the middle of the transaction.\n\n           require(\n                newBalance == existingBalance.sub(_quantity),\n                \"Invalid post transfer balance\"\n            );\n\n\n\n## Impact\nGriefing attacks can revert transactions \n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/lib/Invoke.sol#L89-L112\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/lib/Invoke.sol#L101\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/lib/Invoke.sol#L107-L110\n\n         \n## Tool used\n\nManual Review\n\n## Recommendation\nchange the logic the require ","decidedSeverity":"false","decidedDuplication":"Griefing attacks are possible with ERC-777 tokens."},{"file":"253.md","watson":{"name":"jprod15","days":31,"is_team":false,"payout":744.74,"score":13.8198723654,"senior":false},"severity":"high","title":"many enabledAssets could breack protocol due that can reach block gas  limit","markdown":"jprod15\n\nhigh\n\n# many enabledAssets could breack protocol due that can reach block gas  limit\n\n## Summary\nenabledAssets  is  iterate in a for loop and  many functions of enabledAssets  is  iterate in a for loop in many functions of AaveV3LeverageModule this can break the protocol if many enabledAssets  are put in this array\n## Vulnerability Detail\nThe function removeStorage iterates over the array enabledAssets  in a for loop. This function deletes an index from the array enabledAssets. However, it could also revert and make it impossible to delete an index from the array. \n\n    function indexOf(string[] memory A, string memory a) internal pure returns \n     (uint256, bool) {\n        uint256 length = A.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (keccak256(bytes(A[i])) == keccak256(bytes(a))) {\n                return (i, true);\n            }\n        }\n        return (uint256(-1), false);\n    }\n\n    /**\n     * @param A The input array to search\n     * @param a The string to remove\n     */\n    function removeStorage(string[] storage A, string memory a)\n        internal\n    {\n        (uint256 index, bool isIn) = indexOf(A, a);\n        if (!isIn) {\n            revert(\"String not in array.\");\n        } else {\n            uint256 lastIndex = A.length - 1; // If the array would be empty, the previous line would throw, so no underflow here\n            if (index != lastIndex) { A[index] = A[lastIndex]; }\n            A.pop();\n        }\n    }\n## Impact\nthis can break entire protocol \n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L443-L444\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L607-L609\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L520-L521\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/lib/StringArrayUtils.sol#L35-L60\n## Tool used\n\nManual Review\n\n## Recommendation\navoid foor loops ","decidedSeverity":"false","decidedDuplication":"many enabledAssets could breack protocol due that can reach block gas  limit"},{"file":"254.md","watson":{"name":"0x52","days":191,"is_team":false,"payout":418040.47,"score":142.1939095937,"senior":true},"severity":"high","title":"_calculateMaxBorrowCollateral calculates repay incorrectly and can lead to set token liquidation","markdown":"0x52\n\nhigh\n\n# _calculateMaxBorrowCollateral calculates repay incorrectly and can lead to set token liquidation\n\n## Summary\n\nWhen calculating the amount to repay, `_calculateMaxBorrowCollateral` incorrectly applies `unutilizedLeveragePercentage` when calculating `netRepayLimit`. The result is that if the `borrowValue` ever exceeds `liquidationThreshold * (1 - unutilizedLeveragPercentage)` then all attempts to repay will revert. \n\n## Vulnerability Detail\n\n[AaveLeverageStrategyExtension.sol#L1110-L1118](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1110-L1118)\n\n        } else {\n            uint256 netRepayLimit = _actionInfo.collateralValue\n                .preciseMul(liquidationThresholdRaw.mul(10 ** 14))\n                .preciseMul(PreciseUnitMath.preciseUnit().sub(execution.unutilizedLeveragePercentage));\n\n            return _actionInfo.collateralBalance\n                .preciseMul(netRepayLimit.sub(_actionInfo.borrowValue))\n                .preciseDiv(netRepayLimit);\n        }\n\nWhen calculating `netRepayLimit`, `_calculateMaxBorrowCollateral` uses the `liquidationThreshold` adjusted by `unutilizedLeveragePercentage`. It then subtracts the borrow value from this limit. This is problematic because if the current `borrowValue` of the set token exceeds `liquidationThreshold * (1 - unutilizedLeveragPercentage)` then this line will revert making it impossible to make any kind of repayment. Once no repayment is possible the set token can't rebalance and will be liquidated.\n\n## Impact\n\nOnce the leverage exceeds a certain point the set token can no longer rebalance\n\n## Code Snippet\n\n[AaveLeverageStrategyExtension.sol#L1110-L1118](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1110-L1118)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nDon't adjust the max value by `unutilizedLeveragPercentage`","decidedSeverity":"high","decidedDuplication":"_calculateMaxBorrowCollateral calculates repay incorrectly and can lead to set token liquidation"},{"file":"255.md","watson":{"name":"0x52","days":191,"is_team":false,"payout":418040.47,"score":142.1939095937,"senior":true},"severity":"high","title":"_calculateMaxBorrowCollateral will return repayment values that are not serviceable at higher LTVs","markdown":"0x52\n\nhigh\n\n# _calculateMaxBorrowCollateral will return repayment values that are not serviceable at higher LTVs\n\n## Summary\n\n The methodology for repaying debt in conjunction with how _calculateMaxBorrowCollateral can result in repayment values that are not serviceable leading to repayment attempts reverting and eventually leading to set token liquidation. \n\n## Vulnerability Detail\n\n[AaveV3LeverageModule.sol#L338-L346](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L338-L346)\n\n        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);\n\n        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);\n\n        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);\n\nWhen a set token is deleveraging, it takes the following steps:\n\n    withdraw > swap > repay\n\nThe fundamental issue is that in order to withdraw it must have enough collateral to cover it's current debt or else the withdrawal will revert. This directly conflicts with the methodology used to rebalance the leverage. \n\n[AaveLeverageStrategyExtension.sol#L1111-L1113](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1111-L1113)\n\n            uint256 netRepayLimit = _actionInfo.collateralValue\n                .preciseMul(liquidationThresholdRaw.mul(10 ** 14))\n                .preciseMul(PreciseUnitMath.preciseUnit().sub(execution.unutilizedLeveragePercentage));\n\nWhen calculating the repay it uses the liquidation threshold rather than the LTV. This causes it to potentially attempt rebalances that are completely unserviceable. Let's take LINK as an example. It has the following risk parameters:\n\n    Max LTV - 50%\n    Liquidation Threshold - 65%\n\nAssume that the strategy is a leveraged long on LINK borrowing USDT with a target LTV of 40% and 10% unutilizedLeverage. This would allows the contract to return a rebalance up to 58.5% (0.9 * 65%), which could be problematic in the following scenario: The current LTV is 45% and a sudden price movement pushes the LTV to 48%. A rebalance is triggered attempting to push the LTV back to 45%, rebalancing 3% of the LINK. When attempting to withdraw the call will revert because after the withdrawal, the LTV would be 51%, higher than the max of 50%.\n\nThis creates a trigger point after which it is impossible for the set token to recover even though it has plenty of assets to fully recover itself.\n\n## Impact\n\nError in max rebalance calculation causes extension locking that leads to set token liquidation \n\n## Code Snippet\n\n[AaveV3LeverageModule.sol#L338-L346](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L338-L346)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nI would recommend repaying via a flashloan rather than the current method:\n\n    flashloan > swap > repay > withdraw > repay flashloan","decidedSeverity":"high","decidedDuplication":"_calculateMaxBorrowCollateral will return repayment values that are not serviceable at higher LTVs"},{"file":"256.md","watson":{"name":"0x52","days":191,"is_team":false,"payout":418040.47,"score":142.1939095937,"senior":true},"severity":"high","title":"AaveV3LeverageModule component hooks contain broken logic that will result in dangerous borrowing/repaying","markdown":"0x52\n\nhigh\n\n# AaveV3LeverageModule component hooks contain broken logic that will result in dangerous borrowing/repaying\n\n## Summary\n\nWhen issuing or redeeming a set that deals with debt carrying instruments, the DebtIssuanceModuleV2 is expected to be used. This module contains call to component hooks in all of the modules associated with the set token. The hooks called within AaveV3LeverageModule are dangerous and will result in severe damage to the set.\n\n## Vulnerability Detail\n\n[DebtIssuanceModule.sol#L686-L696](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModule.sol#L686-L696)\n\n        address[] memory externalPositionModules = _setToken.getExternalPositionModules(address(_component));\n        uint256 modulesLength = externalPositionModules.length;\n        if (_isIssue) {\n            for (uint256 i = 0; i < modulesLength; i++) {\n                IModuleIssuanceHook(externalPositionModules[i]).componentIssueHook(_setToken, _setTokenQuantity, _component, _isEquity);\n            }\n        } else {\n            for (uint256 i = 0; i < modulesLength; i++) {\n                IModuleIssuanceHook(externalPositionModules[i]).componentRedeemHook(_setToken, _setTokenQuantity, _component, _isEquity);\n            }\n        }\n\nWhen issuing and redeeming set tokens DebtIssuanceModuleV2 calls component hooks to adjust debt and equity positions. The problem is that the hooks in AaveV3LeverageModule are broken and perform incomplete and dangerous actions.\n\n[AaveV3LeverageModule.sol#L786-L788](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L786-L788)\n\n    function componentIssueHook(ISetToken _setToken, uint256 _setTokenQuantity, IERC20 _component, bool _isEquity) external override onlyModule(_setToken) {\n        // Check hook not being called for an equity position. If hook is called with equity position and outstanding borrow position\n        // exists the loan would be taken out twice potentially leading to liquidation\n        if (!_isEquity) {\n            int256 componentDebt = _setToken.getExternalPositionRealUnit(address(_component), address(this));\n\n            require(componentDebt < 0, \"CMBN\");\n\n            uint256 notionalDebt = componentDebt.mul(-1).toUint256().preciseMul(_setTokenQuantity);\n            _borrowForHook(_setToken, _component, notionalDebt);\n        }\n    }\n\n    function _borrowForHook(ISetToken _setToken, IERC20 _asset, uint256 _notionalQuantity) internal {\n        _borrow(_setToken, IPool(lendingPoolAddressesProvider.getPool()), _asset, _notionalQuantity);\n    }\n\nWe see above that when set tokens are issued, the module borrows tokens. The issue is that these tokens are not utilized in any way leading to borrowed tokens that remain in the contract without any use. This creates excess debt that would lead to the set token being liquidate and suffering a large loss.\n\n## Impact\n\nAaveV3LeverageModule component hooks will result in broken borrowing that will cause set token to be liquidated\n\n## Code Snippet\n\n[AaveV3LeverageModule.sol#L786-L788](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L786-L788)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRework issuance and redemption hooks to leverage and deleverage appropriately","decidedSeverity":"high","decidedDuplication":"AaveV3LeverageModule component hooks contain broken logic that will result in dangerous borrowing/repaying"},{"file":"257.md","watson":{"name":"bulej93","days":26,"is_team":false,"payout":118.96,"score":3.2133267867,"senior":false},"severity":"high","title":"No way to withdraw ETH","markdown":"bulej93\n\nhigh\n\n# No way to withdraw ETH\n\n## Summary\nthere is no mechaminism to withdraw any eth sent to the contract\n## Vulnerability Detail\nin `setToken.sol` there is a receive function that accepts any eth sent to the smart contract, however there is no  way that you can actually withdraw the eth.\n## Impact\neth is stuck inside the contract forever\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/SetToken.sol#L536\n## Tool used\n\nManual Review\n\n## Recommendation\nhave a withdraw function","decidedSeverity":"false","decidedDuplication":"No way to withdraw ETH"},{"file":"258.md","watson":{"name":"0x52","days":191,"is_team":false,"payout":418040.47,"score":142.1939095937,"senior":true},"severity":"medium","title":"Optimism and Arbitrum use an L2 optimized version of Pool.sol making AaveV3.sol completely incompatible","markdown":"0x52\n\nmedium\n\n# Optimism and Arbitrum use an L2 optimized version of Pool.sol making AaveV3.sol completely incompatible\n\n## Summary\n\nThe OP and ARB implementations of AaveV3 use an [L2 optimized pool](https://docs.aave.com/developers/getting-started/l2-optimization/l2pool) contract that has completely different signatures for a majority of user facing functions such as repay, withdraw and borrow\n\n## Vulnerability Detail\n\n[L2Pool.sol#L50-L65](https://github.com/aave/aave-v3-core/blob/29ff9b9f89af7cd8255231bc5faf26c3ce0fb7ce/contracts/protocol/pool/L2Pool.sol#L50-L65)\n\n    function borrow(bytes32 args) external override {\n      (address asset, uint256 amount, uint256 interestRateMode, uint16 referralCode) = CalldataLogic\n        .decodeBorrowParams(_reservesList, args);\n  \n      borrow(asset, amount, interestRateMode, referralCode, msg.sender);\n    }\n  \n    function repay(bytes32 args) external override returns (uint256) {\n      (address asset, uint256 amount, uint256 interestRateMode) = CalldataLogic.decodeRepayParams(\n        _reservesList,\n        args\n      );\n  \n      return repay(asset, amount, interestRateMode, msg.sender);\n    }\n\nAbove we see the repay and borrow functions of the L2Pool.sol contract. These selectors are different than their L1 counterparts.\n\n[AaveV3.sol#L269-L289](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/integration/lib/AaveV3.sol#L269-L289)\n\n    function getRepayCalldata(\n        IPool _lendingPool,\n        address _asset, \n        uint256 _amountNotional,\n        uint256 _interestRateMode,        \n        address _onBehalfOf\n    )\n        public\n        pure\n        returns (address, uint256, bytes memory)\n    {\n        bytes memory callData = abi.encodeWithSignature(\n            \"repay(address,uint256,uint256,address)\", \n            _asset, \n            _amountNotional, \n            _interestRateMode,            \n            _onBehalfOf\n        );\n        \n        return (address(_lendingPool), 0, callData);\n    }\n\nThis completely breaks all compatibility with OP and ARB due to calling a selector that is incorrect.\n\n## Impact\n\nAll AaveV3 integrations are completely broken on L2s\n\n## Code Snippet\n\n[AaveV3.sol#L269-L289](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/integration/lib/AaveV3.sol#L269-L289)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nTo work with L2s like ARB and OP, AaveV3 be modified to pack data similar to [L2Encoder](https://docs.aave.com/developers/getting-started/l2-optimization/l2encoder) provided.","decidedSeverity":"medium","decidedDuplication":"Optimism and Arbitrum use an L2 optimized version of Pool.sol making AaveV3.sol completely incompatible"},{"file":"259.md","watson":{"name":"tsueti_","days":3,"is_team":false,"payout":1.14,"score":0.1133035547,"senior":false},"severity":"medium","title":"_safeMint() SHOULD BE USED RATHER THAN _mint() WHEREVER POSSIBLE","markdown":"tsueti_\n\nmedium\n\n# _safeMint() SHOULD BE USED RATHER THAN _mint() WHEREVER POSSIBLE\n\n## Summary\n\n_mint() is [discouraged](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/d4d8d2ed9798cc3383912a23b5e8d5cb602f7d4b/contracts/token/ERC721/ERC721.sol#L271) in favor of _safeMint() which ensures that the recipient is either an EOA or implements IERC721Receiver. [Both OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/d4d8d2ed9798cc3383912a23b5e8d5cb602f7d4b/contracts/token/ERC721/ERC721.sol#L238-L250) and [solmate](https://github.com/Rari-Capital/solmate/blob/4eaf6b68202e36f67cab379768ac6be304c8ebde/src/tokens/ERC721.sol#L180) have versions of this function\n\n## Vulnerability Detail\n```solidity\n    function mint(address _account, uint256 _quantity) external onlyModule whenLockedOnlyLocker {\n        _mint(_account, _quantity);\n    }\n```\n\n## Impact\n\nPossible loss of funds due to the use of _mint\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/SetToken.sol#L329\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse _safeMint() where possible \n","decidedSeverity":"false","decidedDuplication":"_safeMint() SHOULD BE USED RATHER THAN _mint() WHEREVER POSSIBLE"},{"file":"260.md","watson":{"name":"Satyam"},"severity":"medium","title":"locker get initialized instead of checking","markdown":"Satyam\n\nmedium\n\n# locker get initialized instead of checking\n\n## Summay\n SetToken.lock function is only called when  modulestate for msg.sender is set to INITIALIZED and when it is locked i.e; only the locker (a module) can call, now in the very next line L345 it is initializing the msg.sender to locker variable, which is not suppose to be the case in this since from the comment it says ```only the locker can call privileged functions``` i.e, it is checking that if msg.sender is locker or not, than it marked isLocked = true , As we can see similar check under unlock function, which is checking if locker is msg.sender or not than it proceeds to the following operations:\n```solidity\nfunction unlock() external onlyModule {\n        require(isLocked, \"Must be locked\");\n        require(locker == msg.sender, \"Must be locker\");\n        delete locker;\n        isLocked = false;\n    }\n```\nand under lock function it is doing like: \n``` solidity\nrequire(!isLocked, \"Must not be locked\");\n        locker = msg.sender\n```\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/SetToken.sol#L343\n\n## Impact\nwhenever a user with INITIALIZED module called this function it sets locker to msg.sender instead of checking if msg.sender is locker or not! which can break the functionality of lock function the intended cause for which it was designed!!\n\n## Recommendation\nUse  \n```solidity \nrequire(locker == msg.sender, \"Must be locker\");\n``` \ninstead of directly initializing it!\n\n","decidedSeverity":"false","decidedDuplication":"locker get initialized instead of checking"},{"file":"261.md","watson":{"name":"Satyam"},"severity":"high","title":"removePendingModule not completely removing module","markdown":"Satyam\n\nhigh\n\n# removePendingModule not completely removing module\n\n## Summary\nIn SetToken.removeModule it is removing all the PENDING module from the SetToken contract, which should be called by onlyOwner it does like: first it checks if is unlocked or not then it in 2nd condition it is checking if ``` _module ``` is set to ``` INITIALIZED ModuleState ``` if these both require conditions are true then it calls removeModule function on ``` _module ``` address after that it sets ``` _module ``` address to ``` NONE ModuleState ``` then it calls removerStorage function to completely remove this ``` _module ``` from the storage !! \n\n## Vulnerability Detail\nNow the similar checks and conditions are performed under SetToken.removePendingModule but instead of checking   ``` _module ``` is set to ``` INITIALIZED ModuleState ``` it checks  ``` _module ``` is set to ``` PENDING ModuleState ``` after which it sets ``` _module ``` to ``` NONE state ``` in which the SetToken will not be able to perform any actions that require a module, and now instead of calling removeStorage to completely remove the _module after marking it to ``` NONE ``` it emits an event, due to which ``` _module ``` get remain in the storage and if a _module still remains in the contract after setting its state to NONE, then the manager could potentially misuse it by accessing the module's data or functions directly. This could allow the manager to steal tokens from the SetToken or miss-using its operations.\n\n```\n function removePendingModule(address _module) external onlyManager {\n        require(!isLocked, \"Only when unlocked\");\n        require(moduleStates[_module] == ISetToken.ModuleState.PENDING, \"Module must be pending\");\n\n        moduleStates[_module] = ISetToken.ModuleState.NONE;\n\n        emit PendingModuleRemoved(_module);\n    }\n```\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/SetToken.sol#L392\n\n## Recommendation\nmust include a ``` modules.removeStorage(_module); ``` to completely remove it.\n","decidedSeverity":"false","decidedDuplication":"removePendingModule not completely removing module"},{"file":"262.md","watson":{"name":"ShadowForce","days":56,"is_team":true,"payout":16317.49,"score":22.9570325496,"senior":false},"severity":"medium","title":"no validation to ensure the arbitrum sequencer is down","markdown":"ShadowForce\n\nmedium\n\n# no validation to ensure the arbitrum sequencer is down\n\n## Summary\nThere is no validation to ensure sequencer is down\n## Vulnerability Detail\n```solidity\n int256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\n        rebalanceInfo.collateralPrice = rawCollateralPrice.toUint256().mul(10 ** strategy.collateralDecimalAdjustment);\n        int256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer();\n        rebalanceInfo.borrowPrice = rawBorrowPrice.toUint256().mul(10 ** strategy.borrowDecimalAdjustment);\n```\n\nUsing Chainlink in L2 chains such as Arbitrum requires to check if the sequencer is down to avoid prices from looking like they are fresh although they are not.\n\nThe bug could be leveraged by malicious actors to take advantage of the sequencer downtime.\n## Impact\nwhen sequencer is down, stale price is used for oracle and the borrow value and collateral value is calculated and the protocol can be forced to rebalance in a loss position\n## Code Snippet\nhttps://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/adapters/AaveLeverageStrategyExtension.sol#L889-L907\n## Tool used\n\nManual Review\n\n## Recommendation\nrecommend to add checks to ensure the sequencer is not down.","decidedSeverity":"medium","decidedDuplication":"Missing checks for whether Arbitrum Sequencer is active"},{"file":"263.md","watson":{"name":"ShadowForce","days":56,"is_team":true,"payout":16317.49,"score":22.9570325496,"senior":false},"severity":"medium","title":"Poor validation of chainlink price timestamp","markdown":"ShadowForce\n\nmedium\n\n# Poor validation of chainlink price timestamp\n\n## Summary\npoor validation of chainlink price timestamp\n## Vulnerability Detail\nThere is not sufficient check that ensures the timestamp accepted from a chainlink price feed is up to date. This will cause old prices to be used instead of the current price. This could be result in improper rebalance and losses to a users account.\n```solidity\n    function _createActionInfo() internal view returns(ActionInfo memory) {\n        ActionInfo memory rebalanceInfo;\n\n        // Calculate prices from chainlink. Chainlink returns prices with 8 decimal places, but we need 36 - underlyingDecimals decimal places.\n        // This is so that when the underlying amount is multiplied by the received price, the collateral valuation is normalized to 36 decimals. \n        // To perform this adjustment, we multiply by 10^(36 - 8 - underlyingDecimals)\n        int256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\n        rebalanceInfo.collateralPrice = rawCollateralPrice.toUint256().mul(10 ** strategy.collateralDecimalAdjustment);\n        int256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer();\n        rebalanceInfo.borrowPrice = rawBorrowPrice.toUint256().mul(10 ** strategy.borrowDecimalAdjustment);\n\n        rebalanceInfo.collateralBalance = strategy.targetCollateralAToken.balanceOf(address(strategy.setToken));\n        rebalanceInfo.borrowBalance = strategy.targetBorrowDebtToken.balanceOf(address(strategy.setToken));\n        rebalanceInfo.collateralValue = rebalanceInfo.collateralPrice.preciseMul(rebalanceInfo.collateralBalance);\n        rebalanceInfo.borrowValue = rebalanceInfo.borrowPrice.preciseMul(rebalanceInfo.borrowBalance);\n        rebalanceInfo.setTotalSupply = strategy.setToken.totalSupply();\n\n        return rebalanceInfo;\n    }\n```\n## Impact\nstale price is used for oracle and the borrow value and collateral value is calculated and the protocol can be forced to rebalance in a loss position\n## Code Snippet\nhttps://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/adapters/AaveLeverageStrategyExtension.sol#L889-L907\n## Tool used\n\nManual Review\n\n## Recommendation\nwe recommend to validate chainlink price timestamps to ensure prices are up to date.","decidedSeverity":"medium","decidedDuplication":"Chainlink's latestRoundData return stale or incorrect result"},{"file":"264.md","watson":{"name":"ShadowForce","days":56,"is_team":true,"payout":16317.49,"score":22.9570325496,"senior":false},"severity":"medium","title":"Chainlink price can return a negative number","markdown":"ShadowForce\n\nmedium\n\n# Chainlink price can return a negative number\n\n## Summary\nChainlink price can return a negative number\n## Vulnerability Detail\n```solidity\nint256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\n        rebalanceInfo.collateralPrice = rawCollateralPrice.toUint256().mul(10 ** strategy.collateralDecimalAdjustment);\n        int256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer();\n        rebalanceInfo.borrowPrice = rawBorrowPrice.toUint256().mul(10 ** strategy.borrowDecimalAdjustment);\n```\nin the snippet above there is a call for a chainlink price feed. The problem here is that there is no check to ensure the number returned is negative or not. Therefore a negative price can be returned by the chainlink price feed. A negative price feed is indicative of a malfunctioning price feed. Therefore the tx should revert. Because there is no checks for negative price, the tx will not revert and this is a problem for rebalancing and will cause a loss of funds for many users.\n## Impact\n if the chainlink oracle returns a negative number, that means the oracle is malfunctioning and the transaction should revert, in the current implementation the negative price can be cast to positive integer and used as a price oracle\ntherefore wrong price is used for oracle and the borrow value and collateral value is calculated and the protocol can be forced to rebalance in a loss position.\n## Code Snippet\nhttps://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/adapters/AaveLeverageStrategyExtension.sol#L889-L907\n## Tool used\n\nManual Review\n\n## Recommendation\nensure tx reverts when negative price is provided.","decidedSeverity":"medium","decidedDuplication":"Chainlink's latestRoundData return stale or incorrect result"},{"file":"265.md","watson":{"name":"ShadowForce","days":56,"is_team":true,"payout":16317.49,"score":22.9570325496,"senior":false},"severity":"high","title":"last trade timestamp is not updated","markdown":"ShadowForce\n\nhigh\n\n# last trade timestamp is not updated\n\n## Summary\nlast trade timestamp is never updated\n## Vulnerability Detail\nin AaveLeverageStrategyExtension.sol there is a function\n```solidity\n  function disengage(string memory _exchangeName) external onlyOperator {\n        LeverageInfo memory leverageInfo = _getAndValidateLeveragedInfo(\n            execution.slippageTolerance,\n            exchangeSettings[_exchangeName].twapMaxTradeSize,\n            _exchangeName\n        );\n\n        uint256 newLeverageRatio = PreciseUnitMath.preciseUnit();\n\n        (\n            uint256 chunkRebalanceNotional,\n            uint256 totalRebalanceNotional\n        ) = _calculateChunkRebalanceNotional(leverageInfo, newLeverageRatio, false);\n\n        if (totalRebalanceNotional > chunkRebalanceNotional) {\n            _delever(leverageInfo, chunkRebalanceNotional);\n        } else {\n            _deleverToZeroBorrowBalance(leverageInfo, totalRebalanceNotional);\n        }\n\n        emit Disengaged(\n            leverageInfo.currentLeverageRatio,\n            newLeverageRatio,\n            chunkRebalanceNotional,\n            totalRebalanceNotional\n        );\n    }\n```\nthis function never updates the last trade timestamp, additionally the cooldown period check is ineffective.\n```solditiy\n _updateLastTradeTimestamp(_exchangeName)\n```\nthe snippet above should be included in the function\n## Impact\nbecause the timestamp is not updated correctly, this allows rebalance to be called more frequently than it should in a cooldown period, this breaks an invariant of the protocol.\n## Code Snippet\nhttps://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/adapters/AaveLeverageStrategyExtension.sol#L412-L438\n## Tool used\n\nManual Review\n\n## Recommendation\nwe recommend to update last trade timestamp in the disengage function.","decidedSeverity":"medium","decidedDuplication":"The trade transactions lack of expiration timestamp check"},{"file":"266.md","watson":{"name":"ShadowForce","days":56,"is_team":true,"payout":16317.49,"score":22.9570325496,"senior":false},"severity":"high","title":"users lose out on liquidity mining rewards","markdown":"ShadowForce\n\nhigh\n\n# users lose out on liquidity mining rewards\n\n## Summary\nusers will lose out on AAVE liquidity mining rewards.\n## Vulnerability Detail\nthere is a high likelyhood that AAVE v3 will enable mining rewards. This is a problem because currently the protocol has no way for a user to claim said rewards from AAVE v3.\nwe can observe below a tweet from aave stating they enabled liquidity mining on optimism and AAVE can launch more liquidity mining campagin\nhttps://twitter.com/AaveAave/status/1555230478394966018?lang=en\nthese docs also detail how to implement said functions for reward claiming\nhttps://docs.aave.com/developers/whats-new/multiple-rewards-and-claim\n## Impact\nusers will not be able to claim rewards on AAVE when they should. This is a clear loss of reward and funds for the individual.\n## Code Snippet\nhttps://docs.aave.com/developers/whats-new/multiple-rewards-and-claim\nhttps://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/adapters/AaveLeverageStrategyExtension.sol#L889\n## Tool used\n\nManual Review\n\n## Recommendation\nwe recommend the protocol adds a  function that allows user to claim rewards from liquidity ","decidedSeverity":"false","decidedDuplication":"users lose out on liquidity mining rewards"},{"file":"267.md","watson":{"name":"ShadowForce","days":56,"is_team":true,"payout":16317.49,"score":22.9570325496,"senior":false},"severity":"medium","title":"aave borrow and supply caps can lead to functions reverting","markdown":"ShadowForce\n\nmedium\n\n# aave borrow and supply caps can lead to functions reverting\n\n## Summary\naave borrow and supply caps can be breached\n## Vulnerability Detail\nhttps://docs.aave.com/developers/whats-new/supply-borrow-caps\nin the aave protocol, some assets have borrow or supply caps. Borrowing or supplying beyond this cap is not possible.\nthis is a problem in this protocol. \n```solidity\n    function lever(\n        ISetToken _setToken,\n        IERC20 _borrowAsset,\n        IERC20 _collateralAsset,\n        uint256 _borrowQuantityUnits,\n        uint256 _minReceiveQuantityUnits,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from\n        // collateral asset\n        ActionInfo memory leverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            _borrowQuantityUnits,\n            _minReceiveQuantityUnits,\n            _tradeAdapterName,\n            true\n        );\n\n        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);\n\n        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);\n\n        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);\n\n        _updateLeverPositions(leverInfo, _borrowAsset);\n\n        emit LeverageIncreased(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            leverInfo.exchangeAdapter,\n            leverInfo.notionalSendQuantity,\n            postTradeCollateralQuantity,\n            protocolFee\n        );\n    }\n```\nin the snippet above, the `lever` functions works by first borrowing an asset from aave, this asset is then swapped for the target token and later sent to a pool in this protocol. The problem arises when the AAVE borrow cap has been reached. Because the lever function must first borrow, if the AAVE borrow cap has been, the tx will revert and user will not be able to increase leverage in his position,\n\ninversely this is also present in the `delever` although this deals with supply cap instead of borrow cap.\nLet us assume that the supply cap is reached, delever function will not execute and revert because AAVE cannot accept more tokens once the supply cap is reached\n## Impact\nBecause AAVE utilizes supply and borrow caps, when the supply cap is reached this will cause delever to revert. When borrow cap is reached, this will cause lever to revert. A user who wants to delever to avoid a liquidation will not be able to and essentially forced into a liquidation. This is a complete loss of funds for the user.\n## Code Snippet\nhttps://github.com/IndexCoop/index-protocol/blob/86be7ee76d9a7e4f7e93acfc533216ebef791c89/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L252\n## Tool used\n\nManual Review\n\n## Recommendation\nwe recommend logic is added that is not reliant on AAVE borrow and supply caps.\n","decidedSeverity":"false","decidedDuplication":"aave borrow and supply caps can lead to functions reverting"},{"file":"268.md","watson":{"name":"ShadowForce","days":56,"is_team":true,"payout":16317.49,"score":22.9570325496,"senior":false},"severity":"medium","title":"failure to handle erc 20 transfers","markdown":"ShadowForce\n\nmedium\n\n# failure to handle erc 20 transfers\n\n\n## Summary\nerc 20 transfers are not handled\n## Vulnerability Detail\n```solidity\n    function _resolveEquityPositions(\n        ISetToken _setToken,\n        uint256 _quantity,\n        address _to,\n        bool _isIssue,\n        address[] memory _components,\n        uint256[] memory _componentEquityQuantities,\n        uint256 _initialSetSupply,\n        uint256 _finalSetSupply\n    )\n        internal\n    {\n        for (uint256 i = 0; i < _components.length; i++) {\n            address component = _components[i];\n            uint256 componentQuantity = _componentEquityQuantities[i];\n            if (componentQuantity > 0) {\n                if (_isIssue) {\n                    // Call SafeERC20#safeTransferFrom instead of ExplicitERC20#transferFrom\n                    SafeERC20.safeTransferFrom(\n                        IERC20(component),\n                        msg.sender,\n                        address(_setToken),\n                        componentQuantity\n                    );\n\n                    IssuanceValidationUtils.validateCollateralizationPostTransferInPreHook(_setToken, component, _initialSetSupply, componentQuantity);\n\n                    _executeExternalPositionHooks(_setToken, _quantity, IERC20(component), true, true);\n                } else {\n                    _executeExternalPositionHooks(_setToken, _quantity, IERC20(component), false, true);\n\n                    // Call Invoke#invokeTransfer instead of Invoke#strictInvokeTransfer\n                    _setToken.invokeTransfer(component, _to, componentQuantity);\n\n                    IssuanceValidationUtils.validateCollateralizationPostTransferOut(_setToken, component, _finalSetSupply);\n                }\n            }\n        }\n    }\n```\nin the snippet above we see the function `_resolveEquityPositions` the problem here is that the function does not properly handle erc 20 transfers. This is evident when we take a look at this specific lines of code below.\n```solidity\n_setToken.invokeTransfer(component, _to, componentQuantity);\n```\nin the this snippet we can see the function does never handle the token return value. Therefore the function will not properly handle erc 20 transfers.\n## Impact\nTokens that don't correctly implement the latest EIP20 spec, like USDT, will be unusable in the protocol as they revert the transaction because of the missing return value.\n## Code Snippet\nhttps://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/external/contracts/set/DebtIssuanceModuleV2.sol#L251-L289\n## Tool used\n\nManual Review\n\n## Recommendation\nwe recommend the protocol add logic to properly handle erc 20 transfers.","decidedSeverity":"medium","decidedDuplication":"AmmModule will not work with usdt"},{"file":"269.md","watson":{"name":"ShadowForce","days":56,"is_team":true,"payout":16317.49,"score":22.9570325496,"senior":false},"severity":"medium","title":"soiled assets will lead to a DOS in the lever function","markdown":"ShadowForce\n\nmedium\n\n# soiled assets will lead to a DOS in the lever function\n\n## Summary\nsoiled assets will lead to a DOS in the lever function\n## Vulnerability Detail\nhttps://docs.aave.com/developers/whats-new/siloed-borrowing\n> This feature allow assets with potentially manipulatable oracles (for example illiquid Uni V3 pairs) to be listed on Aave as single borrow asset. This means that if an asset is configured as siloed, it can't be borrowed in a position at the same time as with other assets. This helps mitigating the risk associated with such assets from impacting the overall solvency of the protocol. This condition can be found in the codebase here.\n\nthe quote is from the link above. As we can see an admin from aave can decide if an asset is soiled, and this is a problem because the protocol does not account for this fact.\n\n1. suppose there are three collateral asset,\n2. asset A and asset B and asset C\n3. suddenly asset B is listed as a soiled asset by AAVE admin\n4. all lever function would revert\n\n```solidity\nfunction lever(\n        ISetToken _setToken,\n        IERC20 _borrowAsset,\n        IERC20 _collateralAsset,\n        uint256 _borrowQuantityUnits,\n        uint256 _minReceiveQuantityUnits,\n        string memory _tradeAdapterName, // exchange name\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from \n        // collateral asset\n        ActionInfo memory leverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            _borrowQuantityUnits,\n            _minReceiveQuantityUnits,\n            _tradeAdapterName,\n            true\n        );\n\n        // @audit\n        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);\n\n        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);\n\n        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);\n\n        _updateLeverPositions(leverInfo, _borrowAsset);\n\n        emit LeverageIncreased(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            leverInfo.exchangeAdapter,\n            leverInfo.notionalSendQuantity,\n            postTradeCollateralQuantity,\n            protocolFee\n        );\n    }\n```\nbecause the function `lever` must first borrow, if it has a soiled asset, the function will always revert\n## Impact\nbecause a user has a soiled asset, they cannot call the lever function. Being unable to call this function when market is favorable for user will lose him out on potential gains if he were to have levered up. This is a loss of funds for the user\n## Code Snippet\nhttps://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/external/contracts/set/AaveLeverageModule.sol#L249-L295\n## Tool used\n\nManual Review\n\n## Recommendation\nwe recommend the project account for the potential soiled assets ","decidedSeverity":"false","decidedDuplication":"soiled assets will lead to a DOS in the lever function"},{"file":"270.md","watson":{"name":"ShadowForce","days":56,"is_team":true,"payout":16317.49,"score":22.9570325496,"senior":false},"severity":"high","title":"an underflow can block rebalance","markdown":"ShadowForce\n\nhigh\n\n# an underflow can block rebalance\n\n## Summary\nunderflow can block rebalance\n## Vulnerability Detail\n```solidity\n function _createActionInfo() internal view returns(ActionInfo memory) {\n        ActionInfo memory rebalanceInfo;\n\n        // Calculate prices from chainlink. Chainlink returns prices with 8 decimal places, but we need 36 - underlyingDecimals decimal places.\n        // This is so that when the underlying amount is multiplied by the received price, the collateral valuation is normalized to 36 decimals. \n        // To perform this adjustment, we multiply by 10^(36 - 8 - underlyingDecimals)\n\n        // @audit 8 decimals\n        int256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\n\n        // 8 decimals * 10 ** 28\n        rebalanceInfo.collateralPrice = rawCollateralPrice.toUint256().mul(10 ** strategy.collateralDecimalAdjustment);\n    \n        int256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer();\n\n        // 8 decimals * 10 ** 28\n        rebalanceInfo.borrowPrice = rawBorrowPrice.toUint256().mul(10 ** strategy.borrowDecimalAdjustment);\n\n        // @audit can this be manpulated, the price and total supply and the spot balance of?\n        rebalanceInfo.collateralBalance = strategy.targetCollateralAToken.balanceOf(address(strategy.setToken));\n    \n        rebalanceInfo.borrowBalance = strategy.targetBorrowDebtToken.balanceOf(address(strategy.setToken));\n    \n        // should be 10e18\n        rebalanceInfo.collateralValue = rebalanceInfo.collateralPrice.preciseMul(rebalanceInfo.collateralBalance); //10 ** 36\n     \n        // should be 10e18\n        rebalanceInfo.borrowValue = rebalanceInfo.borrowPrice.preciseMul(rebalanceInfo.borrowBalance);\n    \n        rebalanceInfo.setTotalSupply = strategy.setToken.totalSupply();\n\n        return rebalanceInfo;\n    }\n```\nin the snippet above 2 values are assigned, the rebalanceInfo.collateralValue and  rebalanceInfo.borrowValue.\nthese values are then used in the snippet below.\n```solidity\n /**\n     * Calculate the current leverage ratio given a valuation of the collateral and borrow asset, which is calculated as collateral USD valuation / SetToken USD valuation\n     *\n     * return uint256            Current leverage ratio\n     */\n    function _calculateCurrentLeverageRatio(\n        uint256 _collateralValue,\n        uint256 _borrowValue\n    )\n        internal\n        pure\n        returns(uint256)\n    {\n        // @audit\n        return _collateralValue.preciseDiv(_collateralValue.sub(_borrowValue));\n    }\n``` \nas we can see from the snippet above, there is subtraction of _collateralValue and _borrowValue\n_collateralValue.sub(_borrowValue) can revert in underflow if collaeralValue < borrowValue.\n## Impact\nan underflow in the function ` _calculateCurrentLeverageRatio` can result in tx reverting. The function will not go through or work. This is an important function that integrates with the protocol. \n## Code Snippet\nhttps://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/adapters/AaveLeverageStrategyExtension.sol#L1019-L1028\n## Tool used\n\nManual Review\n\n## Recommendation\nensure logic does not result in underflow so that function does not revert.","decidedSeverity":"false","decidedDuplication":"an underflow can block rebalance"},{"file":"271.md","watson":{"name":"ShadowForce","days":56,"is_team":true,"payout":16317.49,"score":22.9570325496,"senior":false},"severity":"high","title":"rebalance can be manipulated by a malicious user","markdown":"ShadowForce\n\nhigh\n\n# rebalance can be manipulated by a malicious user\n\n## Summary\nrebalance can be manipulated by a malicious user\n## Vulnerability Detail\nto explain how this is possible, let us first look at the snippet below\n```solidity\nfunction _createActionInfo() internal view returns(ActionInfo memory) {\n        ActionInfo memory rebalanceInfo;\n\n        // Calculate prices from chainlink. Chainlink returns prices with 8 decimal places, but we need 36 - underlyingDecimals decimal places.\n        // This is so that when the underlying amount is multiplied by the received price, the collateral valuation is normalized to 36 decimals. \n        // To perform this adjustment, we multiply by 10^(36 - 8 - underlyingDecimals)\n\n        // @audit 8 decimals\n        int256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\n\n        // collateralDecimalAdjustment = 28 - token decimals\n        // if token decimals is 18\n        // 8 decimal * 10 * decimals\n        rebalanceInfo.collateralPrice = rawCollateralPrice.toUint256().mul(10 ** strategy.collateralDecimalAdjustment);\n    \n        int256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer();\n\n        // 8 decimals * 10\n        rebalanceInfo.borrowPrice = rawBorrowPrice.toUint256().mul(10 ** strategy.borrowDecimalAdjustment);\n\n        // @audit can this be manpulated, the price and total supply and the spot balance of?\n        rebalanceInfo.collateralBalance = strategy.targetCollateralAToken.balanceOf(address(strategy.setToken));\n    \n        rebalanceInfo.borrowBalance = strategy.targetBorrowDebtToken.balanceOf(address(strategy.setToken));\n    \n        // should be 10e18\n        rebalanceInfo.collateralValue = rebalanceInfo.collateralPrice.preciseMul(rebalanceInfo.collateralBalance); //10 ** 36\n     \n        // should be 10e18\n        rebalanceInfo.borrowValue = rebalanceInfo.borrowPrice.preciseMul(rebalanceInfo.borrowBalance);\n    \n        rebalanceInfo.setTotalSupply = strategy.setToken.totalSupply();\n\n        return rebalanceInfo;\n    }\n```\nthe function above deals with the rebalance of the protocol. more importantly let us highlight a specific line of code from the snippet above.\n```solidity\nrebalanceInfo.collateralBalance = strategy.targetCollateralAToken.balanceOf(address(strategy.setToken));\n``` \nfrom the snippet above we see that `rebalanceInfo.collateralBalance` is set by balanceOf and total supply. Because the balanceOF and total supply can be manipulated by a malicious user via being a whale or use of flash loan. A malicious user can trigger a rebalance which can result in loss of funds.\n## Impact\nA malicious user can manipulate balanceOf to trigger a rebalance which will a loss of funds for user. And also initiate a rebalance when it should have never happened.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L889\n## Tool used\n\nManual Review\n\n## Recommendation\nrecommend the protocol add logic to ensure the rebalance is not manipulatable ","decidedSeverity":"false","decidedDuplication":"rebalance can be manipulated by a malicious user"},{"file":"272.md","watson":{"name":"ShadowForce","days":56,"is_team":true,"payout":16317.49,"score":22.9570325496,"senior":false},"severity":"medium","title":"use of tx.origin will cause problems with optimism","markdown":"ShadowForce\n\nmedium\n\n# use of tx.origin will cause problems with optimism\n\n## Summary\nthe use of tx.origin is incorrect\n## Vulnerability Detail\nFor `onlyEOA` , `tx.origin` is used to ensure that the caller is from an EOA and not a smart contract.\n\n```solidity\n  /**\n     * Throws if caller is a contract, can be used to stop flash loan and sandwich attacks\n     */\n    modifier onlyEOA() {\n        require(msg.sender == tx.origin, \"Caller must be EOA Address\");\n        _;\n    }\n```\n\nHowever, according to [EIP 3074](https://eips.ethereum.org/EIPS/eip-3074#abstract),\n\nThis EIP introduces two EVM instructions AUTH and AUTHCALL. The first sets a context variable authorized based on an ECDSA signature. The second sends a call as the authorized account. This essentially delegates control of the externally owned account (EOA) to a smart contract.\n\nTherefore, using tx.origin to ensure msg.sender is an EOA will not hold true in the event EIP 3074 goes through.\n## Impact\nUsing modifier `onlyEOA` to ensure calls are made only from EOA will not hold true in the event EIP 3074 goes through.\n## Code Snippet\nhttps://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/lib/BaseExtension.sol#L56-L62\n## Tool used\n\nManual Review\n\n## Recommendation\nRecommend using OpenZepellin's isContract function (https://docs.openzeppelin.com/contracts/2.x/api/utils#Address-isContract-address-). Note that there are edge cases like contract in constructor that can bypass this and hence caution is required when using this.\n```solidity\n  /**\n     * Throws if caller is a contract, can be used to stop flash loan and sandwich attacks\n     */\n    modifier onlyEOA() {\n        require(isContract(msg.sender)) \n        _;\n    }\n```\n","decidedSeverity":"medium","decidedDuplication":"onlyEOA modifier that ensures call is from EOA might not hold true with the eip 3074"},{"file":"273.md","watson":{"name":"seerether"},"severity":"high","title":"Transfer function used instead  of Call function to send ether in transferEtherRewardToCaller","markdown":"seerether\n\nhigh\n\n# Transfer function used instead  of Call function to send ether in transferEtherRewardToCaller\n\n## Summary\nThe transfer function has a gas limit of 2,300 gas, and if the caller is a contract with a fallback function that consumes more than 2,300 gas, the transfer will fail and revert the transaction.\n## Vulnerability Detail\nThis limitation can introduce the risk of denial-of-service (DoS) attacks if an attacker deliberately constructs a fallback function that consumes more gas than the provided limit, thereby preventing the transfer from completing successfully.\n## Impact\nThis can leave the contract in an inconsistent state and prevent the reward from being successfully transferred to the caller leading to loss of fnds\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1221\n## Tool used\nManual Review\n\n## Recommendation \nUse the call function instead of transfer. The call function provides more flexibility and allows specifying a higher gas limit or using a gas stipend to prevent the transfer from failing in scenarios where the caller is a contract with higher gas consumption. \nhttps://github.com/seerether/IndexCoop/blob/f9cc4be568cba23d3cd30612dae77efbd29e083f/indexcoopmitigation11#L4-L6\n\nOr or utilize a more robust mechanism for transferring funds, such as the withdrawal pattern, where the recipient explicitly requests the transfer of funds instead of relying on the contract to automatically transfer them.\nhttps://github.com/seerether/IndexCoop/blob/f9cc4be568cba23d3cd30612dae77efbd29e083f/indexcoopmitigation12#L6-L20C2","decidedSeverity":"false","decidedDuplication":"Transfer function used instead  of Call function to send ether in transferEtherRewardToCaller"},{"file":"274.md","watson":{"name":"caventa","days":102,"is_team":false,"payout":1746.02,"score":3.7299897076,"senior":false},"severity":"high","title":"Accrued fee does not work with high streamingFeePercentage or previous claim was too long","markdown":"caventa\n\nhigh\n\n# Accrued fee does not work with high streamingFeePercentage or previous claim was too long\n\n## Summary\nAccrued fee does not work with high streamingFeePercentage or previous claim was too long\n\n[Note: I mark this as high severity because positionMultiplier is important as it is used to update all the positions in an efficient way]\n\n## Vulnerability Detail\nSee SteamingFeeModule#initialize\n\n```solidity\nrequire(_settings.maxStreamingFeePercentage < PreciseUnitMath.preciseUnit(), \"Max fee must be < 100%.\");\nrequire(_settings.streamingFeePercentage <= _settings.maxStreamingFeePercentage, \"Fee must be <= max.\");\n```\n\nmaxStreamingFeePercentage can be any value that is < 1\nstreamingFeePercentage can be any value < maxStreamingFeePercentage\n        \n\n\nFee is accrued in StreamingFeeModule#accrueFee\n\n```solidity\nfunction accrueFee(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet\n    (_setToken) {\n        uint256 managerFee;\n        uint256 protocolFee;\n\n        if (_streamingFeePercentage(_setToken) > 0) {\n            uint256 inflationFeePercentage = _calculateStreamingFee(_setToken); // @audit\n\n            // Calculate incentiveFee inflation\n            uint256 feeQuantity = _calculateStreamingFeeInflation(_setToken, inflationFeePercentage); // @audit\n\n            // Mint new Sets to manager and protocol\n            (\n                managerFee,\n                protocolFee\n            ) = _mintManagerAndProtocolFee(_setToken, feeQuantity);\n\n            _editPositionMultiplier(_setToken, inflationFeePercentage);\n        }\n\n        feeStates[_setToken].lastStreamingFeeTimestamp = block.timestamp;\n\n        emit FeeActualized(address(_setToken), managerFee, protocolFee);\n    }\n```\n\nInflationFeePercentage is calculated in StreamingFeeModule#_calculateStreamingFee\n\n```solidity\n function _calculateStreamingFee(ISetToken _setToken) internal view returns(uint256) {\n        uint256 timeSinceLastFee = block.timestamp.sub(_lastStreamingFeeTimestamp(_setToken));\n\n        // Streaming fee is streaming fee times years since last fee\n        return timeSinceLastFee.mul(_streamingFeePercentage(_setToken)).div(ONE_YEAR_IN_SECONDS);\n    }\n```\n\nAnd the value should not greater than 1_000_000_000_000_000_000 (Which is 1).\n\nSee this line of code\n\n```solidity\nuint256 b = PreciseUnitMath.preciseUnit().sub(_feePercentage);\n```\n\nin StreamingFeeModule#_calculateStreamingFeeInflation\n\n```solidity\nfunction _calculateStreamingFeeInflation(\n        ISetToken _setToken,\n        uint256 _feePercentage\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 totalSupply = _setToken.totalSupply();\n\n        // fee * totalSupply\n        uint256 a = _feePercentage.mul(totalSupply);\n\n        // ScaleFactor (10e18) - fee\n        uint256 b = PreciseUnitMath.preciseUnit().sub(_feePercentage); // @audit\n\n        return a.div(b);\n    }\n```    \n\nIf not, ```PreciseUnitMath.preciseUnit().sub(_feePercentage)``` will give subtraction overflow.\n\nSadly, this can happen with \n\n1) high streamingFeePercentage. \n\nblock.timestamp = 1_718_289_524\nlastStreamingFeeTimestamp = 1_686_731_919\ntimeSinceLastFee = 1_718_289_524 - 1_686_731_919 = 31_557_605 (After 1 year)\nstreamingFeePercentage = 999_999_990_000_000_000 (Which is 0.99999999)\none year in second = 31_557_600\n\nStreaming fee \n= timeSinceLastFee * streamingFeePercentage / one year in second\n= 1_000_000_148_440_437_485\n\nwhich is more than 1_000_000_000_000_000_000 (1 * 10^18)\n\n2) Previous claim was too long \n\nblock.timestamp = 1_718_289_524\nlastStreamingFeeTimestamp = 20_336_49_524\ntimeSinceLastFee = 20_336_49_524 - 1_718_289_524 =  315_360_000 (After 10 years)\nstreamingFeePercentage = 110_000_000_000_000_000 (Which is 0.11) [This time this value is small]\none year in second = 31_557_600\n\nStreaming fee \n= timeSinceLastFee * streamingFeePercentage / one year in second\n= 1_099_247_091_033_538_672\n\n## Impact\nAccrued fee will not work if streamingFeePercentage is too high or previous claim was too long.\n\n## Code Snippet\nhttps://github.com/IndexCoop/index-protocol/blob/master/contracts/protocol/modules/v1/StreamingFeeModule.sol#L224-L241\nhttps://github.com/IndexCoop/index-protocol/blob/master/contracts/protocol/modules/v1/StreamingFeeModule.sol#L203-L208\nhttps://github.com/IndexCoop/index-protocol/blob/master/contracts/protocol/modules/v1/StreamingFeeModule.sol#L86-L108C6\n## Tool used\n\nManual Review\nManual and added hardhat test unit\n\n## Recommendation\nDon't allow high streamingFeePercentage value to be set. We cannot control how long people wait until the next claim. We can only control the value of streamingFeePercentage ","decidedSeverity":"false","decidedDuplication":"Accrued fee does not work with high streamingFeePercentage or previous claim was too long"},{"file":"275.md","watson":{"name":"0x4db5362c"},"severity":"medium","title":"Wrong inflation fee calculation in StreamingFeeModule","markdown":"0x4db5362c\n\nmedium\n\n# Wrong inflation fee calculation in StreamingFeeModule\n\n## Summary\nWhen StreamingFeeModule#accrueFee is called to accrue inflation fee for the manager of specified SetToken, any user who holds a certain amount of SetToken can redeem their SetToken's position through front-run transaction to avoid paying inflation fee to the manager, then issue their SetTokens's again after StreamingFeeModule#accrueFee was called. Hence their SetToken's position is not affected by inflation defined by the manager of SetToken.\n\nOn the other hand, for a specified SetToken, all holders who issued SetToken between StreamingFeeModule#accrueFee calling need to pay more inflation fees than they should.\n\n## Vulnerability Detail\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/StreamingFeeModule.sol#L232-L238\n\n        uint256 totalSupply = _setToken.totalSupply();\n\n        // fee * totalSupply\n        uint256 a = _feePercentage.mul(totalSupply);\n\n        // ScaleFactor (10e18) - fee\n        uint256 b = PreciseUnitMath.preciseUnit().sub(_feePercentage);\n\n        return a.div(b);\n\ntotalSupply can be manipulated, which will cause wrong inflation fee calculation. \n\n## Impact\n1.Holders of SetToken can bypass inflation fee paying.\n2.Holders who issued SetToken between StreamingFeeModule#accrueFee calling need to pay more inflation fees than they should.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/StreamingFeeModule.sol#L224-L241\n## Tool used\n\nManual Review\n\n## Proof of concept\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/test/protocol/modules/v1/streamingFeeModule.spec.ts#L324-L327\n1.Modify the test code as below:\n\n      await increaseTimeAsync(subjectTimeFastForward);\n      await issuanceModule.connect(owner.wallet).redeem(setToken.address, ether(1), owner.address);\n      return streamingFeeModule.accrueFee(subjectSetToken);\n\nif owner redeems SetToken's position just before StreamingFeeModule#accrueFee was called, the 'feeInflation' calculated in the test case below will be ZERO.\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/test/protocol/modules/v1/streamingFeeModule.spec.ts#L329-L347\n\n1.Modify the test code as below:\n\n      await increaseTimeAsync(subjectTimeFastForward);\n      await issuanceModule.connect(owner.wallet).issue(setToken.address, ether(1), owner.address);\n      return streamingFeeModule.accrueFee(subjectSetToken);\n\nThe 'feeInflation' calculated in the test case below will be doubled even the holder only issued SetToken seconds before StreamingFeeModule#accrueFee is called .\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/test/protocol/modules/v1/streamingFeeModule.spec.ts#L329-L347\n\n## Recommendation\nAdding accumulatedTotalSupply to track supply change of SetToken. accumulatedTotalSupply will be updated when issuing/redeeming. StreamingFeeModule#accrueFee will use the difference between previous accumulatedTotalSupply (stored in  StreamingFeeModule during last call of StreamingFeeModule#accrueFee) and latest accumulatedTotalSupply to calculate inflationFee.\n\nAdd new variables in SetToken to store accumulated supply and the latest accumulated timestamp. Use accumulated supply instead of totalSupply to calculate inflation fee in StreamingFeeModule.\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/SetToken.sol\nAdds codes below:\n\n    uint256 public accumulatedTotalSupply;\n    uint256 public lastAccumulatedTime;    \n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\n        updateAccumulatedTotalSupply();\n        for (uint256 i=0; i<modules.length; i++) {\n            address module = modules[i];\n            if (module.isContract()&&(moduleStates[module] == ISetToken.ModuleState.INITIALIZED)) {\n                IModule(modules[i]).beforeTokenTransfer(from, to, amount);\n            }\n        }\n    }\n    function updateAccumulatedTotalSupply() public {\n        if (block.timestamp > lastAccumulatedTime) {\n            accumulatedTotalSupply += (block.timestamp - lastAccumulatedTime).mul(totalSupply());\n            lastAccumulatedTime = block.timestamp;\n        }\n    }\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/interfaces/ISetToken.sol\nAdds new functions:\n\n    function accumulatedTotalSupply() external view returns (uint256);\n    function updateAccumulatedTotalSupply() external;\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/interfaces/IModule.sol\nAdd new function:\n\n    //it will be called by SetToken during before issuing\n    function beforeTokenTransfer(address from, address to, uint256 amount) external;\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/lib/ModuleBase.sol\nAdd new function implementation:\n\n    function beforeTokenTransfer(address from, address to, uint256 amount) external override virtual {}\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/StreamingFeeModule.sol\nAdds/updates definitions and function implementations.\n\n    struct FeeState {\n        address feeRecipient;                   // Address to accrue fees to\n        uint256 maxStreamingFeePercentage;      // Max streaming fee maanager commits to using (1% = 1e16, 100% = 1e18)\n        uint256 streamingFeePercentage;         // Percent of Set accruing to manager annually (1% = 1e16, 100% = 1e18)\n        uint256 lastStreamingFeeTimestamp;      // Timestamp last streaming fee was accrued\n        uint256 lastStreamingAccumulatedTotalSupply;//accumulatedTotalSupply of SetToken last streaming fee was accrued\n    }\n\n    function initialize(\n        ISetToken _setToken,\n        FeeState memory _settings\n    )\n        external\n        onlySetManager(_setToken, msg.sender)\n        onlyValidAndPendingSet(_setToken)\n    {\n        require(_settings.feeRecipient != address(0), \"Fee Recipient must be non-zero address.\");\n        require(_settings.maxStreamingFeePercentage < PreciseUnitMath.preciseUnit(), \"Max fee must be < 100%.\");\n        require(_settings.streamingFeePercentage <= _settings.maxStreamingFeePercentage, \"Fee must be <= max.\");\n\n        _settings.lastStreamingFeeTimestamp = block.timestamp;\n        _setToken.updateAccumulatedTotalSupply();\n        _settings.lastStreamingAccumulatedTotalSupply = _setToken.accumulatedTotalSupply();\n        feeStates[_setToken] = _settings;\n        _setToken.initializeModule();\n    }\n\n    function accrueFee(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {\n        uint256 managerFee;\n        uint256 protocolFee;\n        \n        _setToken.updateAccumulatedTotalSupply();\n\n        if (_streamingFeePercentage(_setToken) > 0) {\n            uint256 inflationFeePercentage = _calculateStreamingFee(_setToken); \n            // Calculate incentiveFee inflation\n            uint256 feeQuantity = _calculateStreamingFeeInflation(_setToken, inflationFeePercentage);\n\n            // Mint new Sets to manager and protocol\n            (\n                managerFee,\n                protocolFee\n            ) = _mintManagerAndProtocolFee(_setToken, feeQuantity);\n            if (feeQuantity != 0) {\n                _editPositionMultiplier(_setToken, feeQuantity); \n            }\n        }\n\n        feeStates[_setToken].lastStreamingFeeTimestamp = block.timestamp;\n        feeStates[_setToken].lastStreamingAccumulatedTotalSupply = _setToken.accumulatedTotalSupply();\n\n        emit FeeActualized(address(_setToken), managerFee, protocolFee);\n    }\n\n    function _calculateStreamingFee(ISetToken _setToken) internal view returns(uint256) {\n        return _streamingFeePercentage(_setToken).div(ONE_YEAR_IN_SECONDS);\n    }\n\n    function _calculateStreamingFeeInflation(\n        ISetToken _setToken,\n        uint256 _feePercentage\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 accumulatedTotalSupplyInterval = _setToken.accumulatedTotalSupply() - _lastStreamingAccumulatedTotalSupply(_setToken);\n        if (accumulatedTotalSupplyInterval != 0) {\n            // fee * totalSupply\n            uint256 a = _feePercentage.mul(accumulatedTotalSupplyInterval);\n\n            // ScaleFactor (10e18) - fee\n            uint256 b = PreciseUnitMath.preciseUnit().sub(_feePercentage);\n\n            return a.div(b);\n        } else {\n            return 0;\n        }\n    }\n\n    function _editPositionMultiplier(ISetToken _setToken, uint256 _inflationFee) internal {//@audit-ok\n        int256 currentMultipler = _setToken.positionMultiplier();\n        uint256 totalSupply = _setToken.totalSupply();\n        int256 newMultiplier = currentMultipler.mul(totalSupply.sub(_inflationFee).toInt256()).div(totalSupply.toInt256());\n\n        _setToken.editPositionMultiplier(newMultiplier);\n    }\n\n    function _lastStreamingAccumulatedTotalSupply(ISetToken _set) internal view returns (uint256) { \n        return feeStates[_set].lastStreamingAccumulatedTotalSupply;\n    }\n\n    //Accrue inflation fee before SetToken was issued / redeemed. \n    //Issuing SetToken to the feeRecipient of SetToken or the feeRecipient of Controller is not considered as inflation process.\n    function beforeTokenTransfer(address from, address to, uint256 amount) \n        external override \n        onlyValidAndInitializedSet(ISetToken(msg.sender)) \n    {\n        //token transferring between two non-zero address doesn't trigger accrueFee since totalSupply is not changed.\n        if ((from != address(0))&&(to != address(0))) {\n            return;\n        }\n        if (amount == 0) {\n            return;\n        }\n        if ((to != _feeRecipient(ISetToken(msg.sender))) &&(to != controller.feeRecipient())) {\n            accrueFee(ISetToken(msg.sender));\n        }\n    }","decidedSeverity":"false","decidedDuplication":"Wrong inflation fee calculation in StreamingFeeModule"},{"file":"276.md","watson":{"name":"bitsurfer"},"severity":"medium","title":"Unable to update `StreamingFee` to Max Fee config","markdown":"bitsurfer\n\nmedium\n\n# Unable to update `StreamingFee` to Max Fee config\n\n## Summary\n\nUnable to update `StreamingFee` to Max Fee\n\n## Vulnerability Detail\n\nIn the StreamingFeeModule.sol module, the `initialize()` function is invoked by the Set Manager to configure the initial settings for fees using the `FeeState`. One of the important conditions within this function is to ensure that the `streamingFeePercentage` is below or equal to the `maxStreamingFeePercentage`, which is a logical requirement to maintain consistency and prevent excessive fees.\n\n```js\nFile: StreamingFeeModule.sol\n117:     function initialize(\n118:         ISetToken _setToken,\n119:         FeeState memory _settings\n120:     )\n121:         external\n122:         onlySetManager(_setToken, msg.sender)\n123:         onlyValidAndPendingSet(_setToken)\n124:     {\n...\n127:         require(_settings.streamingFeePercentage <= _settings.maxStreamingFeePercentage, \"Fee must be <= max.\");\n...\n133:     }\n```\n\nThe issue lies within the `updateStreamingFee()` function of the StreamingFeeModule.sol module. Currently, the function only checks if the `_newFee` is below the `maxFee`, whereas it should also allow for equality. This inconsistency can lead to potential discrepancies and limitations when updating the streaming fee, as it restricts the fee from being set at the maximum value allowed by the `maxFee`. It is recommended to modify the condition in the `updateStreamingFee()` function to allow the `_newFee` to be below or equal to the `maxFee`.\n\n```js\nFile: StreamingFeeModule.sol\n150:     function updateStreamingFee(\n151:         ISetToken _setToken,\n152:         uint256 _newFee\n153:     )\n154:         external\n155:         onlySetManager(_setToken, msg.sender)\n156:         onlyValidAndInitializedSet(_setToken)\n157:     {\n158:         require(_newFee < _maxStreamingFeePercentage(_setToken), \"Fee must be less than max\");\n...\n164:     }\n```\n\nIndeed, there is an issue in the `updateStreamingFee()` function where the Set Manager may not be able to set the fee to the maximum value specified by the `maxFee` parameter, as it only allows fees below the `maxFee`. This limitation prevents the Set Manager from fully utilizing the maximum fee range that was initially set in the `initialize()` function.\n\nA simple case scenario:\n\n1. Set manager initialize the fee with `maxFee` to 1% and `currentFee` to 0%\n2. Later Set manager want to change the fee to its max, the 1%\n3. It will failed since the `updateStreamingFee` is reverting the `newFee`\n\n## Impact\n\nThis can potentially impact the revenue generated by the protocol, as the fees collected may not reach their intended maximum level.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/StreamingFeeModule.sol#L158\n\n```js\nFile: StreamingFeeModule.sol\n150:     function updateStreamingFee(\n151:         ISetToken _setToken,\n152:         uint256 _newFee\n153:     )\n154:         external\n155:         onlySetManager(_setToken, msg.sender)\n156:         onlyValidAndInitializedSet(_setToken)\n157:     {\n158:         require(_newFee < _maxStreamingFeePercentage(_setToken), \"Fee must be less than max\");\n...\n164:     }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe condition check in the `updateStreamingFee()` function should be modified to allow the `newFee` to be below or equal to the `maxFee`, enabling the Set Manager to set the fee to its maximum value as intended.\n\n```diff\nFile: StreamingFeeModule.sol\n150:     function updateStreamingFee(\n151:         ISetToken _setToken,\n152:         uint256 _newFee\n153:     )\n154:         external\n155:         onlySetManager(_setToken, msg.sender)\n156:         onlyValidAndInitializedSet(_setToken)\n157:     {\n--           require(_newFee < _maxStreamingFeePercentage(_setToken), \"Fee must be less than max\");\n++           require(_newFee <= _maxStreamingFeePercentage(_setToken), \"Fee must be less or equal than max\");\n...\n164:     }\n```\n","decidedSeverity":"false","decidedDuplication":"Unable to update `StreamingFee` to Max Fee config"},{"file":"277.md","watson":{"name":"bitsurfer"},"severity":"medium","title":"`streamingFeePercentage` value can make `positionMultiplier` increased enormously / hyperinflation","markdown":"bitsurfer\n\nmedium\n\n# `streamingFeePercentage` value can make `positionMultiplier` increased enormously / hyperinflation\n\n## Summary\n\n`streamingFeePercentage` value can make `positionMultiplier` increased enormously / hyperinflation\n\n## Vulnerability Detail\n\nSome `streamingFeePercentage` values can make `positionMultiplier` increased enormously / hyperinflation when Set Manager input a value which returned a rounded to 0 on `_calculateStreamingFee()` function\n\nAt first we might see this seems like a simple user input validation issue, but as mentioned in Sherlock's docs:\n\n> User input validation to prevent user mistakes is not considered a valid issue. However, if a user input could result in a major protocol malfunction or significant loss of funds could be a valid high.\n\nSince there is no minimum fee introduced, also TokenSet / Index Coop provides article about updating fee through Etherscan (which open for an input failure), failed to mitigate will effect to the set, not only to the set manager but will have significant loss of funds of user; which this might categorized as medium issue.\n\nCurrently, exist max fee config to prevent Set Manager for such malicious act (for example setting fee 100%), but minimum fee config does not exist.\n\nIt can be 0 for sure, so a Set doesn't have any fee, but to be precise the range is not `0 <= x <= maxFee`. It should be `0` or `valid-min <= x <= maxFee`, where `valid-min` should not produce rounding issue in `_calculateStreamingFee` calculation.\n\n```js\nFile: StreamingFeeModule.sol\n203:     function _calculateStreamingFee(ISetToken _setToken) internal view returns(uint256) {\n204:         uint256 timeSinceLastFee = block.timestamp.sub(_lastStreamingFeeTimestamp(_setToken));\n205:\n206:         // Streaming fee is streaming fee times years since last fee\n//           example: return (1685330394 - 1685330294) / 31557600;\n207:         return timeSinceLastFee.mul(_streamingFeePercentage(_setToken)).div(ONE_YEAR_IN_SECONDS);\n208:     }\n```\n\nThere is an edge case, like:\n\n- `timeSinceLastFee` can be small (because it's a diff between current timestamp with last timestamp).\n- `_streamingFeePercentage` can be very small, for example `50` (there is no check anywhere in the code except in `accrueFee` which just check `if (_streamingFeePercentage(_setToken) > 0)`)\n- `ONE_YEAR_IN_SECONDS` = 31557600\n\nWith this values, `_calculateStreamingFee` will return 0, due to rounding.\n\nNext, the `accrueFee` which is the core function in accruing fees, this previous `0` (inflationFeePercentage) value will be input to `editPositionMultiplier`\n\n```js\nFile: StreamingFeeModule.sol\n086:     function accrueFee(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {\n087:         uint256 managerFee;\n088:         uint256 protocolFee;\n089:\n090:         if (_streamingFeePercentage(_setToken) > 0) {\n091:             uint256 inflationFeePercentage = _calculateStreamingFee(_setToken);\n092:\n093:             // Calculate incentiveFee inflation\n094:             uint256 feeQuantity = _calculateStreamingFeeInflation(_setToken, inflationFeePercentage);\n095:\n096:             // Mint new Sets to manager and protocol\n097:             (\n098:                 managerFee,\n099:                 protocolFee\n100:             ) = _mintManagerAndProtocolFee(_setToken, feeQuantity);\n101:\n102:             _editPositionMultiplier(_setToken, inflationFeePercentage);\n103:         }\n104:\n105:         feeStates[_setToken].lastStreamingFeeTimestamp = block.timestamp;\n106:\n107:         emit FeeActualized(address(_setToken), managerFee, protocolFee);\n108:     }\n```\n\nThe issue is on `_editPositionMultiplier`, with `inflationFeePercentage` = 0 will be critical\n\n```js\nFile: StreamingFeeModule.sol\n278:     function _editPositionMultiplier(ISetToken _setToken, uint256 _inflationFee) internal {\n279:         int256 currentMultipler = _setToken.positionMultiplier();\n280:         int256 newMultiplier = currentMultipler.preciseMul(PreciseUnitMath.preciseUnit().sub(_inflationFee).toInt256());\n281:\n282:         _setToken.editPositionMultiplier(newMultiplier);\n283:     }\n```\n\nThis will update positionMultiplier by multiplying `currentMultipler` with `preciseUnit` (10 \\*\\* 18) but substracted by `0`, which will be a large number. (Initially `currentMultipler` is 10e18, so multiplying it again with preciseUnit, will be a biger number). The issue will have a lot of derived issue when the `positionMultiplier` is a large number.\n\nAgain, even though this seems an input validation issue, but I argue, this is a medium because:\n\n- Set Token previously introduce user (set manager) to familiar with Manual interaction with Etherscan contract interface form input, which open for manual input failure.\n- Set Token manager can be anyone (not the dev of Set Token / Index Coop) which might failed to understand the decimal precision etc.\n- This issue will affect user holding the SetToken/Index potential for losing asset due to hyper inflation because of big positionMultiplier\n\n## Impact\n\nan excessive growth of the `positionMultiplier` for each streaming fee accrual. This could lead to an unsustainable increase in the value of positions within the protocol, potentially causing instability and devaluing the overall system\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/StreamingFeeModule.sol#L207\n\nSee above\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThere should be a valid range `minFee`-`maxFee` setting input for fee, but still accepting the `0` fee\n\n```diff\nFile: StreamingFeeModule.sol\n086:     function accrueFee(ISetToken _setToken) public nonReentrant onlyValidAndInitializedSet(_setToken) {\n087:         uint256 managerFee;\n088:         uint256 protocolFee;\n089:\n--           if (_streamingFeePercentage(_setToken) > 0) {\n++           if(_streamingFeePercentage(_setToken) != 0 && _streamingFeePercentage(_setToken) > minFee) {\n091:             uint256 inflationFeePercentage = _calculateStreamingFee(_setToken);\n...\n103:         }\n...\n108:     }\n...\n150:     function updateStreamingFee(\n151:         ISetToken _setToken,\n152:         uint256 _newFee\n153:     )\n154:         external\n155:         onlySetManager(_setToken, msg.sender)\n156:         onlyValidAndInitializedSet(_setToken)\n157:     {\n158:         require(_newFee < _maxStreamingFeePercentage(_setToken), \"Fee must be less than max\");\n++           if(_newFee != 0 && _newFee < _minStreamingFeePercentage(_setToken)) revert();\n...\n164:     }\n```\n","decidedSeverity":"false","decidedDuplication":"`streamingFeePercentage` value can make `positionMultiplier` increased enormously / hyperinflation"},{"file":"278.md","watson":{"name":"bitsurfer"},"severity":"medium","title":"`TradeModule` open to failure on integration with a dex for some certain quotes","markdown":"bitsurfer\n\nmedium\n\n# `TradeModule` open to failure on integration with a dex for some certain quotes\n\n## Summary\n\n`TradeModule` open to failure on integration with a dex for some certain quotes\n\n## Vulnerability Detail\n\nThe `TradeModule.sol` is a module which will executes a trade on a supported DEX which is only callable by the SetToken's manager.\n\nMain function in the module is the `trade()` function which cover the preparing struct `TradeInfo` and calling `_executeTrade()`.\n\n```js\nFile: TradeModule.sol\n116:     function trade(\n117:         ISetToken _setToken,\n118:         string memory _exchangeName,\n119:         address _sendToken,\n120:         uint256 _sendQuantity,\n121:         address _receiveToken,\n122:         uint256 _minReceiveQuantity,\n123:         bytes memory _data\n124:     )\n125:         external\n126:         nonReentrant\n127:         onlyManagerAndValidSet(_setToken)\n128:     {\n129:         TradeInfo memory tradeInfo = _createTradeInfo(\n130:             _setToken,\n131:             _exchangeName,\n132:             _sendToken,\n133:             _receiveToken,\n134:             _sendQuantity,\n135:             _minReceiveQuantity\n136:         );\n...\n140:         _executeTrade(tradeInfo, _data);\n...\n160:     }\n```\n\nthe `trade()` function inside `TradeModule` will also choose the `exchangeName` from the parameter. From docs https://docs.indexcoop.com/index-coop-community-handbook/protocols/set-protocol-v2#adapters-and-extensions we can see which exchange does Index Coop supports and integrates, 0x, Curve, Synthetix, Uniswap, Sushiswap etc.\n\nThe issue came from the integration with 0x (ZeroEx), and will breaks Index Coop compatibility with some quotes. As the [0x docs](https://0x.org/docs/0x-swap-api/guides/use-0x-api-liquidity-in-your-smart-contracts#payable-fallback) state: `Certain quotes require a protocol fee, in ETH, to be attached to the swap call`.\n\n```js\nFile: TradeModule.sol\n236:     function _executeTrade(\n237:         TradeInfo memory _tradeInfo,\n238:         bytes memory _data\n239:     )\n240:         internal\n241:     {\n...\n249:         (\n250:             address targetExchange,\n251:             uint256 callValue,\n252:             bytes memory methodData\n253:         ) = _tradeInfo.exchangeAdapter.getTradeCalldata(\n254:             _tradeInfo.sendToken,\n255:             _tradeInfo.receiveToken,\n256:             address(_tradeInfo.setToken),\n257:             _tradeInfo.totalSendQuantity,\n258:             _tradeInfo.totalMinReceiveQuantity,\n259:             _data\n260:         );\n261:\n262:         _tradeInfo.setToken.invoke(targetExchange, callValue, methodData);\n263:     }\n\nFile: ZeroExApiAdapter.sol\n097:     function getTradeCalldata(\n098:         address _sourceToken,\n099:         address _destinationToken,\n100:         address _destinationAddress,\n101:         uint256 _sourceQuantity,\n102:         uint256 _minDestinationQuantity,\n103:         bytes calldata _data\n104:     )\n105:         external\n106:         view\n107:         returns (address, uint256, bytes memory)\n108:     {\n...\n207:         return (\n208:             zeroExAddress,\n209:             // Note: Does not account for limit order protocol fees.\n210:             0,\n211:             _data\n212:         );\n213:     }\n```\n\nWe can see from the snippet when executing trade (`_executeTrade`) will call to `getTradeCalldata`, the `callValue` will always 0, reasoning with `// Note: Does not account for limit order protocol fees.` while in fact, there might be some token required a fees. finally the `_tradeInfo.setToken.invoke(targetExchange, callValue, methodData);` will send `callValue` with 0, which will open for a revert when calling it to 0x exchange.\n\n## Impact\n\n`TradeModule` trade function won't be compatible with certain quotes\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/TradeModule.sol#L116-L128\n\nSee above\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd `payable` to `trade` function, remove the hardcoded 0 for value and replace with if the quote api response from 0x returned a fee, finally provide a `payable fallback` in the contract for refunds, for example:\n\n```js\n// Payable fallback to allow this contract to receive protocol fee refunds.\nreceive() external payable {}\n```\n","decidedSeverity":"false","decidedDuplication":"`TradeModule` open to failure on integration with a dex for some certain quotes"},{"file":"279.md","watson":{"name":"bitsurfer"},"severity":"medium","title":"`onlyEOA` modifier that ensures call is from EOA might not hold true in the future","markdown":"bitsurfer\n\nmedium\n\n# `onlyEOA` modifier that ensures call is from EOA might not hold true in the future\n\n## Summary\n\n`onlyEOA` modifier that ensures call is from EOA might not hold true in the future\n\n## Vulnerability Detail\n\nThe usage of `tx.origin` to ensure that `msg.sender` is an externally owned account (EOA) and not a smart contract may no longer hold true if EIP 3074 is implemented.\n\nRelying solely on the `onlyEOA` modifier to verify the origin of a call may no longer be sufficient for ensuring the desired level of security and access control. It is crucial to stay informed about the developments and recommendations outlined in EIP 3074 and consider alternative approaches or additional checks to accurately validate the desired account types in your contract.\n\nEIP 3074 introduces two new EVM instructions, AUTH and AUTHCALL, which allow for delegation of control over an EOA to a smart contract. These instructions enable a smart contract to act on behalf of an EOA, blurring the distinction between EOAs and smart contracts when it comes to determining the origin of a call.\n\nAs a result, relying on `tx.origin` to verify the EOA status of `msg.sender` may no longer provide accurate information if EIP 3074 is adopted.\n\nIt is important to take into account the potential impact of EIP 3074 on the assumptions and security measures of your contract, and consider alternative approaches or additional checks to ensure the desired behavior and access control.\n\nReference: a valid medium issue from, https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/21\n\n## Impact\n\nUsing modifier `onlyEOA` to ensure calls are from EOA will not hold true when EIP 3074 is adopted.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/lib/BaseExtension.sol#L59-L62\n\n```js\nFile: BaseExtension.sol\n59:     modifier onlyEOA() {\n60:         require(msg.sender == tx.origin, \"Caller must be EOA Address\");\n61:         _;\n62:     }\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRecommend using OpenZepellin's isContract function (https://docs.openzeppelin.com/contracts/2.x/api/utils#Address-isContract-address-). Note that there are edge cases like contract in constructor that can bypass this and hence caution is required when using this.\n","decidedSeverity":"medium","decidedDuplication":"onlyEOA modifier that ensures call is from EOA might not hold true with the eip 3074"},{"file":"280.md","watson":{"name":"bitsurfer"},"severity":"medium","title":"The return data of the `Invoke` function is not properly verified when using the Transfer and Approve ERC20 functions.","markdown":"bitsurfer\n\nmedium\n\n# The return data of the `Invoke` function is not properly verified when using the Transfer and Approve ERC20 functions.\n\n## Summary\n\nThe return data of the `Invoke` function is not properly verified when using the Transfer and Approve ERC20 functions.\n\n## Vulnerability Detail\n\nIndex Coop has a custom Invoke `invoke()` function specific to encapsulate call for some ERC20 function like Transfer and Approve.\n\nThe issue here is the return of that call doesn't check or filter again if the call to ERC20 function is success or failed.\n\nIn the ERC20 standard, it is crucial to validate the return values of transfer and approve functions to ensure the transaction was executed successfully and to handle any potential errors or exceptions that may occur.\n\n```js\nFile: Invoke.sol\n46:     function invokeApprove(\n47:         ISetToken _setToken,\n48:         address _token,\n49:         address _spender,\n50:         uint256 _quantity\n51:     )\n52:         internal\n53:     {\n54:         bytes memory callData = abi.encodeWithSignature(\"approve(address,uint256)\", _spender, _quantity);\n55:         _setToken.invoke(_token, 0, callData);\n56:     }\n...\n66:     function invokeTransfer(\n67:         ISetToken _setToken,\n68:         address _token,\n69:         address _to,\n70:         uint256 _quantity\n71:     )\n72:         internal\n73:     {\n74:         if (_quantity > 0) {\n75:             bytes memory callData = abi.encodeWithSignature(\"transfer(address,uint256)\", _to, _quantity);\n76:             _setToken.invoke(_token, 0, callData);\n77:         }\n78:     }\n\nFile: SetToken.sol\n197:     function invoke(\n198:         address _target,\n199:         uint256 _value,\n200:         bytes calldata _data\n201:     )\n202:         external\n203:         onlyModule\n204:         whenLockedOnlyLocker\n205:         returns (bytes memory _returnValue)\n206:     {\n207:         _returnValue = _target.functionCallWithValue(_data, _value);\n208:\n209:         emit Invoked(_target, _value, _data, _returnValue);\n210:\n211:         return _returnValue;\n212:     }\n```\n\nFailure to appropriately check the return values of token transfers or approvals within the `invoke()` function may result in potential errors or issues going unnoticed. This can lead to incorrect assumptions about the success of these operations, potentially compromising the integrity of the token transfers or approvals.\n\n## Impact\n\npotential errors or issues going unnoticed, leading to incorrect assumptions about the success of token transfers or approvals.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/SetToken.sol#L197-L212\n\nSee above\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse OpenZeppelin library for this issue, `safeTransfer` & `safeApprove` or customize it to include / filter the `safe` return data\n\n```js\nrequire(returndata.length == 0 ||\n  abi.decode(returndata, bool), \"SafeERC20: ERC20 operation did not succeed\");\n```\n","decidedSeverity":"medium","decidedDuplication":"AmmModule will not work with usdt"},{"file":"281.md","watson":{"name":"tsvetanovv","days":71,"is_team":false,"payout":1472.34,"score":8.4782267837,"senior":false},"severity":"medium","title":"Use `call()` instead of `transfer()` when transferring ETH","markdown":"tsvetanovv\n\nmedium\n\n# Use `call()` instead of `transfer()` when transferring ETH\n\n## Summary\n\nIn `AaveLeverageStrategyExtension.sol` we have two functions that use `.transfer()` instead of `call()`:\n\n- `withdrawEtherBalance()`\n- `_transferEtherRewardToCaller()`\n\nUsing the `transfer()` function when transferring ETH is not recommended.\n\n## Vulnerability Detail\n\nThe `transfer()` function forward a fixed amount of 2300 gas. The gas cost of EVM instructions may change significantly during hard forks which may break already deployed contract systems that make fixed assumptions about gas costs.\n\n## Impact\n\nThe use of the deprecated `transfer()` function when transferring `ETH` will inevitably make the transaction fail when:\n\n-   The claimer smart contract does not implement a payable function.\n-   The claimer smart contract does implement a payable fallback which uses more than 2300 gas unit.\n-   The claimer smart contract implements a payable fallback function that needs less than 2300 gas units but is called through proxy, raising the call's gas usage above 2300.\n-   Additionally, using higher than 2300 gas might be mandatory for some multisig wallets.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L580-L585\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1218-L1224\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nI recommend using `call()` method instead of `transfer()`.","decidedSeverity":"false","decidedDuplication":"Use `call()` instead of `transfer()` when transferring ETH"},{"file":"282.md","watson":{"name":"tsvetanovv","days":71,"is_team":false,"payout":1472.34,"score":8.4782267837,"senior":false},"severity":"medium","title":"It's possible to withdraw the contract balance during rebalance period","markdown":"tsvetanovv\n\nmedium\n\n# It's possible to withdraw the contract balance during rebalance period\n\n## Summary\nIn `AaveLeverageStrategyExtension.sol` we have `withdrawEtherBalance()` function:\n```solidity\n/**\n     * OPERATOR ONLY: Withdraw entire balance of ETH in this contract to operator. Rebalance must not be in progress\n     */\n    function withdrawEtherBalance() external onlyOperator noRebalanceInProgress {\n        msg.sender.transfer(address(this).balance);\n    }\n```\n This function withdraws the entire balance of ETH in this contract to the operator. \n - *Rebalance must not be in progress*\n \n## Vulnerability Detail\n\nBut there is a way to pull the balance out of the contract and get around `noRebalanceInProgress()`.\n\n- A user can call the `ripcord()` function to get rewards in ETH\n- `ripcord()` call `_transferEtherRewardToCaller()` function\n- If the ETH balance on this contract is less than the required incentive quantity, then transfer the contract balance instead to prevent reverts\n\nIn this situation, ETH can be withdrawn from the contract during the rebalancing period.\n\n## Impact\n\n`noRebalanceInProgress()` modifier can be bypassed and ETH balance can be withdrawn during the rebalance period\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L580-L585\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1218-L1224\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAdd `noRebalanceInProgress()` modifier to `_transferEtherRewardToCaller()`","decidedSeverity":"false","decidedDuplication":"It's possible to withdraw the contract balance during rebalance period"},{"file":"283.md","watson":{"name":"tsvetanovv","days":71,"is_team":false,"payout":1472.34,"score":8.4782267837,"senior":false},"severity":"high","title":"A user calls `ripcord()` to get rewards, but may actually get nothing under certain circumstances","markdown":"tsvetanovv\n\nhigh\n\n# A user calls `ripcord()` to get rewards, but may actually get nothing under certain circumstances\n\n## Summary\n\nIn `AaveLeverageStrategyExtension.sol` we have `ripcord()` function:\n```solidity\nfunction ripcord(string memory _exchangeName) external onlyEOA {\n        LeverageInfo memory leverageInfo = _getAndValidateLeveragedInfo(\n            incentive.incentivizedSlippageTolerance,\n            exchangeSettings[_exchangeName].incentivizedTwapMaxTradeSize,\n            _exchangeName\n        );\n\n        // Use the exchangeLastTradeTimestamp so it can ripcord quickly with multiple exchanges\n        _validateRipcord(leverageInfo, exchangeSettings[_exchangeName].exchangeLastTradeTimestamp);\n\n        ( uint256 chunkRebalanceNotional, ) = _calculateChunkRebalanceNotional(leverageInfo, methodology.maxLeverageRatio, false);\n\n        _delever(leverageInfo, chunkRebalanceNotional);\n\n        _updateRipcordState(_exchangeName);\n\n        uint256 etherTransferred = _transferEtherRewardToCaller(incentive.etherReward);\n\n        emit RipcordCalled(\n            leverageInfo.currentLeverageRatio,\n            methodology.maxLeverageRatio,\n            chunkRebalanceNotional,\n            etherTransferred\n        );\n    }\n```\n\nThis function is intended to reduce the leverage ratio back to the maximum leverage ratio when the current leverage ratio exceeds a certain threshold. This function can be triggered by anyone, but only by externally owned accounts (EOAs).\nThe caller of ripcord() will receive a reward in Ether.\n\nParticular attention should be paid when the function calls out `_transferEtherRewardToCaller`:\n\n```solidity\n392: uint256 etherTransferred = _transferEtherRewardToCaller(incentive.etherReward);\n```\n\n## Vulnerability Detail\n`_transferEtherRewardToCaller`:\n```solidity\nfunction _transferEtherRewardToCaller(uint256 _etherReward) internal returns(uint256) {\n        uint256 etherToTransfer = _etherReward < address(this).balance ? _etherReward : address(this).balance;\n  \n        msg.sender.transfer(etherToTransfer); \n  \n        return etherToTransfer;\n    }\n```\n\nThis function transfers ETH reward to the caller of the ripcord function. If the ETH balance on this contract is less than the required incentive quantity, then transfer the contract balance instead to prevent reverts.\n\nNow let's imagine the following situation as the numbers are just an example:\n\n- Alice calls `ripcord()` in order to receive rewards\n- `ripcord()` calls `_transferEtherRewardToCaller()`\n- The `_transferEtherRewardToCaller()` calculates that there are fewer ETH rewards in the contract than Alice should receive. Let's say Alice should receive 5 ETH and there are 4 ETH in the contract.\n- And in this situation sends the entire ether balance of the contract.\n\nAnd here come the two possible scenarios.\n- It is possible for an Operator to see Alice's transaction in mempool and call [withdrawEtherBalanc()](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L580-L585) before Alice's transaction finishes and withdraw all ETH balance from the contract.\n```solidity\nfunction withdrawEtherBalance() external onlyOperator noRebalanceInProgress {\n        msg.sender.transfer(address(this).balance); \n    }\n```\n- But let's say the Operator will never do that. The exact same situation is likely to become completely accidental. And Alice will get 0 ETH. \n\n## Impact\n\nA user calls `ripcord()` to get ETH rewards but gets nothing.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L368-L400\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1218-L1224\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L580-L585\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nYou can check if the contract balance is 0 to revert the transaction because `withdrawEtherBalance()` withdraw all Ether from the contract. The other variant is to refactor `_transferEtherRewardToCaller` if the rewards are more than the contract balance to revert the transaction.","decidedSeverity":"false","decidedDuplication":"A user calls `ripcord()` to get rewards, but may actually get nothing under certain circumstances"},{"file":"284.md","watson":{"name":"0x52","days":191,"is_team":false,"payout":418040.47,"score":142.1939095937,"senior":true},"severity":"medium","title":"AaveLeverageStrategyExtension and underlying AaveV3 oracles may diverge","markdown":"0x52\n\nmedium\n\n# AaveLeverageStrategyExtension and underlying AaveV3 oracles may diverge\n\n## Summary\n\nBoth AaveLeverageStrategyExtension and the underlying AaveV3 protocol utilize oracles. AaveLeverageStrategyExtension uses an (effectively) immutable oracle while AaveV3 uses it's in-house AaveOracle. While both are initially use Chainlink, the AaveV3 oracle is mutable and can be changed at a later time. This allows divergence between the two oracles and therefore a difference in decision making based on those differences. Since AaveV3 is the underlying protocol that enforces liquidation it is extremely important that the extension uses the same oracle at all times.\n\n## Vulnerability Detail\n\nSee summary.\n\n## Impact\n\nDivergence in oracle data may lead to a host of issues including liquidation, especially due to the leverage nature of the contracts\n\n## Code Snippet\n\n[AaveLeverageStrategyExtension.sol#L889-L907](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L889-L907)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUtilize AaveOracle rather than setting a different one","decidedSeverity":"false","decidedDuplication":"AaveLeverageStrategyExtension and underlying AaveV3 oracles may diverge"},{"file":"285.md","watson":{"name":"0x52","days":191,"is_team":false,"payout":418040.47,"score":142.1939095937,"senior":true},"severity":"medium","title":"Relying solely on oracle base slippage parameters can cause significant loss due to sandwich attacks","markdown":"0x52\n\nmedium\n\n# Relying solely on oracle base slippage parameters can cause significant loss due to sandwich attacks\n\n## Summary\n\nAaveLeverageStrategyExtension relies solely on oracle price data when determining the slippage parameter during a rebalance. This is problematic as chainlink oracles, especially mainnet, have upwards of 2% threshold before triggering a price update. If swapping between volatile assets, the errors will compound causing even bigger variation. These variations can be exploited via sandwich attacks. \n\n## Vulnerability Detail\n\n[AaveLeverageStrategyExtension.sol#L1147-L1152](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1147-L1152)\n\n    function _calculateMinRepayUnits(uint256 _collateralRebalanceUnits, uint256 _slippageTolerance, ActionInfo memory _actionInfo) internal pure returns (uint256) {\n        return _collateralRebalanceUnits\n            .preciseMul(_actionInfo.collateralPrice)\n            .preciseDiv(_actionInfo.borrowPrice)\n            .preciseMul(PreciseUnitMath.preciseUnit().sub(_slippageTolerance));\n    }\n\nWhen determining the minimum return from the swap, _calculateMinRepayUnits directly uses oracle data to determine the final output. The differences between the true value and the oracle value can be systematically exploited via sandwich attacks. Given the leverage nature of the module, these losses can cause significant loss to the pool.\n\n## Impact\n\nPurely oracle derived slippage parameters will lead to significant and unnecessary losses \n\n## Code Snippet\n\n[AaveLeverageStrategyExtension.sol#L1147-L1152](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1147-L1152)\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nThe solution to this is straight forward. Allow keepers to specify their own slippage value. Instead of using an oracle slippage parameter, validate that the specified slippage value is within a margin of the oracle. This gives the best of both world. It allows for tighter and more reactive slippage controls while still preventing outright abuse in the event that the trusted keeper is compromised.\n","decidedSeverity":"medium","decidedDuplication":"Relying solely on oracle base slippage parameters can cause significant loss due to sandwich attacks"},{"file":"286.md","watson":{"name":"tsvetanovv","days":71,"is_team":false,"payout":1472.34,"score":8.4782267837,"senior":false},"severity":"medium","title":"Don't rely on just one `module` to unlock the `SetToken.sol` contract","markdown":"tsvetanovv\n\nmedium\n\n# Don't rely on just one `module` to unlock the `SetToken.sol` contract\n\n## Summary\nIn `SetToken.sol` we have `lock()` and `unlock()` functions:\n\n```solidity\nfunction lock() external onlyModule { \n        require(!isLocked, \"Must not be locked\");\n        locker = msg.sender;\n        isLocked = true;\n    }\n\nfunction unlock() external onlyModule {\n        require(isLocked, \"Must be locked\");\n        require(locker == msg.sender, \"Must be locker\");\n        delete locker;\n        isLocked = false;\n    }\n```\n\nThe `lock` and `unlock` functions here are used to control access to certain functionalities of the SetToken contract. Only approved modules can call these functions due to the `onlyModule` modifier.\n\nModules can only be added from the manager by `addModule()` or in the constructor.\n```solidity\nfunction addModule(address _module) external onlyManager {\n        require(moduleStates[_module] == ISetToken.ModuleState.NONE, \"Module must not be added\");\n        require(controller.isModule(_module), \"Must be enabled on Controller\");\n  \n        moduleStates[_module] = ISetToken.ModuleState.PENDING; \n\n        emit ModuleAdded(_module);\n    }\n```\n\n## Vulnerability Detail\n\nDon't rely on just one `module` to unlock the `SetToken.sol` contract. If one module use `lock()` only the same module can call `unlock()`. \nImagine the situation one module is hacked or becomes malicious or due to a bug, he can lock the most function in the contract.\n\nEven the Manager cannot remove it via `removeModule()` becouse the contract need to be unlocked:\n\n```solidity\nfunction removeModule(address _module) external onlyManager {\n        require(!isLocked, \"Only when unlocked\");\n        require(moduleStates[_module] == ISetToken.ModuleState.INITIALIZED, \"Module must be added\");\n\n        IModule(_module).removeModule();\n\n        moduleStates[_module] = ISetToken.ModuleState.NONE;\n  \n        modules.removeStorage(_module);\n\n        emit ModuleRemoved(_module);\n    }\n```\n## Impact\n\nIf a module that has locked the contract becomes unable to call the unlock function due to a bug, is hacked, or becomes malicious it could lead to a situation where the contract remains locked indefinitely, which can effectively freeze significant parts of the contract's operations.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/SetToken.sol#L343-L387\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nImplementing a fail-safe mechanism where a trusted party, has the ability to unlock the contract in case of such a situation.\nAs an example you can add that `unlock()` can call it and a manager besides `locker`.","decidedSeverity":"false","decidedDuplication":"Don't rely on just one `module` to unlock the `SetToken.sol` contract"},{"file":"287.md","watson":{"name":"warRoom","days":27,"is_team":true,"payout":801.53,"score":17.6963223486,"senior":false},"severity":"high","title":"Use of deprecated chainlink function - `latestAnswer()`","markdown":"warRoom\n\nhigh\n\n# Use of deprecated chainlink function - `latestAnswer()`\n\n## Summary\nAccording to Chainlink's documentation - [API Reference](https://docs.chain.link/data-feeds/api-reference#getanswer), the `latestAnswer()` function is deprecated. This function doesnot throw any error if no answer has been reached, but instead returns 0. Possibly causing an incorrect price feed or even a Denial of Service by a division by zero.\n\n## Vulnerability Detail\nUse of deprecate function 'lastestAnswer()` for chainlink oracle could lead completely incorrect price feed or denial of service attack. \n\n## Impact\n1. Incorrect price feed resulting loss of funds. \n2. Highly probable Denial of Service\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L895-L898\n\nPossible DOS if price returned 0. \nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1128\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1150\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1109\n\n## Tool used\n\nManual Review\n\n## Recommendation\nIt is recommended to use Chainlink’s [`latestRoundData()`](https://docs.chain.link/data-feeds/api-reference#latestrounddata) function to get\nthe price instead. It is also recommended to add checks on the return\ndata with proper revert messages if the price is stale or the round is\nincomplete.","decidedSeverity":"medium","decidedDuplication":"Deprecated oracle function `latestAnswer()` could bring fund loss"},{"file":"288.md","watson":{"name":"BugBusters"},"severity":"medium","title":"Precision loss in `_calculateChunkRebalanceNotional()` function leads to wrong calculations in AAVE leverage extension.","markdown":"BugBusters\n\nmedium\n\n# Precision loss in `_calculateChunkRebalanceNotional()` function leads to wrong calculations in AAVE leverage extension.\n\n## Summary\nAAVELeverageExtension.sol uses the `_calculateChunkRebalanceNotional` function for `engage`, `disengage`, `handleRebalance`, `ripcord` functions, but due to the precision loss in calculateRebalanceNotional, desired outcome would not be reached precisely.\n## Vulnerability Detail\n`_calculateChunkRebalanceNotional` is an important function that returns two things:\n\n1. chunkRebalanceNotional\n2. totalRebalanceNotional\n\nBut the formula that calculates the total rebalance notional does the division before multiplication that is not recommended to do in solidity as it leads to precision loss and even the output to become zero.\n\n```solidity\n    function _calculateChunkRebalanceNotional(\n        LeverageInfo memory _leverageInfo , // => 1\n        uint256 _newLeverageRatio, // = 2\n        bool _isLever // => true\n    )\n        internal\n        view\n        returns (uint256, uint256)\n    {\n  \n        uint256 leverageRatioDifference = _isLever ? _newLeverageRatio.sub(_leverageInfo.currentLeverageRatio) : _leverageInfo.currentLeverageRatio.sub(_newLeverageRatio);\n\n        // @audit-issue - division before multiplication\n        uint256 totalRebalanceNotional = leverageRatioDifference.preciseDiv(_leverageInfo.currentLeverageRatio).preciseMul(_leverageInfo.action.collateralBalance);\n      \n        uint256 maxBorrow = _calculateMaxBorrowCollateral(_leverageInfo.action, _isLever);\n\n        uint256 chunkRebalanceNotional = Math.min(Math.min(maxBorrow, totalRebalanceNotional), _leverageInfo.twapMaxTradeSize);\n\n        return (chunkRebalanceNotional, totalRebalanceNotional);\n    }\n```\n\nThis internal function is used in other important functions of the extension that do the core working of engaging and disengaging from the leverage.\n\nIf this function doesn't return the accurate value, the working of functions including `engage`, `disengage`, and `ripcord` will be directly impacted.\n## Impact\nWrong calculations lead to not acquiring the required state using engae, disengage and ripcord.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1056-L1075\n## Tool used\n\nManual Review\n\n## Recommendation\nSo multiplication before division.\n","decidedSeverity":"medium","decidedDuplication":"division before multiplication may result in truncation of result"},{"file":"289.md","watson":{"name":"Angry_Mustache_Man"},"severity":"medium","title":"Not checking the return value of withdraw function can cause DOS","markdown":"Angry_Mustache_Man\n\nmedium\n\n# Not checking the return value of withdraw function can cause DOS\n\n## Summary\nIn `AaveV3LeverageModule.sol::delever` when the `withdraw` function is called, it goes on to call `invokeWithdraw` function. The `invokewithdraw` function returns the actual amount withdrawn from Aave which is never used . This might cause DOS.\n## Vulnerability Detail\nThe mechanism goes as `AaveV3LeverageModule:delever->AaveV3LeverageModule:withdraw->AaveV3:invokeWithdraw`. In invokewithdraw the function calls Pool.withdraw and gets a return value, which is the actual amount withdrawn . According to Aave docs and Repo : (actual amount withdrawn) <=(amount mentioned[amt]). But the problem occurs when in the next step of delever function the `executetrade` is called by the outdated `notionalSendQuantity(which is amt as above)`. So when the actual withdrawn amount is less than `amt` , `executetrade` will revert and would cause an unexpected DOS.\n## Impact\nCan cause unexpected DOS .\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L755-#L757\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse the return value of `invokeWithdraw` in `executetrade` function and not outdated `notionalSendQuantity`","decidedSeverity":"false","decidedDuplication":"Not checking the return value of withdraw function can cause DOS"},{"file":"290.md","watson":{"name":"BugBusters"},"severity":"high","title":"Division before multiplication in `_calculateMinRepayUnits` function causes no accurate calculation in delever","markdown":"BugBusters\n\nhigh\n\n# Division before multiplication in `_calculateMinRepayUnits` function causes no accurate calculation in delever\n\n## Summary\n`_calculateMinRepayUnits` function does division before multiplication to calculate minimum repay units, leading to precision loss and less accurate delevering.\n## Vulnerability Detail\nLeveraging and deleveraging is at the heart of aave leverage extension and is the core working for the index coop for the leverage tokens so needed to do the accurate calculation.\n\nBut in the function `_calculateMinRepayUnits` :\n\n```solidity\n    function _calculateMinRepayUnits(uint256 _collateralRebalanceUnits, uint256 _slippageTolerance, ActionInfo memory _actionInfo) internal pure returns (uint256) {\n        return _collateralRebalanceUnits\n            .preciseMul(_actionInfo.collateralPrice)\n            .preciseDiv(_actionInfo.borrowPrice)\n            .preciseMul(PreciseUnitMath.preciseUnit().sub(_slippageTolerance));\n    }\n```\nHere we can see we do division before the last multiplication, hence losing the precision that directly impact the delever function.\n\n\n## Impact\nWrong calculation of min repayAmount leads to un precise de leveraging.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1147-L1152\n## Tool used\n\nManual Review\n\n## Recommendation\nDo multiplication before division","decidedSeverity":"medium","decidedDuplication":"division before multiplication may result in truncation of result"},{"file":"291.md","watson":{"name":"ShadowForce","days":56,"is_team":true,"payout":16317.49,"score":22.9570325496,"senior":false},"severity":"high","title":"Lack of consideration when liquidation happens during leverage","markdown":"ShadowForce\n\nhigh\n\n# Lack of consideration when liquidation happens during leverage\n\n## Summary\n\nLack of consideration when liquidation happens\n\n## Vulnerability Detail\n\nhttps://github.com/IndexCoop/index-protocol/blob/86be7ee76d9a7e4f7e93acfc533216ebef791c89/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L252\n\n@dev MANAGER ONLY: Increases leverage for a given collateral position using an enabled borrow asset.\n\nthis function first borrow asset from lending pool, then swap the borrowed asset to target token and deposit the target token to lending pool as collateral\n\nhttps://github.com/IndexCoop/index-protocol/blob/86be7ee76d9a7e4f7e93acfc533216ebef791c89/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L313\n\n@dev MANAGER ONLY: Decrease leverage for a given collateral position using an enabled borrow asset.\n\nthe protocol try to withdraw from the lending pool and repay the debt\ni\nsuch design failed to consider the case when liquidation happens\n\nhttps://docs.aave.com/developers/guides/liquidations\n\n> The health of the Aave Protocol is dependent on the 'health' of the collateralised positions within the protocol, also known as the 'health factor'. When the 'health factor' of an account's total loans is below 1, anyone can make a liquidationCall() to the Pool or L2Pool (in case of Arbitrum/Optimism) contract, pay back part of the debt owed and receive discounted collateral in return (also known as the liquidation bonus).\n\n```solidity\n_withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);\n\nuint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\nuint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);\n\nuint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n_repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);\n\n_updateDeleverPositions(deleverInfo, _repayAsset);\n```\n\nif the collateral token price falls and the collateral is liquidated (liquidator buying collateral asset in a discount)\n\nwithdraw asset from lending pool can revert if the collateral is liquidated or partially liquidated\n\nit is possible the withdrawal when deleveraging push the protocol directly to liquidation\n\nthis not only make deleverage revert, but also force \n\nthe position out of sycn because the function is below is never called\n\n```solidity\n    /**\n     * @dev Updates positions as per _updateLeverPositions and updates Default position for borrow asset in case Set is\n     * delevered all the way to zero any remaining borrow asset after the debt is paid can be added as a position.\n     */\n    function _updateDeleverPositions(ActionInfo memory _actionInfo, IERC20 _repayAsset) internal {\n        // if amount of tokens traded for exceeds debt, update default position first to save gas on editing borrow position\n        uint256 repayAssetBalance = _repayAsset.balanceOf(address(_actionInfo.setToken));\n        if (repayAssetBalance != _actionInfo.preTradeReceiveTokenBalance) {\n            _actionInfo.setToken.calculateAndEditDefaultPosition(\n                address(_repayAsset),\n                _actionInfo.setTotalSupply,\n                _actionInfo.preTradeReceiveTokenBalance\n            );\n        }\n\n        _updateLeverPositions(_actionInfo, _repayAsset);\n    }\n```\n\n## Impact\n\ndeleverage revert when withdrawal (bigger impact) and leverage revert when borrow (lower impact)\n\n## Code Snippet\n\nhttps://github.com/IndexCoop/index-protocol/blob/86be7ee76d9a7e4f7e93acfc533216ebef791c89/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L252\n\nhttps://github.com/IndexCoop/index-protocol/blob/86be7ee76d9a7e4f7e93acfc533216ebef791c89/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L313\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWe recommend the protocol check the collateral ratio (health factor) when withdraw asset before repay the debt\n\n```solidity\n_withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);\n\n// check health factor here before proceed\n\nuint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\nuint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);\n\nuint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n_repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);\n\n_updateDeleverPositions(deleverInfo, _repayAsset);\n```\n","decidedSeverity":"false","decidedDuplication":"Lack of consideration when liquidation happens during leverage"},{"file":"292.md","watson":{"name":"Phantasmagoria"},"severity":"medium","title":"addLiquidity() function of ammModule.sol reverts every time when adding liquidity","markdown":"Phantasmagoria\n\nmedium\n\n# addLiquidity() function of ammModule.sol reverts every time when adding liquidity\n\n## Summary\naddLiquidity() function of ammModule.sol reverts every time when adding liquidity due to underflow\n\n## Vulnerability Detail\n`_executeAddLiquidity` function is a part of the addLiquidity function that is responsible for transferring of components  to a specified AMM pool. After liquidity was added `_updateComponentPositions` is called:\n```solidity\nfunction _updateComponentPositions(ActionInfo memory _actionInfo) internal returns(int256[] memory) {\n        int256[] memory componentsReceived = new int256[](_actionInfo.components.length);\n\n        for (uint256 i = 0; i < _actionInfo.components.length; i++) {\n\n            (uint256 currentComponentBalance,,) = _actionInfo.setToken.calculateAndEditDefaultPosition(\n                _actionInfo.components[i],\n                _actionInfo.totalSupply,\n                _actionInfo.preActionComponentBalances[i]\n            );\n            // @audit\n            componentsReceived[i] = currentComponentBalance.toInt256()\n                                        .sub(_actionInfo.preActionComponentBalances[i].toInt256());\n        }\n\n\treturn componentsReceived;\n    }\n```\nIn the function `_updateComponentPositions` we subtract the value of `currentComponentBalance` from `preActionComponentBalances` to obtain `componentReceived`. The value of `currentComponentBalance` is obtained from the `calculateAndEditDefaultPosition` function, and it represents the balance of the component after liquidity has been added and tokens have been transferred to the pool:\n```solidity\nuint256 currentBalance = IERC20(_component).balanceOf(address(_setToken));\n```\nAn issue arises here because `preActionComponentBalances` consistently appears to be greater than `currentComponentBalance` As a result, subtracting these two values leads to a revert of the transaction, making it impossible to add liquidity.\n## Impact\nAdding liquidity is impossible due to underflow\n\n## Code Snippet\nhttps://github.com/IndexCoop/index-protocol/blob/86be7ee76d9a7e4f7e93acfc533216ebef791c89/contracts/protocol/modules/v1/AmmModule.sol#L131-L135\n\nhttps://github.com/IndexCoop/index-protocol/blob/86be7ee76d9a7e4f7e93acfc533216ebef791c89/contracts/protocol/modules/v1/AmmModule.sol#L533-L535\n## Tool used\n\nManual Review\n\n## Recommendation\nYou can add parameter that will be true when adding liquidity and false when removing\n```solidity\nfunction addLiquidity(\n        ISetToken _setToken,\n        string memory _ammName,\n        address _ammPool,\n        uint256 _minPoolTokenPositionUnit,\n        address[] calldata _components,\n        uint256[] calldata _maxComponentUnits\n        bool isAdd\n)\n```\nAnd in `_updateComponentPositions` this parameter should be checked like this:\n```solidity\nif(isAdd) {\n        componentsReceived[i] = _actionInfo.preActionComponentBalances[i].toInt256().sub(currentComponentBalance.toInt256());\n} else {\n        componentsReceived[i] = currentComponentBalance.toInt256().sub(_actionInfo.preActionComponentBalances[i].toInt256());\n}\n```\n","decidedSeverity":"false","decidedDuplication":"addLiquidity() function of ammModule.sol reverts every time when adding liquidity"},{"file":"293.md","watson":{"name":"Phantasmagoria"},"severity":"medium","title":"Attacker can make some functionality of the protocol completely unusable","markdown":"Phantasmagoria\n\nmedium\n\n# Attacker can make some functionality of the protocol completely unusable\n\n## Summary\nAttacker can make `removeSet()` function unavailable by creating a lot of setTokens\n\n## Vulnerability Detail\nIn `SetTokenCreator.sol`, we have the `create()` function, which allows anyone to create a setToken. The newly created setToken is then added to the sets array.\n```solidity\nsets.push(_setToken);\n```\n\nTo remove a setToken, the owner should call `removeSet()`. Inside this function, the `remove()` function is called, where `indexOf()` loops over the sets array.\n```solidity\n(uint256 index, bool isIn) = indexOf(A, a);\n```\n```solidity\nfunction indexOf(address[] memory A, address a) internal pure returns (uint256, bool) {\n        uint256 length = A.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (A[i] == a) {\n                return (i, true);\n            }\n        }\n        return (uint256(-1), false);\n    }\n```\nIf the array is large enough, the loop can revert due to running out of gas. As a result, the `removeSet()` function will revert every time,\nrendering this part of the protocol unusable.\n\nA malicious user can easily make this array large enough by creating a lot of setTokens. There are no restrictions on anyone creating any amount of setTokens\n\n## Impact\nMalicious user can make removeSet() function unusable\n\n## Code Snippet\nhttps://github.com/IndexCoop/index-protocol/blob/86be7ee76d9a7e4f7e93acfc533216ebef791c89/contracts/protocol/SetTokenCreator.sol#L104\n\nhttps://github.com/IndexCoop/index-protocol/blob/86be7ee76d9a7e4f7e93acfc533216ebef791c89/contracts/protocol/Controller.sol#L178\n\nhttps://github.com/IndexCoop/index-protocol/blob/86be7ee76d9a7e4f7e93acfc533216ebef791c89/contracts/lib/AddressArrayUtils.sol#L89\n\nhttps://github.com/IndexCoop/index-protocol/blob/86be7ee76d9a7e4f7e93acfc533216ebef791c89/contracts/lib/AddressArrayUtils.sol#L41-L45\n\n## Tool used\n\nManual Review\n\n## Recommendation\nOne way to deal with this issue is to set a limit on how many setTokens can be created\n","decidedSeverity":"false","decidedDuplication":"Attacker can make some functionality of the protocol completely unusable"},{"file":"294.md","watson":{"name":"tsvetanovv","days":71,"is_team":false,"payout":1472.34,"score":8.4782267837,"senior":false},"severity":"high","title":"Wrong modifier in `transferTokens()`","markdown":"tsvetanovv\n\nhigh\n\n# Wrong modifier in `transferTokens()`\n\n## Summary\nIn `BaseManagerV2.sol` we have `transferTokens()`:\n```solidity\n/**\n     * OPERATOR ONLY: Transfers _tokens held by the manager to _destination. Can be used to\n     * recover anything sent here accidentally. In BaseManagerV2, extensions should\n     * be the only contracts designated as `feeRecipient` in fee modules.\n     *\n     * @param _token           ERC20 token to send\n     * @param _destination     Address receiving the tokens\n     * @param _amount          Quantity of tokens to send\n     */\n\n    function transferTokens(address _token, address _destination, uint256 _amount) external onlyExtension { \n        IERC20(_token).safeTransfer(_destination, _amount);\n    }\n```\nThis function transfers any ERC20 tokens held by the manager to a specified destination address.\n\n## Vulnerability Detail\n\nAs we can see from `Natspec` and from the function itself it uses the wrong modifier.\nThe function uses `onlyExtension` but needs to use `onlyOperator` modifier.\n\nIt is very important to add proper access control to `transferTokens()`.\n\n## Impact\n\nWrong access control\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/manager/BaseManagerV2.sol#L309-L320\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nRemove `onlyExtension` and add `onlyOperator` modifier to `transferTokens()` function.","decidedSeverity":"medium","decidedDuplication":"Wrong modifier in `transferTokens()`"},{"file":"295.md","watson":{"name":"BugBusters"},"severity":"high","title":"Emode cannot be enable on Aave Leverage Extension due to call to wrong function.","markdown":"BugBusters\n\nhigh\n\n# Emode cannot be enable on Aave Leverage Extension due to call to wrong function.\n\n## Summary\nCalling the function with wrong signature in extension, never enables the e-mode and instead reverts.\n## Vulnerability Detail\nOne of the new feature added to the codebase is the use of the Aave V3 E-mode, which give more capital efficiency and high borrowing power of upto 97%.\n```solidity\n    function setEModeCategory(uint8 _categoryId) external onlyOperator {\n        _setEModeCategory(_categoryId);\n    }\n\n    function _setEModeCategory(uint8 _categoryId) internal {\n        bytes memory setEmodeCallData =\n            abi.encodeWithSignature(\"setEModeCategory(address,uint8)\", address(strategy.setToken), _categoryId);\n        invokeManager(address(strategy.leverageModule), setEmodeCallData);\n    }\n```\nBut the leverage extension is calling the function with signature `setEModeCategory(address,uint8)` which is the admin specific function and cannot be called by anyone, only risk admin and pool admin can call this function as per the docs here:\nhttps://docs.aave.com/developers/core-contracts/poolconfigurator#setsiloedborrowing\n```text\nsetEModeCategory (categoryId, ltv, liquidationThreshold, liquidationBonus, oracle, label)\nAnd the function used to enable the e-mode in extension is calling the wrong function which is only callable by risk admin of the pool.\n```\n\nThe right function to be called is `setUserEmode` that enables the E-mode for the sender, which is the desired move for the protocol.\n## Impact\nE-mode cannot be enabled.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveV3LeverageStrategyExtension.sol#L60-L68\n## Tool used\n\nManual Review\n\n## Recommendation\nUser the right function of `setUserEmode`","decidedSeverity":"false","decidedDuplication":"Emode cannot be enable on Aave Leverage Extension due to call to wrong function."},{"file":"296.md","watson":{"name":"oxchryston"},"severity":"medium","title":"Chainlink price feed is `deprecated`, not sufficiently validated and can return `stale` prices.","markdown":"oxchryston\n\nmedium\n\n# Chainlink price feed is `deprecated`, not sufficiently validated and can return `stale` prices.\n\n## Summary\nThe function `_createActionInfo()` uses Chainlink's deprecated latestAnswer function, this function also does not guarantee that the price returned by the Chainlink price feed is not stale and there is no additional checks to ensure that the return values are valid.\n\n## Vulnerability Detail\n\nThe internal function `_createActionInfo()` uses calls `strategy.collateralPriceOracle.latestAnswer()` and `strategy.borrowPriceOracle.latestAnswer()` that uses Chainlink's deprecated latestAnswer() to get the latest price. However, there is no check for if the return value is a stale data.\n```solidity\n\nfunction _createActionInfo() internal view returns(ActionInfo memory) {\n        ActionInfo memory rebalanceInfo;\n\n        // Calculate prices from chainlink. Chainlink returns prices with 8 decimal places, but we need 36 - underlyingDecimals decimal places.\n        // This is so that when the underlying amount is multiplied by the received price, the collateral valuation is normalized to 36 decimals.\n        // To perform this adjustment, we multiply by 10^(36 - 8 - underlyingDecimals)\n        int256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\n        rebalanceInfo.collateralPrice = rawCollateralPrice.toUint256().mul(10 ** strategy.collateralDecimalAdjustment);\n        int256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer();\n        rebalanceInfo.borrowPrice = rawBorrowPrice.toUint256().mul(10 ** strategy.borrowDecimalAdjustment);\n// More Code....\n}\n   \n```\n\n## Impact\nThe function `_createActionInfo()` is used to return important values used throughout the contract, the staleness of the chainlinklink return values will lead to wrong calculation of the collateral and borrow prices and other unexpected behavior.\n\n## Code Snippet\nhttps://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/adapters/AaveLeverageStrategyExtension.sol#L889\n\n## Tool used\n\nManual Review\n\n## Recommendation\nThe `latestRoundData` function should be used instead of the deprecated `latestAnswer` function and add sufficient checks to ensure that the pricefeed is not stale.\n\n```solidity\n(uint80 roundId, int256 assetChainlinkPriceInt, , uint256 updatedAt, uint80 answeredInRound) = IPrice(_chainlinkFeed).latestRoundData();\n            require(answeredInRound >= roundId, \"price is stale\");\n            require(updatedAt > 0, \"round is incomplete\");\n ```          \n","decidedSeverity":"medium","decidedDuplication":"Chainlink's latestRoundData return stale or incorrect result"},{"file":"297.md","watson":{"name":"Phantasmagoria"},"severity":"medium","title":"Protocol assumes that chainlink will return prices with 8 decimals","markdown":"Phantasmagoria\n\nmedium\n\n# Protocol assumes that chainlink will return prices with 8 decimals\n\n## Summary\nProtocol assumes that chainlink will return prices with 8 decimals\n\n## Vulnerability Detail\nThe createActionInfo() function wrongly assumes that the decimal places of tokens will always be 8\n```solidity\nfunction _createActionInfo() internal view returns(ActionInfo memory) {\n        ActionInfo memory rebalanceInfo;\n\n        // Calculate prices from chainlink. Chainlink returns prices with 8 decimal places, but we need 36 - underlyingDecimals decimal places.\n        // This is so that when the underlying amount is multiplied by the received price, the collateral valuation is normalized to 36 decimals.\n        // To perform this adjustment, we multiply by 10^(36 - 8 - underlyingDecimals)\n\n```\nBut this assumption is incorrect because some feeds can have more decimals. For example ampl\n![Screenshot from 2023-06-14 08-24-13](https://github.com/sherlock-audit/2023-05-Index-Phantasmagoria13/assets/119745278/6b24b616-ad1c-4fac-8e41-2ecba3f99f26)\nIf the borrowed token has more decimals than the collateral, then this will result in a revert in _calculateCurrentLeverageRatio\n```solidity\nreturn _collateralValue.preciseDiv(_collateralValue.sub(_borrowValue));\n```\nThe calculation of the current leverage ratio is used in most crucial functions such as disengage, ripcord, iterateRebalance, and rebalance\n\n## Impact\nWith certain tokens, AaveLeverageStrategyExtension may not work correctly. Additionally, inaccessible ripcord, iterateRebalance, and rebalance functions can potentially result in the liquidation of positions\n## Code Snippet\nhttps://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/adapters/AaveLeverageStrategyExtension.sol#L892-L897\n\nhttps://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/adapters/AaveLeverageStrategyExtension.sol#L1027\n## Tool used\n\nManual Review\n\n## Recommendation\nConsider normalizing collateralValue and borrowValue to 18 decimals before using them in the formula.\n","decidedSeverity":"medium","decidedDuplication":"Wrongly assume chainlink oracle decimal is always 8"},{"file":"298.md","watson":{"name":"BugBusters"},"severity":"medium","title":"Oracle data feed can be outdated yet used anyways","markdown":"BugBusters\n\nmedium\n\n# Oracle data feed can be outdated yet used anyways\n\n## Summary\nThe `_createActionInfo()` function retrieves the latest price from a Chainlink price feed without checking the freshness or validity of the data. This can lead to the usage of outdated price information, potentially resulting in inaccurate calculations and increased risk for the system.\n\n## Vulnerability Detail\nChainlink classifies their data feeds into four different groups regarding how reliable is each source thus, how risky they are. The groups are Verified Feeds, Monitored Feeds, Custom Feeds and Specialized Feeds (they can be seen [here](https://docs.chain.link/docs/selecting-data-feeds/#data-feed-categories)). The risk is the lowest on the first one and highest on the last one.\n\nA strong reliance on the price feeds has to be also monitored as recommended on the [Risk Mitigation section](https://docs.chain.link/docs/selecting-data-feeds/#risk-mitigation). There are several reasons why a data feed may fail such as unforeseen market events, volatile market conditions, degraded performance of infrastructure, chains, or networks, upstream data providers outage, malicious activities from third parties among others.\n\nChainlink recommends using their data feeds along with some controls to prevent mismatches with the retrieved data. Along some recommendations, the feed can include circuit breakers (for extreme price events), contract update delays (to ensure that the injected data into the protocol is fresh enough), manual kill-switches (to cease connection in case of found bug or vulnerability in an upstream contract), monitoring (control the deviation of the data) and soak testing (of the price feeds).\n\nThe feed.lastRoundData() interface parameters [according to Chainlink](https://docs.chain.link/docs/price-feeds-api-reference/) are the following:\n\n```solidity\nfunction latestRoundData() external view\n    returns (\n        uint80 roundId,             //  The round ID.\n        int256 answer,              //  The price.\n        uint256 startedAt,          //  Timestamp of when the round started.\n        uint256 updatedAt,          //  Timestamp of when the round was updated.\n        uint80 answeredInRound      //  The round ID of the round in which the answer was computed.\n    )\n```\n\nRegarding index coop itself, only the answer is used as ` int256 rawCollateralPrice` on the `_createActionInfo()` implementation. The retrieved price of the priceFeed can be outdated and used anyways as a valid data because no timestamp tolerance of the update source time is checked while storing the return parameters of feed.latestRoundData() as recommended by Chainlink in [here](https://docs.chain.link/docs/using-chainlink-reference-contracts/#check-the-timestamp-of-the-latest-answer).\n\n## Impact\n\nInaccurate Price Calculations: Without checking the freshness of the price feed data, the system may use outdated price information for calculations. This can result in inaccurate pricing estimations, leading to financial loss or transactions based on unreliable data.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L895\n\n## Tool used\n\nManual Review\n\n## Recommendation\nAs Chainlink [recommends](https://docs.chain.link/docs/using-chainlink-reference-contracts/#check-the-timestamp-of-the-latest-answer):\n\n`Your application should track the latestTimestamp variable or use the updatedAt value from the latestRoundData() function to make sure that the latest answer is recent enough for your application to use it. If your application detects that the reported answer is not updated within the heartbeat or within time limits that you determine are acceptable for your application, pause operation or switch to an alternate operation mode while identifying the cause of the delay.`\n\n`During periods of low volatility, the heartbeat triggers updates to the latest answer. Some heartbeats are configured to last several hours, so your application should check the timestamp and verify that the latest answer is recent enough for your application.`\n\nIt is recommended both to add also a tolerance that compares the updatedAt return timestamp from latestRoundData() with the current block timestamp and ensure that the priceFeed is being updated with the required frequency.\n","decidedSeverity":"medium","decidedDuplication":"Chainlink's latestRoundData return stale or incorrect result"},{"file":"299.md","watson":{"name":"ShadowForce","days":56,"is_team":true,"payout":16317.49,"score":22.9570325496,"senior":false},"severity":"high","title":"division before multiplication may result in truncation of result","markdown":"ShadowForce\n\nhigh\n\n# division before multiplication may result in truncation of result\n\n## Summary\ndivision before multiplication may result in truncation of result\n## Vulnerability Detail\n```solidity\n function _calculateMinRepayUnits(uint256 _collateralRebalanceUnits, uint256 _slippageTolerance, ActionInfo memory _actionInfo) internal pure returns (uint256) {\n        // @audit\n        // division before manipulation?\n        return _collateralRebalanceUnits\n            .preciseMul(_actionInfo.collateralPrice)\n            .preciseDiv(_actionInfo.borrowPrice)\n            .preciseMul(PreciseUnitMath.preciseUnit().sub(_slippageTolerance));\n    }\n```\nin the snippet above we can see there is division before multiplication. As we all know doing this can result in truncation.\nfunds may be lost (0) due to division before multiplication precision issues\n\nfor example:\nif _actionInfo.borrowPrice is less than 1, it will be truncated to 0. any further multiplication with this number will also result in 0.\nwe observe multiplication after this point in this specific place.\n```solidity\n .preciseMul(_actionInfo.collateralPrice)\n            .preciseDiv(_actionInfo.borrowPrice)\n            .preciseMul(PreciseUnitMath.preciseUnit().sub(_slippageTolerance));\n```\nall multiplacation must first be done before we decide to divide.\n## Impact\nfunds may be lost (0) due to division before multiplication precision issues\n## Code Snippet\nhttps://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/adapters/AaveLeverageStrategyExtension.sol#L1147-L1152\n## Tool used\n\nManual Review\n\n## Recommendation\nmultiply first then divide to avoid precision loss","decidedSeverity":"medium","decidedDuplication":"division before multiplication may result in truncation of result"},{"file":"300.md","watson":{"name":"ShadowForce","days":56,"is_team":true,"payout":16317.49,"score":22.9570325496,"senior":false},"severity":"high","title":"Excessive asset from trade / swap is not handled well when deleveraging","markdown":"ShadowForce\n\nhigh\n\n# Excessive asset from trade / swap is not handled well when deleveraging\n\n## Summary\n\nExcess asset from trade / swap is not handled well when deleveraging\n\n## Vulnerability Detail\n\nwhen doing the deleverage\n\nhttps://github.com/IndexCoop/index-protocol/blob/86be7ee76d9a7e4f7e93acfc533216ebef791c89/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L313\n\nfirst, we construct the deleverInfo\n\n```solidity\nActionInfo memory deleverInfo = _createAndValidateActionInfo(\n\t\t_setToken,\n\t\t_collateralAsset,\n\t\t_repayAsset,\n\t\t_redeemQuantityUnits,\n\t\t_minRepayQuantityUnits,\n\t\t_tradeAdapterName,\n\t\tfalse\n\t);\n```\n\nthen we withdraw from the lending pool, execute trade and repay the borrow token\n\n```solidity\n_withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);\n\n        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);\n\n        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);\n```\n\nthe issue is that the excessive asset from trade is not handled\n\nthe trade received (quantity - the protocol fee) is used to repay the debt\n\nbut the required debt to be required is the (borrowed amount + the interest rate)\n\nsuppose the only debt that needs to be repayed is 1000 USDC\n\ntrade received (quantity - the protocol) fee is 20000 USDC\n\nonly 1000 USDC is used to repay the debt\n\nbecause when repaying, the paybackAmount is only the debt amount\n\nhttps://github.com/aave/aave-v3-core/blob/29ff9b9f89af7cd8255231bc5faf26c3ce0fb7ce/contracts/protocol/libraries/logic/BorrowLogic.sol#L204\n\n```solidity\nuint256 paybackAmount = params.interestRateMode == DataTypes.InterestRateMode.STABLE\n  ? stableDebt\n  : variableDebt;\n```\n\nthen when burning the variable debt token\n\nhttps://github.com/aave/aave-v3-core/blob/29ff9b9f89af7cd8255231bc5faf26c3ce0fb7ce/contracts/protocol/libraries/logic/BorrowLogic.sol#L224\n\n```solidity\nreserveCache.nextScaledVariableDebt = IVariableDebtToken(\n\treserveCache.variableDebtTokenAddress\n  ).burn(params.onBehalfOf, paybackAmount, reserveCache.nextVariableBorrowIndex);\n```\n\nonly the \"payback amount\", which is 1000 USDC is transferred to pay the debt,\n\nthe excessive leftover amount is (20000 USDC - 1000 USDC) = 19000 USDC\n\nwhich is not handled and never deposit back into the AAVE lending pool\n\n## Impact\n\nthe excessive leftover amount after repaying the debt is never deposited into the AAVE lending pool, leads to unhealth position or liquidation\n\n## Code Snippet\n\nhttps://github.com/IndexCoop/index-protocol/blob/86be7ee76d9a7e4f7e93acfc533216ebef791c89/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L313\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWe recommend the protocol handle the excessive swapped amount ","decidedSeverity":"false","decidedDuplication":"Excessive asset from trade / swap is not handled well when deleveraging"},{"file":"301.md","watson":{"name":"oxchryston"},"severity":"medium","title":"Tokens sent to `manager` contracts will be lost `forever`.","markdown":"oxchryston\n\nmedium\n\n# Tokens sent to `manager` contracts will be lost `forever`.\n\n## Summary\nThe function `transferTokens` is used to transfer tokens and recover tokens accidentally sent to the manager contracts but the wrong modifier was used in that function preventing it from being called by the `Operator`\n\n## Vulnerability Detail\nThe function `transferTokens`is guarded by the wrong modifier `onlyExtension` instead of the `onlyOperator` modifier.\nEven the comment above the function verifies this fact by stating it.\n```solidity\n /**\n     * OPERATOR ONLY: Transfers _tokens held by the manager to _destination. Can be used to\n     * recover anything sent here accidentally. In BaseManagerV2, extensions should\n     * be the only contracts designated as `feeRecipient` in fee modules.\n     *\n     * @param _token           ERC20 token to send\n     * @param _destination     Address receiving the tokens\n     * @param _amount          Quantity of tokens to send\n     */\n    function transferTokens(address _token, address _destination, uint256 _amount) external onlyExtension {\n        IERC20(_token).safeTransfer(_destination, _amount);\n    }\n\n```\n\n## Impact\nUnless the extension contracts has a funtion to withdraw this assets it will be trapped forever in the manager contract leading to loss of funds.\n\n## Code Snippet\nhttps://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/manager/BaseManagerV2.sol#L309-L320\n\n## Tool used\n\nManual Review\n\n## Recommendation\nThis can be simply corrected by changing the modifier on the function from `onlyExtension` to `onlyOperator`, this ensures that the funtion can be called by Operator.\n\n```solidity\nfunction transferTokens(address _token, address _destination, uint256 _amount) external onlyOperator {\n        IERC20(_token).safeTransfer(_destination, _amount);\n    }\n```\n\n","decidedSeverity":"false","decidedDuplication":"Tokens sent to `manager` contracts will be lost `forever`."},{"file":"302.md","watson":{"name":"BugBusters"},"severity":"medium","title":"Chainlink’s latestAnswer might return stale or incorrect results #8","markdown":"BugBusters\n\nmedium\n\n# Chainlink’s latestAnswer might return stale or incorrect results #8\n\n## Summary\nIn AaveLeverageStrategyExtension.sol latestAnswer is being used but there is no check if the return value indicates stale data.\nThis could lead to stale prices according to the Chainlink documentation:\n\nhttps://docs.chain.link/docs/historical-price-data/#historical-rounds\nhttps://docs.chain.link/docs/faq/#how-can-i-check-if-the-answer-to-a-round-is-being-carried-over-from-a-previous-round\n\n## Vulnerability Detail\n```solidity\n int256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\n        rebalanceInfo.collateralPrice = rawCollateralPrice.toUint256().mul(10 ** strategy.collateralDecimalAdjustment);\n        int256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer();\n```\n\n\n## Impact\n\nThe impact of this vulnerability can lead to several potential consequences:\n\n1): Inaccurate Price Calculations: Without checking for stale data, the system is utilizing outdated price information for calculations. This can result in inaccurate pricing estimations, leading to incorrect financial loss or transactions based on unreliable data.\n\n2): Financial Losses and Missed Opportunities: Inaccurate or stale price data can result in financial losses for users and the system. Users relying on outdated prices may make sub optimal trading decisions, resulting in missed opportunities for profit or exposure to unnecessary risks.\n\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L895\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L897\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding missing checks for stale data.\n\nFor example:\n\n```solidity\n function _createActionInfo() internal view returns(ActionInfo memory) {\n        ActionInfo memory rebalanceInfo;\n        //(uint80 roundID, int256 price, uint256 startedAt, uint256 timeStamp, uint80 answeredInRound) = strategy.collateralPriceOracle.latestAnswer();\n        (, int256 price, , , ) = strategy.collateralPriceOracle.latestAnswer();\n\n+      require(updatedAt  > block.timestamp - staleLimit, \"stale price error\")\n        return uint256(price) * 1e10;\n    }\n```\n","decidedSeverity":"medium","decidedDuplication":"Chainlink's latestRoundData return stale or incorrect result"},{"file":"303.md","watson":{"name":"Angry_Mustache_Man"},"severity":"high","title":"Index is vulnerable to attackers sending LTV = 0 collateral tokens, supply/supplyCollateral, borrow and liquidate operations could stop working","markdown":"Angry_Mustache_Man\n\nhigh\n\n# Index is vulnerable to attackers sending LTV = 0 collateral tokens, supply/supplyCollateral, borrow and liquidate operations could stop working\n\n## Summary\nWhen an AToken has LTV = 0, Aave restricts the usage of some operations which could affect the Index protocol critically.\n## Vulnerability Detail\nWhen an AToken has LTV = 0, Aave restricts the usage of some operations. In particular, if the user\nowns at least one AToken as collateral that has LTV = 0, these operations could revert\n1) Withdraw: if the asset withdrawn is collateral, the user is borrowing something, the operation will revert if the\nwithdrawn collateral is an AToken with LTV > 0.\n2) Transfer: if the from is using the asset as collateral, is borrowing something and the asset transferred is an\nAToken with LTV > 0 the operation will revert.\n3) Set the reserve of an AToken as not collateral: if the AToken you are trying to set as non-collateral is an\nAToken with LTV > 0 the operation will revert.\n\nNote that as `invokeWithdraw` and `invokeBorrow` is external ,  this attack is completely possible. In the attack scenario, the bad actor could simply supply an underlying that is associated with an LTV = 0 AToken and transfer it to the Index contract. If the victim does not own any balance of the asset, it will be set as collateral and the victim will suffer from all the side effects previously explained.\n## Impact\n Impact would be - if the user\nowns at least one AToken as collateral that has LTV = 0, these operations could revert\n1) Withdraw: if the asset withdrawn is collateral, the user is borrowing something, the operation will revert if the\nwithdrawn collateral is an AToken with LTV > 0.\n2) Transfer: if the from is using the asset as collateral, is borrowing something and the asset transferred is an\nAToken with LTV > 0 the operation will revert.\n3) Set the reserve of an AToken as not collateral: if the AToken you are trying to set as non-collateral is an\nAToken with LTV > 0 the operation will revert.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/integration/lib/AaveV3.sol#L154\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/integration/lib/AaveV3.sol#L230\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/integration/lib/AaveV3.sol#L154\n\n## Tool used\n\nManual Review\n\n## Recommendation\nOne possible solution that Index could explore after elaborating all the pros/cons/side effects and possible problems could be to allow a DAO to set the \"poison asset\" as non-collateral. If the asset is part of Index's markets, they must be sure that Index's Aave position remains healthy. If the asset is not part of Index's markets, there should be no problem regarding the health factor.","decidedSeverity":"false","decidedDuplication":"Index is vulnerable to attackers sending LTV = 0 collateral tokens, supply/supplyCollateral, borrow and liquidate operations could stop working"},{"file":"304.md","watson":{"name":"BugBusters"},"severity":"medium","title":"Deadline is hardcode to block.timestamp in DexAdapter can cause problem like sandwich attack in aave extensions.","markdown":"BugBusters\n\nmedium\n\n# Deadline is hardcode to block.timestamp in DexAdapter can cause problem like sandwich attack in aave extensions.\n\n## Summary\nDeadline in DexAdapter.sol is hardcoded to block.timestamp, that can cause the immediate revert is current time stamp passes and also expose the protocol to sanwich attacks\n## Vulnerability Detail\nFollowing are the functions in the dexAdapter that are used for swapping after performing the trade on aave to create the leverage:\n```solidity\n function _swapTokensForExactTokensUniV3( \n        address[] memory _path,\n        uint24[] memory _fees,\n        uint256 _amountOut,\n        uint256 _maxAmountIn,\n        ISwapRouter _uniV3Router\n    )\n        private\n        returns(uint256)\n    {\n\n        require(_path.length == _fees.length + 1, \"ExchangeIssuance: PATHS_FEES_MISMATCH\");\n        _safeApprove(IERC20(_path[0]), address(_uniV3Router), _maxAmountIn);\n        if(_path.length == 2){\n            ISwapRouter.ExactOutputSingleParams memory params =\n                ISwapRouter.ExactOutputSingleParams({\n                    tokenIn: _path[0],\n                    tokenOut: _path[1],\n                    fee: _fees[0],\n                    recipient: address(this),\n                    deadline: block.timestamp,\n                    amountOut: _amountOut,\n                    amountInMaximum: _maxAmountIn,\n                    sqrtPriceLimitX96: 0\n                });\n            return _uniV3Router.exactOutputSingle(params);\n        } else {\n            bytes memory pathV3 = _encodePathV3(_path, _fees, true);\n            ISwapRouter.ExactOutputParams memory params =\n                ISwapRouter.ExactOutputParams({\n                    path: pathV3,\n                    recipient: address(this),\n                    deadline: block.timestamp,\n                    amountOut: _amountOut,\n                    amountInMaximum: _maxAmountIn\n                });\n            return _uniV3Router.exactOutput(params);\n        }\n    }\n```\nalso in\n\n```solidity\n    function _swapExactTokensForTokensUniV3(\n        address[] memory _path,\n        uint24[] memory _fees,\n        uint256 _amountIn,\n        uint256 _minAmountOut,\n        ISwapRouter _uniV3Router\n    )\n        private\n        returns (uint256)\n    {\n        require(_path.length == _fees.length + 1, \"ExchangeIssuance: PATHS_FEES_MISMATCH\");\n        _safeApprove(IERC20(_path[0]), address(_uniV3Router), _amountIn);\n        if(_path.length == 2){\n            ISwapRouter.ExactInputSingleParams memory params =\n                ISwapRouter.ExactInputSingleParams({\n                    tokenIn: _path[0],\n                    tokenOut: _path[1],\n                    fee: _fees[0],\n                    recipient: address(this),\n                    deadline: block.timestamp,\n                    amountIn: _amountIn,\n                    amountOutMinimum: _minAmountOut,\n                    sqrtPriceLimitX96: 0\n                });\n            return _uniV3Router.exactInputSingle(params);\n        } else {\n            bytes memory pathV3 = _encodePathV3(_path, _fees, false);\n            ISwapRouter.ExactInputParams memory params =\n                ISwapRouter.ExactInputParams({\n                    path: pathV3,\n                    recipient: address(this),\n                    deadline: block.timestamp,\n                    amountIn: _amountIn,\n                    amountOutMinimum: _minAmountOut\n                });\n            uint amountOut = _uniV3Router.exactInput(params);\n            return amountOut;\n        }\n    }\n```\nIn both the functions,  the deadline parameter is simply passed in as current block.timestamp in which transaction occurs. This effectively means that transaction has no deadline, which means that swap transaction may be included anytime by validators and remain pending in mempool, potentially exposing users to sandwich attacks by attackers or MEV bots.\n\n Consider the following general scenerio that is also applicable to the protocol here:\n\nAlice wants to swap 30 vBNB token for 1 BNB and later sell the 1 BNB for 300 DAI. She signs the transaction calling RiskFund.swapPoolsAsset() with inputAmount = 30 vBNB and amountOutmin = 0.99 BNB to allow for 1% slippage.\n\n2. The transaction is submitted to the mempool, however, Alice chose a transaction fee that is too low for validators to be interested in including her transaction in a block. The transaction stays pending in the mempool for extended periods, which could be hours, days, weeks, or even longer.\n3. When the average gas fee dropped far enough for Alice's transaction to become interesting again for miners to include it, her swap will be executed. In the meantime, the price of BNB could have drastically decreased. She will still at least get 0.99 BNB due to `amountOutmin`, but the DAI value of that output might be significantly lower. She has unknowingly performed a bad trade due to the pending transaction she forgot about.\nAn even worse way this issue can be maliciously exploited is through MEV:\n\nThe swap transaction is still pending in the mempool. Average fees are still too high for validators to be interested in it. The price of BNB has gone up significantly since the transaction was signed, meaning Alice would receive a lot more ETH when the swap is executed. But that also means that her minOutput value is outdated and would allow for significant slippage.\n\n2. A MEV bot detects the pending transaction. Since the outdated `minOut` now allows for high slippage, the bot sandwiches Alice, resulting in significant profit for the bot and significant loss for Alice.\n\n\n## Impact\nPotential reverts, MEV and sandwich attacks.\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/exchangeIssuance/DEXAdapter.sol#L324-L362\n## Tool used\n\nManual Review\n\n## Recommendation\nUse some decent deadline, instead of block.timestamp.","decidedSeverity":"medium","decidedDuplication":"Deadline is hardcode to block.timestamp in DexAdapter can cause problem like sandwich attack in aave extensions."},{"file":"305.md","watson":{"name":"erictee"},"severity":"medium","title":"M - wrong modifier used in transferTokens function in BaseManagerv2.sol according to the comment.","markdown":"erictee\n\nmedium\n\n# M - wrong modifier used in transferTokens function in BaseManagerv2.sol according to the comment.\n\n## Summary\nwrong modifier detected according to the comment.\n\n## Vulnerability Detail\nWrong modifier is used in [BaseManagerV2.sol#L310-L318](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/manager/BaseManagerV2.sol#L310-L318) as it is stated in the comment that this function is `OPERATOR ONLY` however the `onlyExtension()` modifier is used instead.\n\n## Impact\nThe function `transferTokens` cannot be called by operators and can be called by extensions unexpectedly.\n\n\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/manager/BaseManagerV2.sol#L310-L318\n\n\n## Tool used\nManual Review\n\n## Recommendation\nChange the modifier `onlyExtension` to `onlyOperator` to match the comment.\n","decidedSeverity":"medium","decidedDuplication":"Wrong modifier in `transferTokens()`"},{"file":"306.md","watson":{"name":"BugBusters"},"severity":"medium","title":"latestAnswer() has no check for round completeness #9","markdown":"BugBusters\n\nmedium\n\n# latestAnswer() has no check for round completeness #9\n\n## Summary\nNo check for round completeness could lead to stale prices and wrong price return value, or outdated price. The functions rely on accurate price feed might not work as expected, sometimes can lead to fund loss.\n\n## Vulnerability Detail\n`_createActionInfo()` call out to an oracle with `latestAnswer()` to get the price of tokens. But there is no check for round completeness.\n\nAccording to Chainlink's documentation, this function does not error if no answer has been reached but returns 0 or outdated round data. The external Chainlink oracle, which provides index price information to the system, introduces risk inherent to any dependency on third-party data sources. For example, the oracle could fall behind or otherwise fail to be maintained, resulting in outdated data being fed to the index price calculations. Oracle reliance has historically resulted in crippled on-chain systems, and complications that lead to these outcomes can arise from things as simple as network congestion.\n\nChainlink documentation:\nhttps://docs.chain.link/docs/historical-price-data/#historical-rounds\n\n## Impact\nIf there is a problem with chainlink starting a new round and finding consensus on the new value for the oracle (e.g. chainlink nodes abandon the oracle, chain congestion, vulnerability/attacks on the chainlink system) consumers of this contract may continue using outdated stale data (if oracles are unable to submit no new round is started).\n\nThis could lead to stale prices and wrong price return value, or outdated price.\n\nAs a result, the functions rely on accurate price feed might not work as expected causing wrong price feed which could sometimes lead to fund loss.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L897\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L895\n\n## Tool used\n\nManual Review\n\n## Recommendation\nValidate data feed for round completeness like below:\n\n```solidity\nfunction _createActionInfo() internal view returns(ActionInfo memory) {\n        ActionInfo memory rebalanceInfo;\n        (\n            uint80 roundID,\n            int signedPrice,\n            /*uint startedAt*/,\n            uint timeStamp,\n            uint80 answeredInRound\n        ) = strategy.collateralPriceOracle.latestAnswer();\n        //check for Chainlink oracle deviancies, force a revert if any are present. Helps prevent a LUNA like issue\n        require(signedPrice > 0, \"Negative Oracle Price\");\n        require(timeStamp >= block.timestamp - HEARTBEAT_TIME , \"Stale pricefeed\");\n        require(signedPrice < _maxPrice, \"Upper price bound breached\");\n        require(signedPrice > _minPrice, \"Lower price bound breached\");\n        require(answeredInRound >= roundID, \"round not complete\");\n\n        uint256 price = uint256(signedPrice);\n        return price;\n    }\n```","decidedSeverity":"medium","decidedDuplication":"Chainlink's latestRoundData return stale or incorrect result"},{"file":"307.md","watson":{"name":"erictee"},"severity":"medium","title":"M - wrong function name used in _setEModeCategory in AaveV3LeverageStrategyExtension.sol","markdown":"erictee\n\nmedium\n\n# M - wrong function name used in _setEModeCategory in AaveV3LeverageStrategyExtension.sol\n\n## Summary\nWrong implementation in function `_setEModeCategory` in `AaveV3LeverageStrategyExtension.sol`.\n\n## Vulnerability Detail\nThe function  `_setEModeCategory` in `AaveV3LeverageStrategyExtension.sol` is implemented wrongly. According to the parameters supplied, it is supposed to call `setAssetEModeCategory` instead of `setEModeCategory`. As a result, function cannot be called properly.\n\n## Impact\nWrong function name is used. As a result, the function cannot be called properly.\n\n## Code Snippet\n\n```Solidity\n function _setEModeCategory(uint8 _categoryId) internal {\n        bytes memory setEmodeCallData =\n            abi.encodeWithSignature(\"setEModeCategory(address,uint8)\", address(strategy.setToken), _categoryId); //@audit-issue Should be setAssetEModeCategory\n        invokeManager(address(strategy.leverageModule), setEmodeCallData);\n    }\n```\n\n[https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveV3LeverageStrategyExtension.sol#L66](https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveV3LeverageStrategyExtension.sol#L66)\n\n## Tool used\nManual Review\n\n## Recommendation\nUse `setAssetEModeCategory` instead of `setEModeCategory`.  \nMore Details: [https://docs.aave.com/developers/core-contracts/poolconfigurator](https://docs.aave.com/developers/core-contracts/poolconfigurator)","decidedSeverity":"false","decidedDuplication":"M - wrong function name used in _setEModeCategory in AaveV3LeverageStrategyExtension.sol"},{"file":"308.md","watson":{"name":"erictee"},"severity":"medium","title":"M - Chainlink pricer is using a deprecated API","markdown":"erictee\n\nmedium\n\n# M - Chainlink pricer is using a deprecated API\n\n## Summary\nM - Chainlink pricer is using a deprecated API\n\n## Vulnerability Detail\nAccording to Chainlink’s documentation, the `latestAnswer` function is deprecated. This function might suddenly stop working if Chainlink stops supporting deprecated APIs. And the old API can return stale data.\n\n## Impact\nChainlink stops supporting deprecated APIs. And the old API can return stale data.\n\n## Code Snippet\n https://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L895-L897\n\n## Tool used\nManual Review\n\n## Recommendation\nUse the latestRoundData function to get the price instead. Add checks on the return data with proper revert messages if the price is stale or the round is uncomplete.  \n[https://docs.chain.link/docs/price-feeds-api-reference/](https://docs.chain.link/docs/price-feeds-api-reference/)\n","decidedSeverity":"medium","decidedDuplication":"Deprecated oracle function `latestAnswer()` could bring fund loss"},{"file":"309.md","watson":{"name":"ShadowForce","days":56,"is_team":true,"payout":16317.49,"score":22.9570325496,"senior":false},"severity":"medium","title":"DOS set token through erc777 hook","markdown":"ShadowForce\n\nmedium\n\n# DOS set token through erc777 hook\n\n## Summary\nDOS set token through erc777 hook\n## Vulnerability Detail\nhttps://github.com/code-423n4/2022-06-notional-coop-findings/issues/168\nthe link above details a vulnerability related to erc777 hook. the issues still stands in the current iteration of the protocol.\n## Impact\nthe impact is explained well by the previous report\n> The wfCash is an erc777 token. [ERC777.sol#L376-L380](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC777/ERC777.sol#L376-L380) Users can get the control flow before sending token and after receiving tokens. This creates attack vectors that require extra caution in designing modules. Any combination of modules may lead to a possible exploit. To elaborate on the dangerousness of the re-entrancy attack, a possible scenario is presented.\n\n>Before the exploit, we first elaborate on three attack vectors:\n[DebtIssuanceModule.sol#L131-L141](https://github.com/IndexCoop/index-protocol/blob/86be7ee76d9a7e4f7e93acfc533216ebef791c89/contracts/protocol/modules/v1/DebtIssuanceModuleV2.sol#L100-L144) The issuance module would pull tokens from the sender before minting setToken.\nAssume there are three compoenents in this set. 1. CDai. 2. wfCash In the _callTokensToSend, the setToken has received cdai and the totalSupply is still the same.\n\n> nonReentrant does not protect cross-contract re-entrancy. This means, that during the issue of issuance module, users can trigger other modules' functions.\n\n>Restricted functions with onlyManagerAndValidSet modifier may be triggered by the exploiter as well. Manager of a setToken is usually a manager contract. Assume it's a multisig-wallet, the exploiter can front-run the execute transaction and replay the payload during his exploit. Note, a private transaction from flash-bot can still be front-run. Please refer to the [uncle bandit risk](https://docs.flashbots.net/flashbots-protect/rpc/uncle-bandits)\nGiven the above attack vectors, the exploiter have enough weapons to exploit the setToken at a propriate time. Note that different combination of modules may have different exploit paths. As long as the above attack vectors remain, the setToken is vulnerable.\n\n> Assume a setToken with CompoundLeverageModule, NotionalTradeModule and BasicIssuanceModule with the following positions: 1. CDAI: 100 2. wfCash-DAI 100 and totalSupply = 100. The community decides to remove the compoundLeverageModule from the set token. Since notionalTradeModule can handle cDAI, the community vote to just call removeModule to remove compoundLeverageModule. The exploiter has the time to build an exploit and wait the right timing to come.\n\n> The exploiter listen the manager multisig wallet.\nExploiter issue 10 setToken.\nDuring the _callTokensToSend of wfcash, the totalSupply = 100, CDAI = 110, wfCash-DAI = 110.\nCall sync of CompoundLeverageModule. _getCollateralPosition get _cToken.balanceOf(address(_setToken)) = 110 and totalSupply = 100 and update the DefaultUnit of CETH 1,1X.\nReplay multisig wallet's payload and remove compoundLeverageModule.\nThe setToken can no longer issue / redeem as it would raise undercollateralized error. Further, setValuer would give a pumped valuation that may cause harm to other protocols.\n## Code Snippet\nhttps://github.com/IndexCoop/index-protocol/blob/86be7ee76d9a7e4f7e93acfc533216ebef791c89/contracts/protocol/modules/v1/DebtIssuanceModuleV2.sol#L100-L144\n## Tool used\n\nManual Review\n\n## Recommendation\nthe recommendation is the same as the previous report states\n> The design choice of wfcash being an ERC777 seems unnecessary to me. Over the past two years, ERC777 leads to so many exploits. [IMBTC-UNISWAP](https://defirate.com/imbtc-uniswap-hack/) [CREAM-AMP](https://twitter.com/CreamdotFinance/status/1432249771750686721?s=20) I recommend the team using ERC20 instead.\nIf the SetToken team considers supporting ERC777 necessary, I recommend implementing protocol-wide cross-contract reentrancy prevention. Please refer to Rari-Capital. [Comptroller.sol#L1978-L2002](https://github.com/Rari-Capital/fuse-v1/blob/development/src/core/Comptroller.sol#L1978-L2002)\nNote that, Rari was [exploited](https://www.coindesk.com/business/2022/04/30/defi-lender-rari-capitalfei-loses-80m-in-hack/) given this reentrancy prevention. Simply making nonReentrant cross-contact prevention may not be enough. I recommend to setToken protocol going through every module and re-consider whether it's re-entrancy safe.","decidedSeverity":"medium","decidedDuplication":"Protocol will not work with fee on transfer tokens"},{"file":"310.md","watson":{"name":"seerether"},"severity":"high","title":"Inability to withdraw collaterals","markdown":"seerether\n\nhigh\n\n# Inability to withdraw collaterals\n\n## Summary\nThere is no explicit check for debt remaining on Aave \n## Vulnerability Detail\nBy intentionally leaving debt on Aave, an attacker can manipulate the value of the collateral assets and potentially cause losses for the SetToken or its users.\n## Impact\nIt result in financial loss for users or the protocol. If the debt is not settled properly, it may accrue additional interest or fees, leading to increased costs for the SetToken or its users. it also lead to an inconsistent state where the debt remains unpaid\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L499-L502\n## Tool used\n\nManual Review\n\n## Recommendation\nAdd the  checkDebtRemaining function  to explicitly check if there is any debt remaining on Aave before proceeding with the module initialization. Implement the logic within the checkDebtRemaining function to perform the actual debt check. The function should return true if there is no debt remaining and false otherwise.\nThe checkDebtRemaining function can utilize Aave's contract or external data provider to fetch the debt information associated with the _setToken and determine if there is any remaining debt.\nhttps://github.com/seerether/IndexCoop/blob/52817079b38660c3a2165de47d343750faa138e4/indexcoopmitigation13#L34-L41\n","decidedSeverity":"false","decidedDuplication":"Inability to withdraw collaterals"},{"file":"311.md","watson":{"name":"Vagner","days":5,"is_team":false,"payout":509.29,"score":16.3520612864,"senior":false},"severity":"medium","title":"`calculateDefaultEditPositionUnit` could revert in multiple cases which will make functions in `TradeWrapModule.sol` or `WrapModuleV2.sol` not work","markdown":"Vagner\n\nmedium\n\n# `calculateDefaultEditPositionUnit` could revert in multiple cases which will make functions in `TradeWrapModule.sol` or `WrapModuleV2.sol` not work\n\n## Summary\nThe function `calculateDefaultEditPositionUnit` from the `Position.sol` contract calculates new position units without picking up airdropped assets, but this function could revert because of an underflow in multiple occasions making most of the important function from `WrapModuleV2.sol` or `TradeModule.sol` unusable.\n## Vulnerability Detail\nAfter most of the important actions in `WrapModuleV2.sol` or `TradeModule.sol` the contract would calculate the new position units with the `calculateDefaultEditPositionUnit` by using the `balanceOf` an asset before the action, and after the action. For exemple in the `TradeModule.sol` it uses `balanceOf` the `sendToken` and `receiveToken`, before and after the trade was done https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/TradeModule.sol#L306-L316 or the `WrapModuleV2.sol` it uses the `balanceOf` the wrapped and underlying assets, before and after the wrapping was done https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/WrapModuleV2.sol#L503-L507\nThe problem occurs if in any of these cases the balances of these assets are 0, before or after since the function `calculateDefaultEditPositionUnit` substract from those balances https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/lib/Position.sol#L256-L257\nor if `totalSupply` of the specific `SetToken` is too high making the calculation `_prePositionUnit` * `_setTokenSupply` bigger than the `_preTotalNotional` which will underflow and revert. Even if, `TradeModule.sol`, uses the if statement in the function `calculateAndEditDefaultPosition` https://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/lib/Position.sol#L215-L225 which checks that the `balanceOf` after the action is greater than 0, it doesn't protect for the `receiveToken` cases, where the `balanceOf` before is lower than `balanceOf` after.\n## Impact\nThe impact is a medium one since it affects the usability of the protocol in some cases\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/lib/Position.sol#L245-L259\n## Tool used\n\nManual Review\n\n## Recommendation\nThe recommendation would be to use an If statement so in those cases the subtraction would not be made, or take special care for those cases.","decidedSeverity":"false","decidedDuplication":"`calculateDefaultEditPositionUnit` could revert in multiple cases which will make functions in `TradeWrapModule.sol` or `WrapModuleV2.sol` not work"},{"file":"312.md","watson":{"name":"BugBusters"},"severity":"high","title":"Index Coop is vulnerable to attackers sending LTV = 0 collateral tokens, supply/supplyCollateral, bor- row and liquidate operations could stop working","markdown":"BugBusters\n\nhigh\n\n# Index Coop is vulnerable to attackers sending LTV = 0 collateral tokens, supply/supplyCollateral, bor- row and liquidate operations could stop working\n\n## Summary\nIf a A-Token with LTV==0 is sent to index coop by a malicious user, all the functionalities will halt.\n## Vulnerability Detail\nWhen an AToken has LTV = 0, Aave restricts the usage of some operations. In particular, if the user\nowns at least one AToken as collateral that has LTV = 0, these operations could revert\n1) Withdraw: if the asset withdrawn is collateral, the user is borrowing something, the operation will revert if the\nwithdrawn collateral is an AToken with LTV > 0\n2) Transfer: if the from is using the asset as collateral, is borrowing something and the asset transferred is an\nAToken with LTV > 0 the operation will revert\n3) Set the reserve of an AToken as not collateral: if the AToken you are trying to set as non-collateral is an\nAToken with LTV > 0 the operation will revert\n\nIn the attack scenario, the bad actor could simply supply an underlying that is associated with an LTV = 0 AToken\nand transfer it to the Index Coop contract. If the victim does not own any balance of the asset, it will be set as collateral\nand the victim will suffer from all the side effects previously explained.\nWhile a \"normal\" Aave user could simply withdraw, transfer or set that asset as non-collateral, Index Coop, with the\ncurrent implementation, cannot do it. Because of the impossibility to remove from the Index Coop wallet the \"poisoned\nAToken\", all the mechanics of index coop will break.\n\n## Impact\nAbove scenerio will have the following impact\n1. User will not be able to withdraw, hence cannot de-leverage\n2. User will not be able to borrow any asset, hence cannot leverage.\n3. Whole mechanism will break, there could be unexpected, liquidation.\n4. User will not be able to withdraw if they wanted to.\n\nIn short whole system will be doomed\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1-L1274\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L1-L1151\n\n## Tool used\n\nManual Review\n\n## Recommendation\nOne probable solution could be to devise a mechanism to remove such poisoned token, probably through the DAO to prevent the centralization risk","decidedSeverity":"false","decidedDuplication":"Index Coop is vulnerable to attackers sending LTV = 0 collateral tokens, supply/supplyCollateral, bor- row and liquidate operations could stop working"},{"file":"313.md","watson":{"name":"lemonmon","days":28,"is_team":false,"payout":46232.85,"score":159.6616526375,"senior":true},"severity":"medium","title":"MethodologySettings not validated correctly in AaveLeverageStrategyExtension","markdown":"lemonmon\n\nmedium\n\n# MethodologySettings not validated correctly in AaveLeverageStrategyExtension\n\n## Summary\n\nIn the `AaveLeverageStrategyExtension` contract the MethodolgySettings are not validated correctly in the function `AaveLeverageStrategyExtension._validateNonExchangeSettings()`, especially the `methodology.targetLeverageRatio` is not validated adequatly. This can  lead to a DOS condition when calling the `AaveLeverageStrategyExtension.engage()` function, which always reverts if the `currentLeverageRatio` is bigger than the `methodology.targetLeverageRatio`.\n\n## Vulnerability Detail\n\nThe function `_calculateChunkRebalanceNotional()` always reverts if `_newLeverageRatio` is smaller than `_leverageInfo.currentLeverageRatio`, when `_isLever` is true. The revert is triggered by the `SafeMath.sub()` function, if `a` (`_newLeverageRatio`) is smaller than `b` (`_leverageInfo.currentLeverageRatio`).\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1066\n\nhttps://github.com/ConsenSysMesh/openzeppelin-solidity/blob/d5f06ab32ff40bf447fa34bcdb997b54e2499ee0/contracts/math/SafeMath.sol#L36\n\nThis revert can happen, when the `engage` function is calling the `_calculateChunkRebalanceNotional` function here:\n\nhttps://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/adapters/AaveLeverageStrategyExtension.sol#L272-L275\n\nIn the above code snippet, `methodology.targetLeverageRatio` is passed as the `_newLeverageRatio` parameter to the `_calculateChunkRebalanceNotional` function.\n\nThere is no validation that `methodology.targetLeverageRatio` is bigger or equal to the value of `leverageInfo.currentLeverageRatio` which is set to `PreciseUnitMath.preciseUnit()`.\n\nThat means that if `methodology.targetLeverageRatio` is smaller than `PreciseUnitMath.preciseUnit()` (`currentLeverageRatio`), the function `AaveLeverageStrategyExtension.engage()` will always revert.\n\nhttps://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/adapters/AaveLeverageStrategyExtension.sol#L265\n\n## Impact\n\nThe function `AaveLeverageStrategyExtension.engage()` always reverts if `methodology.targetLeverageRatio` is smaller than `PreciseUnitMath.preciseUnit()`.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1066\n\nhttps://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/adapters/AaveLeverageStrategyExtension.sol#L272-L275\n\nhttps://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/adapters/AaveLeverageStrategyExtension.sol#L265\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nConsider adding additional checks in the function `AaveLeverageStrategyExtension._validateNonExchangeSettings()` in order to validate that `methodology.targetLeverageRatio` is bigger or equal than 1 (`PreciseUnitMath.preciseUnit()`).\n\n```solidity\n920        require (\n921            _methodology.targetLeverageRatio >= PreciseUnitMath.preciseUnit()\n922            \"Must be valid target leverage ratio\"\n923        );\n```\n\nOr:\n\nIf the `methodology.targetLeverageRatio` is allowed to be less than 1 (`PreciseUnitMath.preciseUnit()`), then the `_isLever` param in the function call on line 275 should not be always true, but should be set dynamically instead - example:\n\n```solidity\n275       ) = _calculateChunkRebalanceNotional(leverageInfo, methodology.targetLeverageRatio, isLever); // <-- @audit set isLever param dynamically.\n```","decidedSeverity":"medium","decidedDuplication":"MethodologySettings not validated correctly in AaveLeverageStrategyExtension"},{"file":"314.md","watson":{"name":"ShadowForce","days":56,"is_team":true,"payout":16317.49,"score":22.9570325496,"senior":false},"severity":"medium","title":"The protocol does not compatible with token such as USDT because of the Approval Face Protection","markdown":"ShadowForce\n\nmedium\n\n# The protocol does not compatible with token such as USDT because of the Approval Face Protection\n\n## Summary\n\nThe protocol does not compatible with token such as USDT because of the Approval Face Protection\n\n## Vulnerability Detail\n\nthe protocol is intended to interact with any ERC20 token and USDT is a common one\n\n> Q: Which ERC20 tokens do you expect will interact with the smart contracts?\nThe protocol expects to interact with any ERC20.\n\n> Individual SetToken's should only interact with ERC20 chosen by the SetToken manager.\n\nwhen doing the deleverage\n\nhttps://github.com/IndexCoop/index-protocol/blob/86be7ee76d9a7e4f7e93acfc533216ebef791c89/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L313\n\nfirst, we construct the deleverInfo\n\n```solidity\nActionInfo memory deleverInfo = _createAndValidateActionInfo(\n\t\t_setToken,\n\t\t_collateralAsset,\n\t\t_repayAsset,\n\t\t_redeemQuantityUnits,\n\t\t_minRepayQuantityUnits,\n\t\t_tradeAdapterName,\n\t\tfalse\n\t);\n```\n\nthen we withdraw from the lending pool, execute trade and repay the borrow token\n\n```solidity\n_withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);\n\n        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);\n\n        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);\n```\n\nthis is calling _repayBorrow\n\n```solidity\n/**\n * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.\n */\nfunction _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n\t_setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);\n\t_setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);\n}\n```\n\nthe trade received (quantity - the protocol fee) is used to repay the debt\n\nbut the required debt to be required is the (borrowed amount + the interest rate)\n\nsuppose the only debt that needs to be repayed is 1000 USDT\n\ntrade received (quantity - the protocol) fee is 20000 USDT\n\nonly 1000 USDT is used to repay the debt\n\nbecause when repaying, the paybackAmount is only the debt amount\n\nhttps://github.com/aave/aave-v3-core/blob/29ff9b9f89af7cd8255231bc5faf26c3ce0fb7ce/contracts/protocol/libraries/logic/BorrowLogic.sol#L204\n\n```solidity\nuint256 paybackAmount = params.interestRateMode == DataTypes.InterestRateMode.STABLE\n  ? stableDebt\n  : variableDebt;\n```\n\nthen when burning the variable debt token\n\nhttps://github.com/aave/aave-v3-core/blob/29ff9b9f89af7cd8255231bc5faf26c3ce0fb7ce/contracts/protocol/libraries/logic/BorrowLogic.sol#L224\n\n```solidity\nreserveCache.nextScaledVariableDebt = IVariableDebtToken(\n\treserveCache.variableDebtTokenAddress\n  ).burn(params.onBehalfOf, paybackAmount, reserveCache.nextVariableBorrowIndex);\n```\n\nonly the \"payback amount\", which is 1000 USDT is transferred to pay the debt,\n\nthe excessive leftover amount is (20000 USDT - 1000 USDT) = 19000 USDT\n\nbut if we lookback into the repayBack function\n\n```solidity\n/**\n * @dev Invoke repay from SetToken using AaveV2 library. Burns DebtTokens for SetToken.\n */\nfunction _repayBorrow(ISetToken _setToken, ILendingPool _lendingPool, IERC20 _asset, uint256 _notionalQuantity) internal {\n\t_setToken.invokeApprove(address(_asset), address(_lendingPool), _notionalQuantity);\n\t_setToken.invokeRepay(_lendingPool, address(_asset), _notionalQuantity, BORROW_RATE_MODE);\n}\n```\n\nthe approved amount is 20000 USDT, but only 1000 USDT approval limit is used, we have 19000 USDT approval limit left\n\naccording to\n\nhttps://github.com/d-xo/weird-erc20#approval-race-protections\n\n> Some tokens (e.g. OpenZeppelin) will revert if trying to approve the zero address to spend tokens (i.e. a call to approve(address(0), amt)).\n\n> Integrators may need to add special cases to handle this logic if working with such a token.\n\nUSDT is such token that subject to approval race condition, without approving 0 first, the second approve after first repay will revert\n\n## Impact\n\nsecond and following repay borrow will revert if the ERC20 token is subject to approval race condition\n\n## Code Snippet\n\nhttps://github.com/IndexCoop/index-protocol/blob/86be7ee76d9a7e4f7e93acfc533216ebef791c89/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L313\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nApproval 0 first","decidedSeverity":"medium","decidedDuplication":"AmmModule will not work with usdt"},{"file":"315.md","watson":{"name":"hildingr"},"severity":"medium","title":"Delevering can be blocked by other positions","markdown":"hildingr\n\nmedium\n\n# Delevering can be blocked by other positions\n\n## Summary\n\nAAVE3 introduces new conditions on when collateral can be removed. One new condition is that collateral withdrawal is blocked if any other collateral token's LTV has been set to 0.\n\nThis introduces a scenario where a AaveLeverageExtension can be blocked from delevering. This was not an issue with AAVE2 since this constraint did not exist.\n\n## Vulnerability Detail\n\nWhen a collateral's LTV is set to 0 on AAVE3 all other collateral are blocked from withdrawal until that token is completely removed.\n\nA separate component in a SetToken can therefore block the Aave3LeverageStrategyExtension from withdrawing collateral.\n\nIt i always necessary to withdraw collateral to delever in the Aave3LeverageStrategyExtension since the `delever()` function in Aave3LeverageModule always withdraws collateral to repay debt. \n\nIf we can not withdraw collateral we are blocked from delevering until the other component has fully been withdrawn. \n\n## Impact\n\nNot being able to withdraw collateral puts the leverage position at significant risk of liquidation since the safety functionality to delever through the `AaveLeverageStrategyExtension#ripcord()` and  `AaveLeverageStrategyExtension#disengage()` is blocked.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L313-L338\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nA  solution that guarantees that delevering can always happen requires a separate safety feature similar to the ripcord that does not rely on withdrawing collateral.\n\nThis could be done by giving anybody the ability to delever by directly transferring tokens to repay the debt and receiving payment in terms of minted SetTokens in proportion to how much was repaid + a bonus fee. The NAV for users would be intact other than a fee. This would only be callable in rare occasions, similar to he ripcord.\n\nI also recommend that a note is added to the documentation that states that SetTokens with multiple positions with AAVE3 collateral introduce a new risk for leverage positions.","decidedSeverity":"false","decidedDuplication":"Delevering can be blocked by other positions"},{"file":"316.md","watson":{"name":"ShadowForce","days":56,"is_team":true,"payout":16317.49,"score":22.9570325496,"senior":false},"severity":"medium","title":"0 value is not allowed","markdown":"ShadowForce\n\nmedium\n\n# 0 value is not allowed\n\n## Summary\nAAVE does not allow 0 value transfer.\n## Vulnerability Detail\n```solidity\nfunction lever(\n        ISetToken _setToken,\n        IERC20 _borrowAsset,\n        IERC20 _collateralAsset,\n        uint256 _borrowQuantityUnits,\n        uint256 _minReceiveQuantityUnits,\n        string memory _tradeAdapterName, // exchange name\n        bytes memory _tradeData\n    )\n        external\n        nonReentrant\n        onlyManagerAndValidSet(_setToken)\n    {\n        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from \n        // collateral asset\n        ActionInfo memory leverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            _borrowQuantityUnits,\n            _minReceiveQuantityUnits,\n            _tradeAdapterName,\n            true\n        );\n\n        // @audit\n        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);\n\n        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);\n\n        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);\n\n        _updateLeverPositions(leverInfo, _borrowAsset);\n\n        emit LeverageIncreased(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            leverInfo.exchangeAdapter,\n            leverInfo.notionalSendQuantity,\n            postTradeCollateralQuantity,\n            protocolFee\n        );\n    }\n```\nThe snippet above has no validation to ensure token amount passed in is not 0. The reason this is needed is because AAVE does not support 0 value. Transaction will always revert with a 0  value\n## Impact\nuse of a 0 value will cause the entire tx to revert. deposit, borrow, and withdraw functions will all revert\n## Code Snippet\nhttps://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/external/contracts/set/AaveLeverageModule.sol#L249-L295\n## Tool used\n\nManual Review\n\n## Recommendation\nwe recommend the protocol add a check to ensure passed in value can never be a 0 value","decidedSeverity":"false","decidedDuplication":"0 value is not allowed"},{"file":"317.md","watson":{"name":"BugBusters"},"severity":"medium","title":"Missing checks for whether Arbitrum Sequencer is active","markdown":"BugBusters\n\nmedium\n\n# Missing checks for whether Arbitrum Sequencer is active\n\n## Summary\nWhen utilizing Chainlink in L2 chains like Arbitrum, it's important to ensure that the prices provided are not falsely perceived as fresh, even when the sequencer is down. This vulnerability could potentially be exploited by malicious actors to gain an unfair advantage.\n\n## Vulnerability Detail\nIf the Arbitrum Sequencer goes down, the oracle data won't be updated, and can therefore become basic. However, users can continue to interact with the protocol directly through contracts\nAs a result, users may be able to use the protocol when the oracle feed is basic. This can cause a lot of problems, but as a simple example:\nA user has an account with 100 tokens, each worth 1 ETH, and no loans\nSequencer Arbitrum temporarily shuts down\nOn the way down, the price of each token drops to 0.5 ETH\nA user's current account value is 50 ETH, so they should be able to borrow a maximum of 200 ETH to keep the account healthy ((200 + 50) / 200 = 1.2)\nDue to the floor price the protocol published they borrowed 400 ETH ( (400 + 100) / 400 = 1.2\n\n## Impact\nStale prices, e.g. if USDC were to de-peg while the sequencer is offline, stale price is used and can result in false liquidation or over-borrowing.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L895-L898\n\n## Tool used\n\nManual Review\n\n## Recommendation\nUse sequencer oracle to determine whether the sequencer is offline or not, and don't allow orders to be executed while the sequencer is offline.","decidedSeverity":"medium","decidedDuplication":"Missing checks for whether Arbitrum Sequencer is active"},{"file":"318.md","watson":{"name":"hildingr"},"severity":"medium","title":"onlyEOA() modifier could be bypassed in the future due to EIP3074","markdown":"hildingr\n\nmedium\n\n# onlyEOA() modifier could be bypassed in the future due to EIP3074\n\n## Summary\n\nThe onlyEOA() modifier is used in the AaveLeverageStrategyExtension to ensure that calls are not made from smart contracts. With EIP 3074 this would not function as expected.\n\nThis issue has been reported in previous reports on Sherlock. See [this](https://github.com/sherlock-audit/2023-02-blueberry-judging/issues/21) as a reference.\n\n## Vulnerability Detail\nIn AaveLeverageStrategyExtension the following modifier is used\n\n```solidity\n    /**\n     * Throws if caller is a contract, can be used to stop flash loan and sandwich attacks\n     */\n    modifier onlyEOA() {\n        require(msg.sender == tx.origin, \"Caller must be EOA Address\");\n        _;\n    }\n```\n\nAs the comments above explain, this is to protect from sandwich and flashloan attacks. \n\nThis  modifier protects `AaveLeverageStrategyExtension#rebalance()`, `AaveLeverageStrategyExtension#uterateRebalance()` and `AaveLeverageStrategyExtension#ripcord`.\n\nWith [EIP3074](https://eips.ethereum.org/EIPS/eip-3074#abstract) the `tx.origin = msg.sender` check will not guarantee that the caller is an EOA since the control of an EOA can be delegated to a smart contract.\n\n## Impact\n\n`onlyEOA()` could be bypassed in the future which means that the protection against sandwich attacks and flashloan attacks is not functioning. \n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/lib/BaseExtension.sol#L59-L62\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L304\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L338\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L376\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse OpenZeppelin's `isContract()` see their [documentation](https://eips.ethereum.org/EIPS/eip-3074#abstract) for details.","decidedSeverity":"medium","decidedDuplication":"onlyEOA modifier that ensures call is from EOA might not hold true with the eip 3074"},{"file":"319.md","watson":{"name":"warRoom","days":27,"is_team":true,"payout":801.53,"score":17.6963223486,"senior":false},"severity":"medium","title":"Division before multiplication incurs unnecessary precision loss","markdown":"warRoom\n\nmedium\n\n# Division before multiplication incurs unnecessary precision loss\n\n## Summary\nDivision before multiplication incurs unnecessary precision loss. \n\n## Vulnerability Detail\nThere are some operation used in the below code snippet that incurs unnecessary precision loss because of division before multiplication. \nIn certain functions `_calculateChunkRebalanceNotional` and `_calculateMinRepayUnits`. \n1. Below code snippet first divides collateral price with borrow price and then multiplies by slippage tolerance. This could incur precision loss especially when slippage is not set by user arguement, which could lead to transaction being failed.\n```solidity\n    function _calculateMinRepayUnits(uint256 _collateralRebalanceUnits, uint256 _slippageTolerance, ActionInfo memory _actionInfo) internal pure returns (uint256) {\n        return _collateralRebalanceUnits\n            .preciseMul(_actionInfo.collateralPrice)\n            .preciseDiv(_actionInfo.borrowPrice)\n            .preciseMul(PreciseUnitMath.preciseUnit().sub(_slippageTolerance));\n    }\n```\n\n2. Similarly, totalRebalanceNotional is calculated with division first and multiplication later. \n```solidity\n        uint256 totalRebalanceNotional = leverageRatioDifference.preciseDiv(_leverageInfo.currentLeverageRatio).preciseMul(_leverageInfo.action.collateralBalance);\n\n```\n\n\n## Impact\nUnnecessary precision loss. \n\n## Code Snippet\nhttps://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/adapters/AaveLeverageStrategyExtension.sol#L1147-L1152\nhttps://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/adapters/AaveLeverageStrategyExtension.sol#L1068\n\n## Tool used\n\nManual Review\n\n## Recommendation\nAlmost all the codebase in scope is following multiplication before division. Hence recommended  to do the same.  ","decidedSeverity":"medium","decidedDuplication":"division before multiplication may result in truncation of result"},{"file":"320.md","watson":{"name":"Angry_Mustache_Man"},"severity":"medium","title":"Remaining collateral assets get's stuck","markdown":"Angry_Mustache_Man\n\nmedium\n\n# Remaining collateral assets get's stuck\n\n## Summary\nIn AaveV3LeverageModule.sol , while removing the ability of assets to be collateral through `removeCollateralAssets` , it is never checked whether there is a balance of the particular asset in the contract.\n## Vulnerability Detail\nWhile removing borrow assets ,  we could see there is a condition - \n```solidity\n require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, \"VDR\");\n```\nwhich ensures that there is no balance of `borrowAsset` remaining in contract, but there is no such condition while removing collateral assets, preventing those assets to be used as collateral again, leading to temporary lockage of those assets . \n## Impact\nTemporary lockage of assets.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/AaveV3LeverageModule.sol#L637-#L649\n## Tool used\n\nManual Review\n\n## Recommendation\nReplicate the condition applied in `removeBorrowAssets` for `removeCollateralAssets`.","decidedSeverity":"false","decidedDuplication":"Remaining collateral assets get's stuck"},{"file":"321.md","watson":{"name":"hildingr"},"severity":"medium","title":"Operator is blocked when sequencer is down on Arbitrum","markdown":"hildingr\n\nmedium\n\n# Operator is blocked when sequencer is down on Arbitrum\n\n## Summary\nWhen the sequencer is down on Arbitrum state changes can still happen on L2 by passing them from L1 through the Delayed Inbox.\n\nUsers can still interact with the Index protocol but due to how Arbitrum address aliasing functions the operator will be blocked from calling onlyOperator().\n\n## Vulnerability Detail\n\nThe `msg.sender` of a transaction from the Delayed Inbox is aliased:\n\n```solidity\nL2_Alias = L1_Contract_Address + 0x1111000000000000000000000000000000001111\n```\n\nAll functions with the `onlyOperator()` modifier are therefore blocked when the sequencer is down.\n\nThe issue exists for all modifiers that are only callable by specific EOAs. But the operator of the Aave3LeverageStrategyExtension is the main security risk.\n\n## Impact\n\nThe operator has roles that are vital for the safety of the protocol. Re-balancing and issuing/redeeming can still be done when the sequencer is down it is therefore important that the operator call the necessary functions to operate the protocol when the sequencer is down. \n\n`disengage()` is an important safety function that the operator should always have access especially when the protocol is still in accessible to other users. Changing methodology and adding/removing exchanges are also important for the safety of the protocol. \n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/manager/BaseManagerV2.sol#L113-L116\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nChange the `onlyOperator()` to check if the address is the aliased address of the operator.","decidedSeverity":"medium","decidedDuplication":"Missing checks for whether Arbitrum Sequencer is active"},{"file":"322.md","watson":{"name":"0xpinky"},"severity":"high","title":"DebtIssuanceModule.sol : `removeModule` will not clear the mapping.","markdown":"0xpinky\n\nhigh\n\n# DebtIssuanceModule.sol : `removeModule` will not clear the mapping.\n\n## Summary\n\n`issuanceSettings` storage data will not be cleared completely since the structure has the mapping inside.\n\n## Vulnerability Detail\n\n`DebtIssuanceModule.sol` has the `removeModule` which will clear the storage data of `issuanceSettings`\n\n    function removeModule() external override {\n        require(issuanceSettings[ISetToken(msg.sender)].moduleIssuanceHooks.length == 0, \"Registered modules must be removed.\");\n        delete issuanceSettings[ISetToken(msg.sender)];\n    }\n\nissuanceSettings is map of `mapping(ISetToken => IssuanceSettings) public issuanceSettings;`\n\nwhen we look at the `IssuanceSettings` structure, it has the following elements.\n\n    struct IssuanceSettings {\n        uint256 maxManagerFee;                          // Max issue/redeem fee defined on instantiation\n        uint256 managerIssueFee;                        // Current manager issuance fees in precise units (10^16 = 1%)\n        uint256 managerRedeemFee;                       // Current manager redeem fees in precise units (10^16 = 1%)\n        address feeRecipient;                           // Address that receives all manager issue and redeem fees\n        IManagerIssuanceHook managerIssuanceHook;       // Instance of manager defined hook, can hold arbitrary logic\n        address[] moduleIssuanceHooks;                  // Array of modules that are registered with this module\n        mapping(address => bool) isModuleHook;          // Mapping of modules to if they've registered a hook\n    }\n\nAs per solidity documentation, delete will not clear the memory of map which is inside the struct.\n\nhttps://docs.soliditylang.org/en/latest/types.html#delete\n\nso, if struct is deleted, the memory of map will still persist.\n\n`IssuanceSettings`   has the following map - `mapping(address => bool) isModuleHook;`\n\nSo, in the issue case, the mapping will not be reset when deleting the struct.\n\n## Impact\n\nStale data will not be cleared properly. This might a problem when the isModuleHook is removed due to some reason. but still it has the valid state.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModule.sol#L335-L338\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAfter deleting the struct, delete the map separately.\n","decidedSeverity":"false","decidedDuplication":"DebtIssuanceModule.sol : `removeModule` will not clear the mapping."},{"file":"323.md","watson":{"name":"hildingr"},"severity":"medium","title":"Oracle Price miss matched when E-mode uses single oracle","markdown":"hildingr\n\nmedium\n\n# Oracle Price miss matched when E-mode uses single oracle\n\n## Summary\n\nAAVE3 can turn on single oracle use on any E-mode category. When that is done collateral and the borrowed assets will be valued based on a single oracle price. When this is done the prices used in AaveLeverageStrategyExtension can differ from those used internally in AAVE3.\n\nThis can lead to an increased risk of liquidation and failures to re-balance properly.\n\n## Vulnerability Detail\nThere is currently no accounting for single oracle use in the AaveLeverageStragyExtension, if AAVE3 turns it on the extension will simply continue using its current oracles without accounting for the different prices.\n\nWhen re-balancing the following code calculate the `netBorrowLimit`/`netRepayLimit`:\n```solidity\n\n        if (_isLever) {\n            uint256 netBorrowLimit = _actionInfo.collateralValue\n                .preciseMul(maxLtvRaw.mul(10 ** 14))\n                .preciseMul(PreciseUnitMath.preciseUnit().sub(execution.unutilizedLeveragePercentage));\n\n            return netBorrowLimit\n                .sub(_actionInfo.borrowValue)\n                .preciseDiv(_actionInfo.collateralPrice);\n        } else {\n            uint256 netRepayLimit = _actionInfo.collateralValue\n                .preciseMul(liquidationThresholdRaw.mul(10 ** 14))\n                .preciseMul(PreciseUnitMath.preciseUnit().sub(execution.unutilizedLeveragePercentage));\n\n            return _actionInfo.collateralBalance\n                .preciseMul(netRepayLimit.sub(_actionInfo.borrowValue)) \n                .preciseDiv(netRepayLimit);\n        \n```\n\nThe `_actionInfo.collateralValue` and `_adminInfo.borrowValue` are `_getAndValidateLeverageInfo()` where they are both retrieved based on the current set chainlink oracle.\n\nWhen E-mode uses a single oracle price a de-pegging of one of the assets will lead to incorrect values of `netBorrowLimit`  and `netRepayLimit` depending on which asset is de-pegging.\n\n`collateralValue` or `borrowValue` can be either larger or smaller than how they are valued internally in AAVE3.\n\n## Impact\n\nWhen Levering \n\nIf `collateralValue` is to valued higher than internally in AAVE3 OR If `borrowValue` is to valued lower than internally in AAVE3:\n\nThe `netBorrowLimit` is larger than it should be we are essentially going to overriding `execute.unutilizedLeveragePercentage` and attempting to borrow more than we should. \n\nIf `collateralValue` is valued lower than internally in AAVE3 OR If `borrowValue` is to valued higher than internally in AAVE3:\n\nThe `netBorrowLimit` is smaller than it should be, we are not borrowing as much as we should. Levering up takes longer.\n\nWhen Delevering\n\nIf `collateralValue` is to valued higher than internally in AAVE3 OR If `borrowValue` is to valued lower than internally in AAVE3:\n\nWe will withdraw more collateral and repay more than specified by `execution.unutilizedLeveragePercentage`. \n\nIf `collateralValue` is  valued lower than internally in AAVE3 OR If `borrowValue` is to valued higher than internally in AAVE3:\n\nWe withdraw less and repay less debt than we should. This means that both `ripcord()` and `disengage()` are not functioning as they, they will not delever as fast they should. We can look at it as `execution.unutilizedLeveragePercentage` not being throttled. \n\nThe above consequences show that important functionality is not working as expected. \"overriding\" `execution.unutilizedLeveragePercentage` is a serious safety concern.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1095-L1119\n## Tool used\n\nManual Review\n\n## Recommendation\n\nAave3LeverageStrategyExtension should take single oracle usage into account. `_calcualteMaxBorrowCollateral` should check if there is a discrepancy and adjust such that the `execute.unutilizedLeveragePercentage` safety parameter is honored.","decidedSeverity":"false","decidedDuplication":"Oracle Price miss matched when E-mode uses single oracle"},{"file":"324.md","watson":{"name":"BugBusters"},"severity":"high","title":"Wrong modifier is being used in `transferTokens()` function","markdown":"BugBusters\n\nhigh\n\n# Wrong modifier is being used in `transferTokens()` function\n\n## Summary\n`onlyExtension` modifier is being used instead of `onlyOperator` modifier in transferTokens() function\n## Vulnerability Detail\nIn `BaseManagerV2.sol` `transferTokens()` function incorrect modifier is being used, according to the comments above the function this function is OPERATOR ONLY but if we look at the code and the modifier which is being used is `onlyExtension` instead of `onlyOperator` so wrong person will be able to call the function and will be able to transfer the funds which could result in unintended consequences and even loss of funds in worse case\n\n## Impact\nUnauthorized person will be able to call this function which could result in unintended consequences and even loss of funds in some case scenarios.\n \n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/manager/BaseManagerV2.sol#L318\n\n## Tool used\n\nManual Review\n\n## Recommendation\nMake sure that you are using the correct modifier as according with natspec","decidedSeverity":"medium","decidedDuplication":"Wrong modifier in `transferTokens()`"},{"file":"325.md","watson":{"name":"MohammedRizwan"},"severity":"medium","title":"Transaction revert if the Token does not support 0 value transfer","markdown":"MohammedRizwan\n\nmedium\n\n# Transaction revert if the Token does not support 0 value transfer\n\n## Summary\nTransaction revert if the Token does not support 0 value transfer\n\n## Vulnerability Detail\n## Impact\nIn transferTokens(), Transaction revert if the Token does not support 0 value transfer when transferring tokens to destination address.\n\nIn BaseManagerV2.sol, transferTokens() function is given by,\n\n```solidity\nFile: contracts/manager/BaseManagerV2.sol\n\n318    function transferTokens(address _token, address _destination, uint256 _amount) external onlyExtension {\n319       IERC20(_token).safeTransfer(_destination, _amount);\n320    }\n```\nThe transferTokens() function provides the ability for the owner to recover ANY tokens accidentally sent to this contract. This token can be any token which will be accidentally sent to contract address like it can be LEND token. Let's consider the LEND token is accidentally transferred to the contract. The issue is at L-319, if the amount is 0, the code would revert if the ERC20 token does not support 0 value transfer.\n\nAccording to https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers\n\nSome tokens (e.g. LEND) revert when transferring a zero value amount.\n\n## Code Snippet\nhttps://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/manager/BaseManagerV2.sol#L318-L320\n\n## Tool used\nManual Review\n\n## Recommendation\nRecommend to check if the amount is 0 before performing transfer in transferTokens() function.\n\n```solidity\nFile: contracts/manager/BaseManagerV2.sol\n\n    function transferTokens(address _token, address _destination, uint256 _amount) external onlyExtension {\n+    if (_amount != 0 ) {\n      IERC20(_token).safeTransfer(_destination, _amount);\n+    }\n    }\n```","decidedSeverity":"false","decidedDuplication":"Transaction revert if the Token does not support 0 value transfer"},{"file":"326.md","watson":{"name":"hildingr"},"severity":"high","title":"Possible to redeem tokens without repaying debt.","markdown":"hildingr\n\nhigh\n\n# Possible to redeem tokens without repaying debt.\n\n## Summary\n\nIn the DebtIssuanceModule, users have the ability to redeem SetTokens without repaying any debt if certain conditions a met. \n\nThe vulnerability arises when a SetToken holds debt in a token that fails silently during a standard `transferFrom()` call. In such cases, if the SetToken also employs the same token in a default position, a user can redeem their SetToken without fulfilling the debt repayment requirement. Instead, they can utilize the tokens owned by the SetToken in a default position.\n\n## Vulnerability Detail\n\nSome tokens fail silently on a standard `transferFrom()`. A user could therefore pass the following code without reverting:\n\n```solidity\n                    transferFrom(\n                        IERC20(component),\n                        msg.sender,\n                        address(_setToken),\n                        componentQuantity\n                    )\n\t\t\t\t\t_executeExternalPositionHooks(_setToken, _quantity, IERC20(component), false, false)\n```\n\nThis code is used in `_resolveDebtPosition()` to transfer tokens from the user to the SetToken to repay a debt.\n\nThe `_executeExternalPositionHook()` can also be successfully passed if the SetToken uses the same token in a default position in which case those tokens will be used to repay the debt.\n\n## Impact\n\nA user can steal from other users since they can redeem their tokens for collateral tokens without paying any debt. The amount they are able to steal is based on how large the default position of the same token is. SetTokens can be complex and hold significant positions, this issue could lead to significant loss based on the SetToken configuration.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-protocol/contracts/protocol/modules/v1/DebtIssuanceModule.sol#L581-L612\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse OpenZeppelin's `safeTransferFrom()`\n","decidedSeverity":"false","decidedDuplication":"Possible to redeem tokens without repaying debt."},{"file":"327.md","watson":{"name":"ShadowForce","days":56,"is_team":true,"payout":16317.49,"score":22.9570325496,"senior":false},"severity":"high","title":"Wrongly assume chainlink oracle decimal is always 8","markdown":"ShadowForce\n\nhigh\n\n# Wrongly assume chainlink oracle decimal is always 8\n\n## Summary\n\nWrongly assume chainlink oracle decimal is 8\n\n## Vulnerability Detail\n\nvery important\n\n```solidity\nstruct ActionInfo {\n\tuint256 collateralBalance;                      // Balance of underlying held in Aave in base units (e.g. USDC 10e6)\n\tuint256 borrowBalance;                          // Balance of underlying borrowed from Aave in base units\n\tuint256 collateralValue;                        // Valuation in USD adjusted for decimals in precise units (10e18)\n\tuint256 borrowValue;                            // Valuation in USD adjusted for decimals in precise units (10e18)\n\tuint256 collateralPrice;                        // Price of collateral in precise units (10e18) from Chainlink\n\tuint256 borrowPrice;                            // Price of borrow asset in precise units (10e18) from Chainlink\n\tuint256 setTotalSupply;                         // Total supply of SetToken\n}\n```\n\nand\n\n```solidity\nstruct ContractSettings {\n\tISetToken setToken;                             // Instance of leverage token\n\tILeverageModule leverageModule;                 // Instance of Aave leverage module\n\tIProtocolDataProvider aaveProtocolDataProvider; // Instance of Aave protocol data provider\n\tIChainlinkAggregatorV3 collateralPriceOracle;   // Chainlink oracle feed that returns prices in 8 decimals for collateral asset\n\tIChainlinkAggregatorV3 borrowPriceOracle;       // Chainlink oracle feed that returns prices in 8 decimals for borrow asset\n\tIERC20 targetCollateralAToken;                  // Instance of target collateral aToken asset\n\tIERC20 targetBorrowDebtToken;                   // Instance of target borrow variable debt token asset\n\taddress collateralAsset;                        // Address of underlying collateral\n\taddress borrowAsset;                            // Address of underlying borrow asset\n\tuint256 collateralDecimalAdjustment;            // Decimal adjustment for chainlink oracle of the collateral asset. Equal to 28 - collateralDecimals (10^18 * 10^18 / 10^decimals / 10^8)\n\tuint256 borrowDecimalAdjustment;                // Decimal adjustment for chainlink oracle of the borrowing asset. Equal to 28 - borrowDecimals (10^18 * 10^18 / 10^decimals / 10^8)\n}\n```\n\nwe know \n\nuint256 collateralValue and uint256 borrowValue\n\nare both in 10e18\n\nand we have \n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L889\n\n```solidity\nuint256 collateralDecimalAdjustment;            // Decimal adjustment for chainlink oracle of the collateral asset. Equal to 28 - collateralDecimals (10^18 * 10^18 / 10^decimals / 10^8)\n\n\tuint256 borrowDecimalAdjustment;                // Decimal adjustment for chainlink oracle of the borrowing asset. Equal to 28 - borrowDecimals (10^18 * 10^18 / 10^decimals / 10^8)\n```\n\nthe decimal adjustment is (28 - decimal of token)\n\nok now let us proceed\n\nthis is important\n\n```solidity\n  function _createActionInfo() internal view returns(ActionInfo memory) {\n        ActionInfo memory rebalanceInfo;\n\n        // Calculate prices from chainlink. Chainlink returns prices with 8 decimal places, but we need 36 - underlyingDecimals decimal places.\n        // This is so that when the underlying amount is multiplied by the received price, the collateral valuation is normalized to 36 decimals. \n        // To perform this adjustment, we multiply by 10^(36 - 8 - underlyingDecimals)\n        int256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\n        rebalanceInfo.collateralPrice = rawCollateralPrice.toUint256().mul(10 ** strategy.collateralDecimalAdjustment);\n        int256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer();\n        rebalanceInfo.borrowPrice = rawBorrowPrice.toUint256().mul(10 ** strategy.borrowDecimalAdjustment);\n\n        rebalanceInfo.collateralBalance = strategy.targetCollateralAToken.balanceOf(address(strategy.setToken));\n        rebalanceInfo.borrowBalance = strategy.targetBorrowDebtToken.balanceOf(address(strategy.setToken));\n        rebalanceInfo.collateralValue = rebalanceInfo.collateralPrice.preciseMul(rebalanceInfo.collateralBalance);\n        rebalanceInfo.borrowValue = rebalanceInfo.borrowPrice.preciseMul(rebalanceInfo.borrowBalance);\n        rebalanceInfo.setTotalSupply = strategy.setToken.totalSupply();\n\n        return rebalanceInfo;\n    }\n```\n\nlet us use the focus on the collateral price sacling\n\n```solidity\n  int256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\n        rebalanceInfo.collateralPrice = rawCollateralPrice.toUint256().mul(10 ** strategy.collateralDecimalAdjustment);\n```\n\nand the comment:\n\n```solidity\n// Calculate prices from chainlink. Chainlink returns prices with 8 decimal places, but we need 36 - underlyingDecimals decimal places.\n```\n\nso assume the chainlink return 8 decimals\n\nrawCollateral price is 8 decimals\n\nthe collateral decimal adjustment is (28 - token decimals), and the token decimal is regular 18\n\nthe collateral decimals adjustment is 10\n\nwe are using 8 decimals ** 10 ** 10, which is 18 decimals, for collateral value, this is fine, the math checkout\n\nHowever, chainlink oracle does not always return 8 decimals\n\nhttps://etherscan.io/address/0xe20CA8D7546932360e37E9D72c1a47334af57706#readContract\n\nthis is the AMPL / USD feed, but the decimals is 18 \n\nin this case, math does not work and the collateral value is not in 18 decimals (10e18)\n\nbeacuse we are using 18 decimals scaled by 10 decimals, which goes to 28 decimals\n\n## Impact\n\nbasically if one chainlink oracle is 18 decimals, the other is 8 decimals, or both are 18 decimals, the code does not work!\n\nif one chainlink oracle return 18 decimals, another return 8 decimals, the math below breaks\n\n```solidity\n   /**\n     * Derive the min repay units from collateral units for delever. Units are calculated as target collateral rebalance units multiplied by slippage tolerance\n     * and pair price (collateral oracle price / borrow oracle price). Output is measured in borrow unit decimals.\n     *\n     * return uint256           Min position units to repay in borrow asset\n     */\n    function _calculateMinRepayUnits(uint256 _collateralRebalanceUnits, uint256 _slippageTolerance, ActionInfo memory _actionInfo) internal pure returns (uint256) {\n        // @audit\n        // division before manipulation?\n        return _collateralRebalanceUnits\n            .preciseMul(_actionInfo.collateralPrice)\n            .preciseDiv(_actionInfo.borrowPrice)\n            .preciseMul(PreciseUnitMath.preciseUnit().sub(_slippageTolerance));\n    }\n```\n\nthere are also code such as \n\n```solidity\n  function _calculateCurrentLeverageRatio(\n        uint256 _collateralValue,\n        uint256 _borrowValue\n    )\n        internal\n        pure\n        returns(uint256)\n    {\n        // @audit\n        return _collateralValue.preciseDiv(_collateralValue.sub(_borrowValue));\n    }\n```\n\nif chainlink oracle is not 8 decimals, which result in collateral value or borrow value not in 10e18 decimals,\n\n```solidity\n_collateralValue.sub(_borrowValue)\n```\n\nwould not work\n\nif collateral value is 10e28, and borrow value is 10e18 decimals,\n\n```solidity\n_collateralValue.sub(_borrowValue)\n```\n\nis too small because 10e18 is neglible amotun comparing to 10e28\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L889\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWe recommend the protocol do not assume the chainlink oracle is 8 digitals, \n\nif the chainlink oracle return 18 decimals, not need to scale the chainlink price by adjustment decimals\n","decidedSeverity":"medium","decidedDuplication":"Wrongly assume chainlink oracle decimal is always 8"},{"file":"328.md","watson":{"name":"hildingr"},"severity":"medium","title":"Ripcord can be pulled when the sequencer is down","markdown":"hildingr\n\nmedium\n\n# Ripcord can be pulled when the sequencer is down\n\n## Summary\n\nAAVE3 has built-in safety features through their sentinel to protect users from being liquidated when a sequencer is down since the chainlink oracle pricing is unreliable. \n\nL1->L2 transactions can still trigger state changes on L2 when the sequencer is down. This means that re-balancing can be done based on stale prices.\n\n## Vulnerability Detail\n\nWhen the sequencer is down the chainlink oracle can return stale prices. L2 state changes can still be initiated from L1. This means that AaveLeverageStrategyExtension can still re-balance positions based on stale oracle prices.\n\n`rebalance()`, `iterateRebalance()` would only be at risk the extension if `anyoneCallable == True` . In such a case anybody could trigger erroneous balancing based on stale oracle prices. Any levering up will be blocked by AAVE3 but re-balancing to delever will be possible when the sequencer is down.\n\nThe most severe issue is the ability to call `ripcord()` based on stale prices since this can initiate aggressive re-balancing with large slippage that destroy NAV.\n\n## Impact\n\nThe most severe consequence is that `ripcord()` could be called when the sequencer is down and initiate aggressive re-balancing when the `ripcord()` would not be called if the oracle was reporting the correct information. `ripcord()` is a safety feature that can lead to NAV destruction since it has loose slippage requirement to allow for aggressive delivering.\n\nThe `ripcord()` should also take into account the grace period that AAVE3  has implemented where liquidations don't happen as long as the position is not heavily undercollateralized (0.95 < HF<1). The oracle price is still deemed unstable during this period which should be taken into account.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L376-L400\n## Tool used\n\nManual Review\n\n## Recommendation\n\nCheck if the sequencer is down such that re-balancing is not done based on stale pricing. The grace period should also be taken into account here since price data is still deemed unreliable during that period. ","decidedSeverity":"medium","decidedDuplication":"Missing checks for whether Arbitrum Sequencer is active"},{"file":"329.md","watson":{"name":"ShadowForce","days":56,"is_team":true,"payout":16317.49,"score":22.9570325496,"senior":false},"severity":"high","title":"Wrongly assume the token decimals is 18","markdown":"ShadowForce\n\nhigh\n\n# Wrongly assume the token decimals is 18\n\n## Summary\n\nWrongly assume the token decimals is 18\n\n## Vulnerability Detail\n\nvery important\n\n```solidity\nstruct ActionInfo {\n\tuint256 collateralBalance;                      // Balance of underlying held in Aave in base units (e.g. USDC 10e6)\n\tuint256 borrowBalance;                          // Balance of underlying borrowed from Aave in base units\n\tuint256 collateralValue;                        // Valuation in USD adjusted for decimals in precise units (10e18)\n\tuint256 borrowValue;                            // Valuation in USD adjusted for decimals in precise units (10e18)\n\tuint256 collateralPrice;                        // Price of collateral in precise units (10e18) from Chainlink\n\tuint256 borrowPrice;                            // Price of borrow asset in precise units (10e18) from Chainlink\n\tuint256 setTotalSupply;                         // Total supply of SetToken\n}\n```\n\nand\n\n```solidity\nstruct ContractSettings {\n\tISetToken setToken;                             // Instance of leverage token\n\tILeverageModule leverageModule;                 // Instance of Aave leverage module\n\tIProtocolDataProvider aaveProtocolDataProvider; // Instance of Aave protocol data provider\n\tIChainlinkAggregatorV3 collateralPriceOracle;   // Chainlink oracle feed that returns prices in 8 decimals for collateral asset\n\tIChainlinkAggregatorV3 borrowPriceOracle;       // Chainlink oracle feed that returns prices in 8 decimals for borrow asset\n\tIERC20 targetCollateralAToken;                  // Instance of target collateral aToken asset\n\tIERC20 targetBorrowDebtToken;                   // Instance of target borrow variable debt token asset\n\taddress collateralAsset;                        // Address of underlying collateral\n\taddress borrowAsset;                            // Address of underlying borrow asset\n\tuint256 collateralDecimalAdjustment;            // Decimal adjustment for chainlink oracle of the collateral asset. Equal to 28 - collateralDecimals (10^18 * 10^18 / 10^decimals / 10^8)\n\tuint256 borrowDecimalAdjustment;                // Decimal adjustment for chainlink oracle of the borrowing asset. Equal to 28 - borrowDecimals (10^18 * 10^18 / 10^decimals / 10^8)\n}\n```\n\nwe know \n\nuint256 collateralValue and uint256 borrowValue\n\nare both in 10e18\n\nand we have \n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L889\n\n```solidity\nuint256 collateralDecimalAdjustment;            // Decimal adjustment for chainlink oracle of the collateral asset. Equal to 28 - collateralDecimals (10^18 * 10^18 / 10^decimals / 10^8)\n\n\tuint256 borrowDecimalAdjustment;                // Decimal adjustment for chainlink oracle of the borrowing asset. Equal to 28 - borrowDecimals (10^18 * 10^18 / 10^decimals / 10^8)\n```\n\nthe decimal adjustment is (28 - decimal of token)\n\nok now let us proceed\n\nthis is important\n\n```solidity\n  function _createActionInfo() internal view returns(ActionInfo memory) {\n        ActionInfo memory rebalanceInfo;\n\n        // Calculate prices from chainlink. Chainlink returns prices with 8 decimal places, but we need 36 - underlyingDecimals decimal places.\n        // This is so that when the underlying amount is multiplied by the received price, the collateral valuation is normalized to 36 decimals. \n        // To perform this adjustment, we multiply by 10^(36 - 8 - underlyingDecimals)\n        int256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\n        rebalanceInfo.collateralPrice = rawCollateralPrice.toUint256().mul(10 ** strategy.collateralDecimalAdjustment);\n        int256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer();\n        rebalanceInfo.borrowPrice = rawBorrowPrice.toUint256().mul(10 ** strategy.borrowDecimalAdjustment);\n\n        rebalanceInfo.collateralBalance = strategy.targetCollateralAToken.balanceOf(address(strategy.setToken));\n        rebalanceInfo.borrowBalance = strategy.targetBorrowDebtToken.balanceOf(address(strategy.setToken));\n        rebalanceInfo.collateralValue = rebalanceInfo.collateralPrice.preciseMul(rebalanceInfo.collateralBalance);\n        rebalanceInfo.borrowValue = rebalanceInfo.borrowPrice.preciseMul(rebalanceInfo.borrowBalance);\n        rebalanceInfo.setTotalSupply = strategy.setToken.totalSupply();\n\n        return rebalanceInfo;\n    }\n```\n\nlet us use the focus on the collateral price sacling\n\n```solidity\n  int256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\n        rebalanceInfo.collateralPrice = rawCollateralPrice.toUint256().mul(10 ** strategy.collateralDecimalAdjustment);\n```\n\nand the comment:\n\n```solidity\n// Calculate prices from chainlink. Chainlink returns prices with 8 decimal places, but we need 36 - underlyingDecimals decimal places.\n```\n\nso assume the chainlink return 8 decimals\n\nrawCollateral price is 8 decimals\n\nthe collateral decimal adjustment is (28 - token decimals), and the token decimal is regular 18\n\nthe collateral decimals adjustment is 10\n\nwe are using 8 decimals ** 10 ** 10, which is 18 decimals, for collateral value, this is fine, the math checkout\n\nHowever, token decimal does not have to be 18,\n\nif the token decimal is 6, the math does not work\n\nfor example, if the token decimal is 6\n\n28 - 6 = 22, the decimal adjustment is 22\n\nand 8 decimals * 10 ** 22 = 10e32, \n\n## Impact\n\nif the collateral token decimal is not 18, the code does not work because of the incorrect scaling of the oracle price\n\n```solidity\n   /**\n     * Derive the min repay units from collateral units for delever. Units are calculated as target collateral rebalance units multiplied by slippage tolerance\n     * and pair price (collateral oracle price / borrow oracle price). Output is measured in borrow unit decimals.\n     *\n     * return uint256           Min position units to repay in borrow asset\n     */\n    function _calculateMinRepayUnits(uint256 _collateralRebalanceUnits, uint256 _slippageTolerance, ActionInfo memory _actionInfo) internal pure returns (uint256) {\n        // @audit\n        // division before manipulation?\n        return _collateralRebalanceUnits\n            .preciseMul(_actionInfo.collateralPrice)\n            .preciseDiv(_actionInfo.borrowPrice)\n            .preciseMul(PreciseUnitMath.preciseUnit().sub(_slippageTolerance));\n    }\n```\n\nthere are also code such as \n\n```solidity\n  function _calculateCurrentLeverageRatio(\n        uint256 _collateralValue,\n        uint256 _borrowValue\n    )\n        internal\n        pure\n        returns(uint256)\n    {\n        // @audit\n        return _collateralValue.preciseDiv(_collateralValue.sub(_borrowValue));\n    }\n```\n\nif token decimals is not 18, which result in collateral value or borrow value not in 10e18 decimals,\n\n```solidity\n_collateralValue.sub(_borrowValue)\n```\n\nwould not work\n\nif collateral value is 10e32, and borrow value is 10e18 decimals,\n\n```solidity\n_collateralValue.sub(_borrowValue)\n```\n\nis too small because 10e18 is neglible amotun comparing to 10e32\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L889\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nWe recommend the protocol does not use 28 - token decimals for decimal adjustment\n","decidedSeverity":"medium","decidedDuplication":"Wrongly assume chainlink oracle decimal is always 8"},{"file":"330.md","watson":{"name":"whitehat","days":7,"is_team":false,"payout":8620.69,"score":93.4676530059,"senior":false},"severity":"high","title":"Protocol can fall into situation that ripcord reward are all drained","markdown":"whitehat\n\nhigh\n\n# Protocol can fall into situation that ripcord reward are all drained\n\n## Summary\n\nWhen the difference between collateralValue and borrowValue goes small, the `ripcord` can be called infinitely.\n\n\n## Vulnerability Detail\n\nLet's assume this scenario:\nSetting: 1 eth = 1000 usdc, initialCollateral 1 eth, targetLeverageRatio: 1.8, LTV 0.8, IncentivedRatio: 2\n-> borrow 800 usdc and swap into 0.8 eth and deposit all.\n== Position is 1.8 eth equity, 800 usdc debt ==\nNow eth price went down, 1.8 eth = 1010 usdc\ncurrentLeverateRatio = 1010 / (1010-800) = 4.80\n-> ripcord\nmaxBorrowInUsdc = 1010 * 0.8 - 800 = 8\n== Position is 1.785 eth equity, 792 usdc debt, currentLeverageRatio: 4.77 ==\n-> ripcord\n...\n\n## Impact\n\nPrice of assets changes dramatically for many external reasons and this situation is not \"hardly happening\" one.\n- To fully adjust ratio to safe level, it might need to take even hundreds of ripcord action. This means \"Denial of service\" of whole protocol due to incentivizedTwapCooldownPeriod.\n- Rewards are sent same amount everytime of ripcord while the it can only decrease ratio very small amount. It could lead to very inefficient loss of eth.\n\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L376-L400\n\n```solidity\n    function ripcord(string memory _exchangeName) external onlyEOA {\n        LeverageInfo memory leverageInfo = _getAndValidateLeveragedInfo(\n            incentive.incentivizedSlippageTolerance,\n            exchangeSettings[_exchangeName].incentivizedTwapMaxTradeSize,\n            _exchangeName\n        );\n\n        // Use the exchangeLastTradeTimestamp so it can ripcord quickly with multiple exchanges\n        _validateRipcord(leverageInfo, exchangeSettings[_exchangeName].exchangeLastTradeTimestamp);\n\n        ( uint256 chunkRebalanceNotional, ) = _calculateChunkRebalanceNotional(leverageInfo, methodology.maxLeverageRatio, false);\n\n        _delever(leverageInfo, chunkRebalanceNotional);\n\n        _updateRipcordState(_exchangeName);\n\n        uint256 etherTransferred = _transferEtherRewardToCaller(incentive.etherReward);\n\n        emit RipcordCalled(\n            leverageInfo.currentLeverageRatio,\n            methodology.maxLeverageRatio,\n            chunkRebalanceNotional,\n            etherTransferred\n        );\n    }\n```\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1019-L1028\n```solidity\n    function _calculateCurrentLeverageRatio(\n        uint256 _collateralValue,\n        uint256 _borrowValue\n    )\n        internal\n        pure\n        returns(uint256)\n    {\n        return _collateralValue.preciseDiv(_collateralValue.sub(_borrowValue));\n    }\n```\n## Tool used\n\nManual Review\n\n## Recommendation\nAs Ripcord is emergency situation, we can/should\n- remove incentivizedTwapCooldownPeriod\n- iterate ripcord until it gets to maxRatio or can't delever any more.\n\nOr we can make new function iterateRipcord with onlyOperator for these cases specifically\n","decidedSeverity":"false","decidedDuplication":"Protocol can fall into situation that ripcord reward are all drained"},{"file":"331.md","watson":{"name":"BugBusters"},"severity":"high","title":"Wrong modifier is being used in interactManager() function","markdown":"BugBusters\n\nhigh\n\n# Wrong modifier is being used in interactManager() function\n\n## Summary\n`onlyExtension` modifier is being used instead of `onlyAdapter` modifier in interactManager() function\n\n## Vulnerability Detail\nThe `interactManager()` function in `BaseManagerV2.sol` has a discrepancy between the comments and its implementation. According to the comments, the function should only be called by `onlyAdapter`. However, the code uses the `onlyExtension` modifier instead of the correct `onlyAdapter` modifier. This incorrect modifier allows unintended individuals to invoke the function, potentially leading to unforeseen consequences and unexpected behavior.\n\n\n## Impact\nThis inconsistency raises concerns about the security and integrity of the contract. If unauthorized entities can access and interact with the manager through this function, it could result in unintended actions and even loss of funds.\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/manager/BaseManagerV2.sol#L300\n\n## Tool used\n\nManual Review\n\n## Recommendation\nMake sure that you are using the correct modifier as according with natspec","decidedSeverity":"false","decidedDuplication":"Wrong modifier is being used in interactManager() function"},{"file":"332.md","watson":{"name":"whitehat","days":7,"is_team":false,"payout":8620.69,"score":93.4676530059,"senior":false},"severity":"high","title":"Deprecated oracle function `latestAnswer()` could bring fund loss","markdown":"whitehat\n\nhigh\n\n# Deprecated oracle function `latestAnswer()` could bring fund loss\n\n## Summary\n\nUsing ChainlinkOracle's deprecated function `latestAnswer()` instead of `latestRoundData`, the prices can be zero.\n\n## Vulnerability Detail\n\nChainlinkOracle's latestAnswer is deprecated for its security risk that returns 0 when no answer is reached.\nThis means `rawCollateralPrice`, `rawBorrowPrice` can be zero and could lead to different kinds of mal-actions.\nThis is why Aave and all other protocols have strong validation after price feteched when using this deprecated function.\n\n\n## Impact\n\nProtocol can be broken\n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L889-L908\n```solidity\n    int256 rawCollateralPrice = strategy.collateralPriceOracle.latestAnswer();\n\n    rebalanceInfo.collateralPrice = rawCollateralPrice.toUint256().mul(\n        10 ** strategy.collateralDecimalAdjustment\n    );\n    int256 rawBorrowPrice = strategy.borrowPriceOracle.latestAnswer();\n```\n\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse `latestRoundData` or add validation like\n```solidity\nif (rawCollateralPrice > 0)\n```\n","decidedSeverity":"medium","decidedDuplication":"Deprecated oracle function `latestAnswer()` could bring fund loss"},{"file":"333.md","watson":{"name":"whitehat","days":7,"is_team":false,"payout":8620.69,"score":93.4676530059,"senior":false},"severity":"high","title":"removeExtension should validate if the extension is completely paused","markdown":"whitehat\n\nhigh\n\n# removeExtension should validate if the extension is completely paused\n\n## Summary\nWhile having debt position and even in rebalancing at Extension, the Manager just removes extension from it. It makes later extensions can't start/engage.\n\n\n## Vulnerability Detail\nLet's see Manager.removeModule()\nIt calls setToken.removeModule() and it calls module.removeModule() to finalize things before being removed.\nThis tells us that, Operator can call remove functions without enough preparation, by mistake or some other reasons.\nBut Manager.removeExtension() doesn't have this step and just remove.\nExtension can in various situations that can not be removed.\nIf Extension makes setToken have debt position and it's suddenly removed from module,\nthen setToken's debtPosition can't be removed as new extension can't even start/engage.\n\n\n## Impact\nProtocol not working\nDenial of Service\nLocked funds\n\n\n## Code Snippet\nThere are many places that remove extension in BaseManagerV2.sol.\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/manager/BaseManagerV2.sol#L337-L340\n```solidity\nfunction removeModule(address _module) external onlyOperator {\n    require(!protectedModules[_module].isProtected, \"Module protected\");\n    setToken.removeModule(_module);\n}\n```\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/manager/BaseManagerV2.sol#L240-L249\n```solidity\nfunction removeExtension(address _extension) external onlyOperator {\n    require(isExtension[_extension], \"Extension does not exist\");\n    require(!_isAuthorizedExtension(_extension), \"Extension used by protected module\");\n\n    extensions.removeStorage(_extension);\n\n    isExtension[_extension] = false;\n\n    emit ExtensionRemoved(_extension);\n}\n```\nhttps://github.com/sherlock-audit/2023-05-Index/blob/main/index-coop-smart-contracts/contracts/manager/BaseManagerV2.sol#L286-L287\n```solidity\nfunction revokeExtensionAuthorization(address _module, address _extension)\n    external\n    mutualUpgrade(operator, methodologist)\n{\n    require(protectedModules[_module].isProtected, \"Module not protected\");\n    require(isExtension[_extension], \"Extension does not exist\");\n    require(protectedModules[_module].authorizedExtensions[_extension], \"Extension not authorized\");\n\n    protectedModules[_module].authorizedExtensions[_extension] = false;\n    protectedModules[_module].authorizedExtensionsList.removeStorage(_extension);\n\n    emit ExtensionAuthorizationRevoked(_module, _extension);\n}\n```\n\n## Tool used\n\nManual Review\n\n\n## Recommendation\n\nLike removeModule, removeExtension should call extension.removeExtension that does finalization process (e,g disengage).\n","decidedSeverity":"false","decidedDuplication":"removeExtension should validate if the extension is completely paused"},{"file":"334.md","watson":{"name":"hildingr"},"severity":"high","title":"Wrong LTV and threshold LTV when in E-Mode","markdown":"hildingr\n\nhigh\n\n# Wrong LTV and threshold LTV when in E-Mode\n\n## Summary\n\nThe AaveLeverageStrategyExtension uses`aaveProtocolDataProvider.getReserveConfigurationData` to get the LTV and threshold LTV which are the incorrect numbers when using E Mode. \n\nThis upgrade to the Index-protocol is built to support E mode to unlock higher leverage due to the higher LTV, this is not possible since the incorrect LTV is used. This discrepancy leads to multiple failures of core functionality since parameters will be set by the operator expecting the E-mode parameters.\n\n## Vulnerability Detail\n\nCurrently the `netBorrowLimit` and `netRepayLimit` are based on the non E-mode LTV and will therefore be smaller than they should be. \n\nMany functions do not work as they should due to the wrong LVT being used when in E-mode. In the below text, I define `baseLTV` as the LTV when not in E-Mode.\n\n1. If `targetLeverageRate`  > `baseLTV` we will perpetually be attempting to re-balancing without being able to do so because `borrowAmount` will eventually be 0  when we reach `baseLTV`. We never reach the expected leverage and re-balancing to increase LTV will fail. \n2. When in TWAP we can not change methodology settings. If `targetLeverageRate`  > `baseLTV` we will never leave TWAP and will be forced to use `ripcord()` or `disengage`.\n4. Delevering is throttled since `netRepayLimit` is wrong due to an incorrect liquidation threshold. Ripcord especially should deleverage as quickly as possible which is not possible puts users at increased risk of liquidation.\n\n## Impact\n\nThe core functionality that the protocol was designed for does not work. Many features do not function as expected. `ripcord()` and `disengage()` are throttled since `netRepayLimit` is lower than it should, this increases the risk of liquidation.\n\n## Code Snippet\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1098\n\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-coop-smart-contracts/contracts/adapters/AaveLeverageStrategyExtension.sol#L1102-L1118\n\n## Tool used\n\nManual Review\n\n## Recommendation\nGet the correct LTV and threshold LTV from `getEModeCategoryData()` in the AAVE3 pool when in E-Mode.\n","decidedSeverity":"false","decidedDuplication":"Wrong LTV and threshold LTV when in E-Mode"},{"file":"335.md","watson":{"name":"whitehat","days":7,"is_team":false,"payout":8620.69,"score":93.4676530059,"senior":false},"severity":"medium","title":"The trade transactions lack of expiration timestamp check","markdown":"whitehat\n\nmedium\n\n# The trade transactions lack of expiration timestamp check\n\n## Summary\n\nThe trade transactions(engage, disengage, rebalance, ripcord) lack of expiration timestamp check\n\n## Vulnerability Detail\n\nLet us look into the heavily forked Uniswap V2 contract addLiquidity function implementation\n\nhttps://github.com/Uniswap/v2-periphery/blob/0335e8f7e1bd1e8d8329fd300aea2ef2f36dd19f/contracts/UniswapV2Router02.sol#L61\n\n```solidity\n// **** ADD LIQUIDITY ****\nfunction _addLiquidity(\n\taddress tokenA,\n\taddress tokenB,\n\tuint amountADesired,\n\tuint amountBDesired,\n\tuint amountAMin,\n\tuint amountBMin\n) internal virtual returns (uint amountA, uint amountB) {\n\t// create the pair if it doesn't exist yet\n\tif (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {\n\t\tIUniswapV2Factory(factory).createPair(tokenA, tokenB);\n\t}\n\t(uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n\tif (reserveA == 0 && reserveB == 0) {\n\t\t(amountA, amountB) = (amountADesired, amountBDesired);\n\t} else {\n\t\tuint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);\n\t\tif (amountBOptimal <= amountBDesired) {\n\t\t\trequire(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n\t\t\t(amountA, amountB) = (amountADesired, amountBOptimal);\n\t\t} else {\n\t\t\tuint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);\n\t\t\tassert(amountAOptimal <= amountADesired);\n\t\t\trequire(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n\t\t\t(amountA, amountB) = (amountAOptimal, amountBDesired);\n\t\t}\n\t}\n}\n\nfunction addLiquidity(\n\taddress tokenA,\n\taddress tokenB,\n\tuint amountADesired,\n\tuint amountBDesired,\n\tuint amountAMin,\n\tuint amountBMin,\n\taddress to,\n\tuint deadline\n) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) {\n\t(amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n\taddress pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n\tTransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n\tTransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n\tliquidity = IUniswapV2Pair(pair).mint(to);\n}\n```\n\nthe implementation has two point that worth noting,\n\n**the first point is the deadline check**\n\n```solidity\nmodifier ensure(uint deadline) {\n\trequire(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');\n\t_;\n}\n```\n\nThe transaction can be pending in mempool for a long time and can be executed in a long time after the user submit the transaction.\n\nProblem is trade transactions here - engage/disengage/rebalance/ripcord.\n\ntrade functions accepts exchange as paramter.\nIf the transaction is delayed for long time (exchange market goes bad), the operator/user shouldn't have to call that trade.\n\n## Impact\nUn-intended trading result can happen for operators/users.\nAs this is for rare case that transaction stays in mempool, it's Medium severity.\n\n## Code Snippet\n```solidity\nfunction engage(string memory _exchangeName) external onlyOperator {\n\nfunction rebalance(string memory _exchangeName) external onlyEOA onlyAllowedCaller(msg.sender) {\n```\n\n## Tool used\n\nManual Review\n\n## Recommendation\n\nUse deadline, like uniswap\n\n","decidedSeverity":"medium","decidedDuplication":"The trade transactions lack of expiration timestamp check"},{"file":"336.md","watson":{"name":"Saeedalipoor01988"},"severity":"medium","title":"Missing check AMM Pools balance before changes manager address","markdown":"Saeedalipoor01988\n\nmedium\n\n# Missing check AMM Pools balance before changes manager address\n\n## Summary\nIf SetToken has balance in the AMM Pools, and the manager of the setToken , change the address of the manager to the null address, then funds in the AMM Pools will be lost.\n\n## Vulnerability Detail\nThe manager of setToken **only** can use [addLiquidity ](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/AmmModule.sol#L107)function to add liquidity to an AMM pool for a specified AMM and liquidity token will send to the SetToken address.\n\nAlso, manager of setToken **only** can use [removeLiquidity ](https://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/AmmModule.sol#L205)function to removes liquidity from an AMM pool for a specified AMM.\n\n```solidity\n    /**\n     * MANAGER ONLY. Changes manager; We allow null addresses in case the manager wishes to wind down the SetToken.\n     * Modules may rely on the manager state, so only changable when unlocked\n     */\n    function setManager(address _manager) external onlyManager {\n        require(!isLocked, \"Only when unlocked\");\n        address oldManager = manager;\n        manager = _manager;\n\n        emit ManagerEdited(_manager, oldManager);\n    }\n```\n\nAbove function is using to changes manager and null address is allowed. when manager address get change to the null address, no one can call removeLiquidity.\n\n## Impact\nIn the condition that the setToken has a balance in the AMM Pools, If manager of the setToken , change the address of the manager to the null address, without checking balance, funds in the AMM Pools will be lost. \n\n## Code Snippet\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/SetToken.sol#L420\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/modules/v1/AmmModule.sol#L216\nhttps://github.com/sherlock-audit/2023-05-Index/blob/3190057afd3085143a31746d65045a0d1bacc78c/index-protocol/contracts/protocol/lib/ModuleBase.sol#L64\n\n## Tool used\nManual Review\n\n## Recommendation\nAdd check for setToken balance in the AMM Pools before allow manager to change manager address to the null address.","decidedSeverity":"false","decidedDuplication":"Missing check AMM Pools balance before changes manager address"},{"file":"337.md","watson":{"name":"MohammedRizwan"},"severity":"medium","title":"Wrong use of access modifier on BaseManagerV2.transferTokens() function","markdown":"MohammedRizwan\n\nmedium\n\n# Wrong use of access modifier on BaseManagerV2.transferTokens() function\n\n## Summary\nWrong use of access modifier on BaseManagerV2.transferTokens() function\n\n## Vulnerability Detail\n## Impact\nIn BaseManagerV2.sol contract, transferTokens() function is given as below,\n\n```solidity\nFile: contracts/manager/BaseManagerV2.sol\n\n309    /**\n310     * OPERATOR ONLY: Transfers _tokens held by the manager to _destination. Can be used to\n311     * recover anything sent here accidentally. In BaseManagerV2, extensions should\n312     * be the only contracts designated as `feeRecipient` in fee modules.\n313     *\n314     * @param _token           ERC20 token to send\n315     * @param _destination     Address receiving the tokens\n316     * @param _amount          Quantity of tokens to send\n317     */\n318    function transferTokens(address _token, address _destination, uint256 _amount) external onlyExtension {\n319        IERC20(_token).safeTransfer(_destination, _amount);\n320    }\n321\n322    /**\n```\nAs seen above at L-318, transferTokens() function has used onlyExtension  modifier which is wrong use as per NatSpec comment.\n\nat L-310, the function NatSpec comments says, OPERATOR ONLY modifier to be used on transferTokens(),\n\nonlyOperator modifier is given as below,\n\n```solidity\nFile: contracts/manager/BaseManagerV2.sol\n\n    /**\n     * Throws if the sender is not the SetToken operator\n     */\n    modifier onlyOperator() {\n        require(msg.sender == operator, \"Must be operator\");\n        _;\n    }\n```\n\n## Code Snippet\nCode Link-\nhttps://github.com/IndexCoop/index-coop-smart-contracts/blob/317dfb677e9738fc990cf69d198358065e8cb595/contracts/manager/BaseManagerV2.sol#L309-L322\n\n## Tool used\nManual Review\n\n## Recommendation\nUse onlyOperator modifier on transferTokens() instead of onlyExtension modifier.\n\n\n```solidity\nFile: contracts/manager/BaseManagerV2.sol\n\n-    function transferTokens(address _token, address _destination, uint256 _amount) external onlyExtension {\n+    function transferTokens(address _token, address _destination, uint256 _amount) external onlyOperator {\n        IERC20(_token).safeTransfer(_destination, _amount);\n    }\n```\n","decidedSeverity":"medium","decidedDuplication":"Wrong modifier in `transferTokens()`"},{"file":"338.md","watson":{"name":"Angry_Mustache_Man"},"severity":"medium","title":"Use BTC/USD chainlink oracle to price WBTC which is problematic if WBTC depegs","markdown":"Angry_Mustache_Man\n\nmedium\n\n# Use BTC/USD chainlink oracle to price WBTC which is problematic if WBTC depegs\n\n## Summary\nThe chainlink BTC/USD oracle is used to price WBTC as there is no WBTC/USD available in chainlink. WBTC is basically a bridged asset and if the bridge is compromised/fails then WBTC will depeg and will no longer be equivalent to BTC. This will lead to large amounts of borrowing against an asset that is now effectively worthless. Since the protocol still values it via BTC/USD the protocol will not only be stuck with the bad debt caused by the currently outstanding loans but they will also continue to give out bad loans and increase the amount of bad debt further\n## Vulnerability Detail\nSee summary.\n## Impact\nProtocol will take on a large amount of bad debt should WBTC bridge become compromised and WBTC depegs\n\n## Tool used\n\nManual Review\n\n## Recommendation\nI would recommend using a double oracle setup. Use both the Chainlink and another on-chain liquidity base oracle (i.e. UniV3 TWAP). If the price of the on-chain liquidity oracle drops below a certain threshold of the Chainlink oracles (i.e. 2% lower), any borrowing should be immediately halted. The chainlink oracle will prevent price manipulation and the liquidity oracle will safeguard against the asset depegging.","decidedSeverity":"false","decidedDuplication":"Use BTC/USD chainlink oracle to price WBTC which is problematic if WBTC depegs"}]}